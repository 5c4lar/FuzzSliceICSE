{
    "git log -L350,383:crypto/ts/ts_rsp_verify.c": [
        {
            "author": {
                "email": "graeme.perrow@sap.com",
                "name": "Graeme Perrow"
            },
            "changes": "diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c--- a/crypto/ts/ts_rsp_verify.c+++ b/crypto/ts/ts_rsp_verify.c@@ -435,34 +432,34 @@ static int ts_check_status_info(TS_RESP *response) {-    if (0 <= status && status < (long)TS_STATUS_TEXT_SIZE)+    if (0 <= status && status < (long) OSSL_NELEM(ts_status_text))-                    strcpy(failure_text, \",\");+                    strcat(failure_text, \",\");",
            "commit_date": "2015-11-01 20:15:23-05:00",
            "commit_hash": "0704343f138a38d3882d5af2a4ebe8821e9a8f3a",
            "message": "RT32671: wrong multiple errs TS_check_status_info\nReviewed-by: Tim Hudson <tjh@openssl.org>\nSigned-off-by: Rich Salz <rsalz@openssl.org>\nTS_STATUS_INFO *info = response->status_info;\nlong status = ASN1_INTEGER_get(info->status);\nconst char *status_text = NULL;\nchar *embedded_status_text = NULL;\nchar failure_text[TS_STATUS_BUF_SIZE] = \"\";\nif (status == 0 || status == 1)\nreturn 1;\n/* There was an error, get the description in status_text. */\nstatus_text = ts_status_text[status];\nelse\nstatus_text = \"unknown code\";\nif (sk_ASN1_UTF8STRING_num(info->text) > 0\n&& (embedded_status_text = ts_get_status_text(info->text)) == NULL)\nreturn 0;\n/* Fill in failure_text with the failure information. */\nif (info->failure_info) {\nint i;\nint first = 1;\nfor (i = 0; i < (int)OSSL_NELEM(ts_failure_info); ++i) {\nif (ASN1_BIT_STRING_get_bit(info->failure_info,\nts_failure_info[i].code)) {\nif (!first)\nelse\nfirst = 0;\nstrcat(failure_text, ts_failure_info[i].text);"
        },
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c--- a/crypto/ts/ts_rsp_verify.c+++ b/crypto/ts/ts_rsp_verify.c@@ -477,36 +433,34 @@ static int ts_check_status_info(TS_RESP *response) {-    /* Check if everything went fine. */-    /* Set the embedded_status_text to the returned description. */-    /* Filling in failure_text with the failure information. */+    /* Fill in failure_text with the failure information. */-        for (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i) {+        for (i = 0; i < (int)OSSL_NELEM(ts_failure_info); ++i) {",
            "commit_date": "2015-05-07 23:41:07-04:00",
            "commit_hash": "18cd23df8a8f2edd800182e1ab62111e4b7f1dbe",
            "message": "Remove \"noise\" comments from TS files.\nReviewed-by: Tim Hudson <tjh@openssl.org>\nTS_STATUS_INFO *info = response->status_info;\nlong status = ASN1_INTEGER_get(info->status);\nconst char *status_text = NULL;\nchar *embedded_status_text = NULL;\nchar failure_text[TS_STATUS_BUF_SIZE] = \"\";\nif (status == 0 || status == 1)\nreturn 1;\n/* There was an error, get the description in status_text. */\nif (0 <= status && status < (long)TS_STATUS_TEXT_SIZE)\nstatus_text = ts_status_text[status];\nelse\nstatus_text = \"unknown code\";\nif (sk_ASN1_UTF8STRING_num(info->text) > 0\n&& (embedded_status_text = ts_get_status_text(info->text)) == NULL)\nreturn 0;\nif (info->failure_info) {\nint i;\nint first = 1;\nif (ASN1_BIT_STRING_get_bit(info->failure_info,\nts_failure_info[i].code)) {\nif (!first)\nstrcpy(failure_text, \",\");\nelse\nfirst = 0;\nstrcat(failure_text, ts_failure_info[i].text);"
        },
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c--- a/crypto/ts/ts_rsp_verify.c+++ b/crypto/ts/ts_rsp_verify.c@@ -476,36 +477,36 @@ static int ts_check_status_info(TS_RESP *response) {-    TS_STATUS_INFO *info = TS_RESP_get_status_info(response);+    TS_STATUS_INFO *info = response->status_info;",
            "commit_date": "2015-06-10 14:07:40-04:00",
            "commit_hash": "ca4a494cb7437a7af155361b0084de8329c0bf25",
            "message": "Make TS structures opaque.\nMost of the accessors existed and were already used so it was easy.\nTS_VERIFY_CTX didn't have accessors/settors so I added the simple and\nobvious ones, and changed the app to use them.  Also, within crypto/ts,\nreplaced the functions with direct access to the structure members\nsince we generally aren't opaque within a directory.\nAlso fix RT3901.\nReviewed-by: Tim Hudson <tjh@openssl.org>\nlong status = ASN1_INTEGER_get(info->status);\nconst char *status_text = NULL;\nchar *embedded_status_text = NULL;\nchar failure_text[TS_STATUS_BUF_SIZE] = \"\";\n/* Check if everything went fine. */\nif (status == 0 || status == 1)\nreturn 1;\n/* There was an error, get the description in status_text. */\nif (0 <= status && status < (long)TS_STATUS_TEXT_SIZE)\nstatus_text = ts_status_text[status];\nelse\nstatus_text = \"unknown code\";\n/* Set the embedded_status_text to the returned description. */\nif (sk_ASN1_UTF8STRING_num(info->text) > 0\n&& (embedded_status_text = ts_get_status_text(info->text)) == NULL)\nreturn 0;\n/* Filling in failure_text with the failure information. */\nif (info->failure_info) {\nint i;\nint first = 1;\nfor (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i) {\nif (ASN1_BIT_STRING_get_bit(info->failure_info,\nts_failure_info[i].code)) {\nif (!first)\nstrcpy(failure_text, \",\");\nelse\nfirst = 0;\nstrcat(failure_text, ts_failure_info[i].text);"
        },
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c--- a/crypto/ts/ts_rsp_verify.c+++ b/crypto/ts/ts_rsp_verify.c@@ -493,36 +476,36 @@-static int TS_check_status_info(TS_RESP *response)+static int ts_check_status_info(TS_RESP *response) {-        status_text = TS_status_text[status];+        status_text = ts_status_text[status];-        && (embedded_status_text = TS_get_status_text(info->text)) == NULL)+        && (embedded_status_text = ts_get_status_text(info->text)) == NULL)-                                        TS_failure_info[i].code)) {+                                        ts_failure_info[i].code)) {-                strcat(failure_text, TS_failure_info[i].text);+                strcat(failure_text, ts_failure_info[i].text);",
            "commit_date": "2015-06-03 22:04:48-04:00",
            "commit_hash": "9c422b5b1ebc9871a7306f66648aa16c8769082a",
            "message": "Rename all static TS_xxx to ts_xxx\nReviewed-by: Richard Levitte <levitte@openssl.org>\nTS_STATUS_INFO *info = TS_RESP_get_status_info(response);\nlong status = ASN1_INTEGER_get(info->status);\nconst char *status_text = NULL;\nchar *embedded_status_text = NULL;\nchar failure_text[TS_STATUS_BUF_SIZE] = \"\";\n/* Check if everything went fine. */\nif (status == 0 || status == 1)\nreturn 1;\n/* There was an error, get the description in status_text. */\nif (0 <= status && status < (long)TS_STATUS_TEXT_SIZE)\nelse\nstatus_text = \"unknown code\";\n/* Set the embedded_status_text to the returned description. */\nif (sk_ASN1_UTF8STRING_num(info->text) > 0\nreturn 0;\n/* Filling in failure_text with the failure information. */\nif (info->failure_info) {\nint i;\nint first = 1;\nfor (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i) {\nif (ASN1_BIT_STRING_get_bit(info->failure_info,\nif (!first)\nstrcpy(failure_text, \",\");\nelse\nfirst = 0;"
        },
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c--- a/crypto/ts/ts_rsp_verify.c+++ b/crypto/ts/ts_rsp_verify.c@@ -493,36 +493,36 @@ static int TS_check_status_info(TS_RESP *response) {-        && !(embedded_status_text = TS_get_status_text(info->text)))+        && (embedded_status_text = TS_get_status_text(info->text)) == NULL)",
            "commit_date": "2015-05-06 13:43:59-04:00",
            "commit_hash": "75ebbd9aa411c5b8b19ded6ace2b34181566b56a",
            "message": "Use p==NULL not !p (in if statements, mainly)\nReviewed-by: Tim Hudson <tjh@openssl.org>\nTS_STATUS_INFO *info = TS_RESP_get_status_info(response);\nlong status = ASN1_INTEGER_get(info->status);\nconst char *status_text = NULL;\nchar *embedded_status_text = NULL;\nchar failure_text[TS_STATUS_BUF_SIZE] = \"\";\n/* Check if everything went fine. */\nif (status == 0 || status == 1)\nreturn 1;\n/* There was an error, get the description in status_text. */\nif (0 <= status && status < (long)TS_STATUS_TEXT_SIZE)\nstatus_text = TS_status_text[status];\nelse\nstatus_text = \"unknown code\";\n/* Set the embedded_status_text to the returned description. */\nif (sk_ASN1_UTF8STRING_num(info->text) > 0\nreturn 0;\n/* Filling in failure_text with the failure information. */\nif (info->failure_info) {\nint i;\nint first = 1;\nfor (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i) {\nif (ASN1_BIT_STRING_get_bit(info->failure_info,\nTS_failure_info[i].code)) {\nif (!first)\nstrcpy(failure_text, \",\");\nelse\nfirst = 0;\nstrcat(failure_text, TS_failure_info[i].text);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ts/ts_rsp_verify.c b/crypto/ts/ts_rsp_verify.c--- a/crypto/ts/ts_rsp_verify.c+++ b/crypto/ts/ts_rsp_verify.c@@ -478,55 +493,36 @@ static int TS_check_status_info(TS_RESP *response)-\t{-\tTS_STATUS_INFO *info = TS_RESP_get_status_info(response);-\tlong status = ASN1_INTEGER_get(info->status);-\tconst char *status_text = NULL;-\tchar *embedded_status_text = NULL;-\tchar failure_text[TS_STATUS_BUF_SIZE] = \"\";--\t/* Check if everything went fine. */-\tif (status == 0 || status == 1) return 1;--\t/* There was an error, get the description in status_text. */-\tif (0 <= status && status < (long)TS_STATUS_TEXT_SIZE)-\t\tstatus_text = TS_status_text[status];-\telse-\t\tstatus_text = \"unknown code\";--\t/* Set the embedded_status_text to the returned description. */-\tif (sk_ASN1_UTF8STRING_num(info->text) > 0-\t    && !(embedded_status_text = TS_get_status_text(info->text)))-\t\treturn 0;-\t-\t/* Filling in failure_text with the failure information. */-\tif (info->failure_info)-\t\t{-\t\tint i;-\t\tint first = 1;-\t\tfor (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i)-\t\t\t{-\t\t\tif (ASN1_BIT_STRING_get_bit(info->failure_info,-\t\t\t\t\t\t    TS_failure_info[i].code))-\t\t\t\t{-\t\t\t\tif (!first)-\t\t\t\t\tstrcpy(failure_text, \",\");-\t\t\t\telse-\t\t\t\t\tfirst = 0;-\t\t\t\tstrcat(failure_text, TS_failure_info[i].text);-\t\t\t\t}-\t\t\t}-\t\t}-\tif (failure_text[0] == '\\0')-\t\tstrcpy(failure_text, \"unspecified\");--\t/* Making up the error string. */-\tTSerr(TS_F_TS_CHECK_STATUS_INFO, TS_R_NO_TIME_STAMP_TOKEN);-\tERR_add_error_data(6,-\t\t\t   \"status code: \", status_text,-\t\t\t   \", status text: \", embedded_status_text ? -\t\t\t   embedded_status_text : \"unspecified\",-\t\t\t   \", failure codes: \", failure_text);-\tOPENSSL_free(embedded_status_text);--\treturn 0;-\t}+{+    TS_STATUS_INFO *info = TS_RESP_get_status_info(response);+    long status = ASN1_INTEGER_get(info->status);+    const char *status_text = NULL;+    char *embedded_status_text = NULL;+    char failure_text[TS_STATUS_BUF_SIZE] = \"\";++    /* Check if everything went fine. */+    if (status == 0 || status == 1)+        return 1;++    /* There was an error, get the description in status_text. */+    if (0 <= status && status < (long)TS_STATUS_TEXT_SIZE)+        status_text = TS_status_text[status];+    else+        status_text = \"unknown code\";++    /* Set the embedded_status_text to the returned description. */+    if (sk_ASN1_UTF8STRING_num(info->text) > 0+        && !(embedded_status_text = TS_get_status_text(info->text)))+        return 0;++    /* Filling in failure_text with the failure information. */+    if (info->failure_info) {+        int i;+        int first = 1;+        for (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i) {+            if (ASN1_BIT_STRING_get_bit(info->failure_info,+                                        TS_failure_info[i].code)) {+                if (!first)+                    strcpy(failure_text, \",\");+                else+                    first = 0;+                strcat(failure_text, TS_failure_info[i].text);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ts/ts_resp_verify.c b/crypto/ts/ts_resp_verify.c--- /dev/null+++ b/crypto/ts/ts_resp_verify.c@@ -0,0 +478,55 @@++static int TS_check_status_info(TS_RESP *response)+\t{+\tTS_STATUS_INFO *info = TS_RESP_get_status_info(response);+\tlong status = ASN1_INTEGER_get(info->status);+\tconst char *status_text = NULL;+\tchar *embedded_status_text = NULL;+\tchar failure_text[TS_STATUS_BUF_SIZE] = \"\";++\t/* Check if everything went fine. */+\tif (status == 0 || status == 1) return 1;++\t/* There was an error, get the description in status_text. */+\tif (0 <= status && status < (long)TS_STATUS_TEXT_SIZE)+\t\tstatus_text = TS_status_text[status];+\telse+\t\tstatus_text = \"unknown code\";++\t/* Set the embedded_status_text to the returned description. */+\tif (sk_ASN1_UTF8STRING_num(info->text) > 0+\t    && !(embedded_status_text = TS_get_status_text(info->text)))+\t\treturn 0;+\t+\t/* Filling in failure_text with the failure information. */+\tif (info->failure_info)+\t\t{+\t\tint i;+\t\tint first = 1;+\t\tfor (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i)+\t\t\t{+\t\t\tif (ASN1_BIT_STRING_get_bit(info->failure_info,+\t\t\t\t\t\t    TS_failure_info[i].code))+\t\t\t\t{+\t\t\t\tif (!first)+\t\t\t\t\tstrcpy(failure_text, \",\");+\t\t\t\telse+\t\t\t\t\tfirst = 0;+\t\t\t\tstrcat(failure_text, TS_failure_info[i].text);+\t\t\t\t}+\t\t\t}+\t\t}+\tif (failure_text[0] == '\\0')+\t\tstrcpy(failure_text, \"unspecified\");++\t/* Making up the error string. */+\tTSerr(TS_F_TS_CHECK_STATUS_INFO, TS_R_NO_TIME_STAMP_TOKEN);+\tERR_add_error_data(6,+\t\t\t   \"status code: \", status_text,+\t\t\t   \", status text: \", embedded_status_text ? +\t\t\t   embedded_status_text : \"unspecified\",+\t\t\t   \", failure codes: \", failure_text);+\tOPENSSL_free(embedded_status_text);++\treturn 0;+\t}",
            "commit_date": "2006-02-12 23:11:56+00:00",
            "commit_hash": "c7235be6e36c4bef84594aa3b2f0561db84b63d8",
            "message": "RFC 3161 compliant time stamp request creation, response generation\nand response verification.\nSubmitted by: Zoltan Glozik <zglozik@opentsa.org>\nReviewed by: Ulf Moeller"
        }
    ],
    "git log -L164,176:test/sslapitest.c": [
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -87,13 +87,13 @@ static void server_keylog_callback(const SSL *ssl, const char *line) {-        TEST_info(\"Server og too full\");+        TEST_info(\"Server log too full\");",
            "commit_date": "2017-08-12 20:02:24+02:00",
            "commit_hash": "bdcacd93b14ed7381a922b41d74c481224ef9fa1",
            "message": "Fix some typo and comments\n[skip ci]\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4149)\nint line_length = strlen(line);\n/* If the log doesn't fit, error out. */\nif (server_log_buffer_index + line_length > sizeof(server_log_buffer) - 1) {\nerror_writing_log = 1;\nreturn;\n}\nstrcat(server_log_buffer, line);"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -73,12 +71,13 @@-static void server_keylog_callback(const SSL *ssl, const char *line) {+static void server_keylog_callback(const SSL *ssl, const char *line)+{-    if ((server_log_buffer_index + line_length) > LOG_BUFFER_SIZE) {-        printf(\"No room in server log\\n\");+    if (server_log_buffer_index + line_length > sizeof(server_log_buffer) - 1) {+        TEST_info(\"Server og too full\");",
            "commit_date": "2017-04-26 13:24:37-04:00",
            "commit_hash": "710756a9b384c9e9eaaf42acaf429aebc2a822a1",
            "message": "Convert sslapitest to test framework\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3252)\nint line_length = strlen(line);\n/* If the log doesn't fit, error out. */\nerror_writing_log = 1;\nreturn;\n}\nstrcat(server_log_buffer, line);"
        },
        {
            "author": {
                "email": "lukasaoz@gmail.com",
                "name": "Cory Benfield"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -37,0 +61,12 @@++static void server_keylog_callback(const SSL *ssl, const char *line) {+    int line_length = strlen(line);++    /* If the log doesn't fit, error out. */+    if ((server_log_buffer_index + line_length) > LOG_BUFFER_SIZE) {+        printf(\"No room in server log\\n\");+        error_writing_log = 1;+        return;+    }++    strcat(server_log_buffer, line);",
            "commit_date": "2017-01-20 16:22:39+00:00",
            "commit_hash": "6acdd3e531e52173a0c76490c0aae3ecebe04a89",
            "message": "Add tests for the key logging callbacks.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1646)"
        }
    ],
    "git log -L148,160:test/sslapitest.c": [
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -113,12 +123,13 @@+ static void client_keylog_callback(const SSL *ssl, const char *line) {",
            "commit_date": "2020-02-04 17:11:07+00:00",
            "commit_hash": "104a733df65dfd8c3dd110de9bd56f6ebfc8f2f6",
            "message": "Fix no-tls1_3\nThe hostname_cb in sslapitest.c was originally only defined if TLSv1.3\nwas enabled. A recently added test now uses this unconditionally, so we\nmove the function implementation earlier in the file, and always compile\nit in.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/11014)\nint line_length = strlen(line);\n/* If the log doesn't fit, error out. */\nif (client_log_buffer_index + line_length > sizeof(client_log_buffer) - 1) {\nTEST_info(\"Client log too full\");\nerror_writing_log = 1;\nreturn;\n}\nstrcat(client_log_buffer, line);"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -56,11 +56,12 @@-static void client_keylog_callback(const SSL *ssl, const char *line) {+static void client_keylog_callback(const SSL *ssl, const char *line)+{-    if ((client_log_buffer_index + line_length) > LOG_BUFFER_SIZE) {-        printf(\"No room in client log\\n\");+    if (client_log_buffer_index + line_length > sizeof(client_log_buffer) - 1) {+        TEST_info(\"Client log too full\");",
            "commit_date": "2017-04-26 13:24:37-04:00",
            "commit_hash": "710756a9b384c9e9eaaf42acaf429aebc2a822a1",
            "message": "Convert sslapitest to test framework\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3252)\nint line_length = strlen(line);\n/* If the log doesn't fit, error out. */\nerror_writing_log = 1;\nreturn;\n}\nstrcat(client_log_buffer, line);"
        },
        {
            "author": {
                "email": "lukasaoz@gmail.com",
                "name": "Cory Benfield"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -37,0 +44,11 @@+static void client_keylog_callback(const SSL *ssl, const char *line) {+    int line_length = strlen(line);++    /* If the log doesn't fit, error out. */+    if ((client_log_buffer_index + line_length) > LOG_BUFFER_SIZE) {+        printf(\"No room in client log\\n\");+        error_writing_log = 1;+        return;+    }++    strcat(client_log_buffer, line);",
            "commit_date": "2017-01-20 16:22:39+00:00",
            "commit_hash": "6acdd3e531e52173a0c76490c0aae3ecebe04a89",
            "message": "Add tests for the key logging callbacks.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1646)"
        }
    ],
    "git log -L20,29:crypto/o_str.c": [
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/crypto/o_str.c b/crypto/o_str.c--- a/crypto/o_str.c+++ b/crypto/o_str.c@@ -15,9 +17,10 @@+ char *CRYPTO_strdup(const char *str, const char* file, int line) {",
            "commit_date": "2020-05-26 12:44:36+10:00",
            "commit_hash": "f32af93c924dca25728d8e7b85b8e4b660154e12",
            "message": "Fix ERR_print_errors so that it matches the documented format in doc/man3/ERR_error_string.pod\nFixes #11743\nThe ouput format had 2 issues that caused it not to match the expected documented format:\n(1) At some point the thread id printing was changed to use the OPENSSL_hex2str method which puts ':' between hex bytes.\nAn internal function that skips the seperator has been added.\n(2) The error code no longer exists. So this was completely removed from the string. It is now replaced by ::\nAs an example:\n00:77:6E:52:14:7F:00:00:error:asn1 encoding routines:asn1_check_tlen:wrong tag:crypto/asn1/tasn_dec.c:1135:\nIs now:\n00776E52147F0000:error::asn1 encoding routines:asn1_check_tlen:wrong tag:crypto/asn1/tasn_dec.c:1135:\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/11789)\nchar *ret;\nif (str == NULL)\nreturn NULL;\nret = CRYPTO_malloc(strlen(str) + 1, file, line);\nif (ret != NULL)\nstrcpy(ret, str);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/o_str.c b/crypto/o_str.c--- a/crypto/o_str.c+++ b/crypto/o_str.c@@ -15,0 +15,9 @@+char *CRYPTO_strdup(const char *str, const char* file, int line)+{+    char *ret;++    if (str == NULL)+        return NULL;+    ret = CRYPTO_malloc(strlen(str) + 1, file, line);+    if (ret != NULL)+        strcpy(ret, str);",
            "commit_date": "2019-07-22 15:19:02+01:00",
            "commit_hash": "037439c46addc62130617bbba8c5e58e1548bfd8",
            "message": "Remove some utilities from the core to provider interface\nThe core provides a number of essential functions as \"upcalls\" to\nproviders. Some of those were just utility functions that wrap other\nupcalls - which don't seem essential and bloat the interface. We should\nremove them in order to simplify the interface.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/9432)"
        }
    ],
    "git log -L479,495:test/endecode_test.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/endecode_test.c b/test/endecode_test.c--- a/test/endecode_test.c+++ b/test/endecode_test.c@@ -359,1 +368,17 @@+static void collect_name(const char *name, void *arg)+{+    char **namelist = arg;+    char *new_namelist;+    size_t space;++    space = strlen(name);+    if (*namelist != NULL)+        space += strlen(*namelist) + 2 /* for comma and space */;+    space++; /* for terminating null byte */++    new_namelist = OPENSSL_realloc(*namelist, space);+    if (new_namelist == NULL)+        return;+    if (*namelist != NULL) {+        strcat(new_namelist, \", \");",
            "commit_date": "2020-09-14 11:21:37+02:00",
            "commit_hash": "ae12eac074be92e14c11a36b90e1c95eca3723f1",
            "message": "TEST: Adapt applicable tests to the changed OSSL_ENCODER_CTX_new_by_EVP_PKEY()\nThis adds the convenience function EVP_PKEY_typenames_do_all(), which\ndoes the same as EVP_KEYMGMT_names_do_all(), but without having to\nexpose all the internal ways to find out if the internal EVP_PKEY key\nis legacy or provider-native.\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12873)"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/serdes_test.c b/test/serdes_test.c--- /dev/null+++ b/test/serdes_test.c@@ -0,0 +136,1 @@+",
            "commit_date": "2020-07-09 19:10:39+02:00",
            "commit_hash": "5a23d78c9b141e31ab9b7d551b2125b124a75e49",
            "message": "TEST: Add new serializer and deserializer test\nThis test revolves around a central function that will first serialize\nan EVP_PKEY, then deserialize the result into a new EVP_PKEY and\ncompare the two.\nThe following tests are currently implemented:\n1.  EVP_PKEY (RSA) -> DER, then DER -> EVP_PKEY (RSA).\n2.  EVP_PKEY (RSA) -> PEM, then PEM -> EVP_PKEY (RSA).\nThis one exercises deserializer chains, as we know that there is a\nPEM -> DER and a DER -> EVP_PKEY (RSA) deserializer, but no direct\nPEM -> EVP_PKEY (RSA) deserializer.\nAdditionally, a small fix in test_fail_string_common(), as strcmp()\ncould run past a buffer if one of the strings isn't terminated with\na null byte within the given length.\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12410)"
        }
    ],
    "git log -L479,498:test/endecode_test.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/endecode_test.c b/test/endecode_test.c--- a/test/endecode_test.c+++ b/test/endecode_test.c@@ -359,1 +368,20 @@+static void collect_name(const char *name, void *arg)+{+    char **namelist = arg;+    char *new_namelist;+    size_t space;++    space = strlen(name);+    if (*namelist != NULL)+        space += strlen(*namelist) + 2 /* for comma and space */;+    space++; /* for terminating null byte */++    new_namelist = OPENSSL_realloc(*namelist, space);+    if (new_namelist == NULL)+        return;+    if (*namelist != NULL) {+        strcat(new_namelist, \", \");+        strcat(new_namelist, name);+    } else {+        strcpy(new_namelist, name);",
            "commit_date": "2020-09-14 11:21:37+02:00",
            "commit_hash": "ae12eac074be92e14c11a36b90e1c95eca3723f1",
            "message": "TEST: Adapt applicable tests to the changed OSSL_ENCODER_CTX_new_by_EVP_PKEY()\nThis adds the convenience function EVP_PKEY_typenames_do_all(), which\ndoes the same as EVP_KEYMGMT_names_do_all(), but without having to\nexpose all the internal ways to find out if the internal EVP_PKEY key\nis legacy or provider-native.\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12873)"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/serdes_test.c b/test/serdes_test.c--- /dev/null+++ b/test/serdes_test.c@@ -0,0 +136,1 @@+",
            "commit_date": "2020-07-09 19:10:39+02:00",
            "commit_hash": "5a23d78c9b141e31ab9b7d551b2125b124a75e49",
            "message": "TEST: Add new serializer and deserializer test\nThis test revolves around a central function that will first serialize\nan EVP_PKEY, then deserialize the result into a new EVP_PKEY and\ncompare the two.\nThe following tests are currently implemented:\n1.  EVP_PKEY (RSA) -> DER, then DER -> EVP_PKEY (RSA).\n2.  EVP_PKEY (RSA) -> PEM, then PEM -> EVP_PKEY (RSA).\nThis one exercises deserializer chains, as we know that there is a\nPEM -> DER and a DER -> EVP_PKEY (RSA) deserializer, but no direct\nPEM -> EVP_PKEY (RSA) deserializer.\nAdditionally, a small fix in test_fail_string_common(), as strcmp()\ncould run past a buffer if one of the strings isn't terminated with\na null byte within the given length.\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12410)"
        }
    ],
    "git log -L327,339:test/params_test.c": [
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -327,14 +326,13 @@ static int init_app_variables(void) {-    bignumbin_l = (size_t)l;",
            "commit_date": "2019-06-25 01:37:07+10:00",
            "commit_hash": "edc62356485257a37eb8775f25c5a19345b83a50",
            "message": "The params_test uses wrong size for BN check.\nBefore the return size was included in the OSSL_PARAM structure, the size\nglobal was updated via a pointer.  The size global variable has been removed\nand the in structure return size used instead.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9248)\nint l = 0;\ncleanup_app_variables();\napp_p1 = app_p1_init;\napp_p2 = app_p2_init;\nif (!BN_hex2bn(&app_p3, app_p3_init)\n|| (l = BN_bn2nativepad(app_p3, bignumbin, sizeof(bignumbin))) < 0)\nreturn 0;\nstrcpy(app_p4, app_p4_init);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- /dev/null+++ b/test/params_test.c@@ -0,0 +239,14 @@++static int init_app_variables(void)+{+    int l = 0;++    cleanup_app_variables();++    app_p1 = app_p1_init;+    app_p2 = app_p2_init;+    if (!BN_hex2bn(&app_p3, app_p3_init)+        || (l = BN_bn2nativepad(app_p3, bignumbin, sizeof(bignumbin))) < 0)+        return 0;+    bignumbin_l = (size_t)l;+    strcpy(app_p4, app_p4_init);",
            "commit_date": "2019-03-04 17:22:45+01:00",
            "commit_hash": "9ad41d246f43d410ab4805e09786a88d56371908",
            "message": "test/params_test.c: Add \"real world\" parameter testing\ntest/params_test.c is a program that tries to mimic how a provider and\nan application would or could handle OSSL_PARAM arrays.\nFor the moment, this program tests a very raw way of handling\nOSSL_PARAM arrays.  It is, however, written in a way that will\nhopefully make it possible to extend with other methods as APIs arise,\nand to set up test cases where a \"provider\" handles the array one way\nwhile the \"application\" handles it another way.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)"
        }
    ],
    "git log -L327,340:test/params_test.c": [
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -327,15 +326,14 @@ static int init_app_variables(void) {-    bignumbin_l = (size_t)l;",
            "commit_date": "2019-06-25 01:37:07+10:00",
            "commit_hash": "edc62356485257a37eb8775f25c5a19345b83a50",
            "message": "The params_test uses wrong size for BN check.\nBefore the return size was included in the OSSL_PARAM structure, the size\nglobal was updated via a pointer.  The size global variable has been removed\nand the in structure return size used instead.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9248)\nint l = 0;\ncleanup_app_variables();\napp_p1 = app_p1_init;\napp_p2 = app_p2_init;\nif (!BN_hex2bn(&app_p3, app_p3_init)\n|| (l = BN_bn2nativepad(app_p3, bignumbin, sizeof(bignumbin))) < 0)\nreturn 0;\nstrcpy(app_p4, app_p4_init);\nstrcpy(app_p5, app_p5_init);"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -337,16 +327,15 @@ static int init_app_variables(void) {-    app_p4_l = sizeof(app_p4_init);",
            "commit_date": "2019-06-24 14:43:55+10:00",
            "commit_hash": "4e7991b497b65145ec5d570485020e1658208866",
            "message": "Change OSSL_PARAM return size to not be a pointer.\nInstead of referencing the return size from the OSSL_PARAM structure, make the\nsize a field within the structure.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9135)\nint l = 0;\ncleanup_app_variables();\napp_p1 = app_p1_init;\napp_p2 = app_p2_init;\nif (!BN_hex2bn(&app_p3, app_p3_init)\n|| (l = BN_bn2nativepad(app_p3, bignumbin, sizeof(bignumbin))) < 0)\nreturn 0;\nbignumbin_l = (size_t)l;\nstrcpy(app_p4, app_p4_init);\nstrcpy(app_p5, app_p5_init);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -303,16 +332,16 @@ static int init_app_variables(void) {-    app_p5 = app_p5_init;+    strcpy(app_p5, app_p5_init);",
            "commit_date": "2019-03-08 09:54:04+01:00",
            "commit_hash": "fff684168c7923aa85e6b4381d71d933396e32b0",
            "message": "test/params_test.c: Add run-time constructed OSSL_PARAM variant\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)\nint l = 0;\ncleanup_app_variables();\napp_p1 = app_p1_init;\napp_p2 = app_p2_init;\nif (!BN_hex2bn(&app_p3, app_p3_init)\n|| (l = BN_bn2nativepad(app_p3, bignumbin, sizeof(bignumbin))) < 0)\nreturn 0;\nbignumbin_l = (size_t)l;\nstrcpy(app_p4, app_p4_init);\napp_p4_l = sizeof(app_p4_init);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- /dev/null+++ b/test/params_test.c@@ -0,0 +239,16 @@++static int init_app_variables(void)+{+    int l = 0;++    cleanup_app_variables();++    app_p1 = app_p1_init;+    app_p2 = app_p2_init;+    if (!BN_hex2bn(&app_p3, app_p3_init)+        || (l = BN_bn2nativepad(app_p3, bignumbin, sizeof(bignumbin))) < 0)+        return 0;+    bignumbin_l = (size_t)l;+    strcpy(app_p4, app_p4_init);+    app_p4_l = sizeof(app_p4_init);+    app_p5 = app_p5_init;",
            "commit_date": "2019-03-04 17:22:45+01:00",
            "commit_hash": "9ad41d246f43d410ab4805e09786a88d56371908",
            "message": "test/params_test.c: Add \"real world\" parameter testing\ntest/params_test.c is a program that tries to mimic how a provider and\nan application would or could handle OSSL_PARAM arrays.\nFor the moment, this program tests a very raw way of handling\nOSSL_PARAM arrays.  It is, however, written in a way that will\nhopefully make it possible to extend with other methods as APIs arise,\nand to set up test cases where a \"provider\" handles the array one way\nwhile the \"application\" handles it another way.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)"
        }
    ],
    "git log -L97,111:test/params_test.c": [
        {
            "author": {
                "email": "pauli@openssl.org",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -97,12 +97,15 @@ static void *init_object(void) {-    struct object_st *obj = OPENSSL_zalloc(sizeof(*obj));+    struct object_st *obj;++    if (!TEST_ptr(obj = OPENSSL_zalloc(sizeof(*obj))))+        return NULL;",
            "commit_date": "2021-06-25 12:57:53+10:00",
            "commit_hash": "f06c5547605b1e400f95eafb77a42947e4d50b78",
            "message": "test: check for NULL returns better\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/15910)\nobj->p1 = p1_init;\nobj->p2 = p2_init;\nif (!TEST_true(BN_hex2bn(&obj->p3, p3_init)))\ngoto fail;\nif (!TEST_ptr(obj->p4 = OPENSSL_strdup(p4_init)))\ngoto fail;\nstrcpy(obj->p5, p5_init);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -89,12 +96,12 @@ static void *init_object(void) {-    obj->p5 = p5_init;+    strcpy(obj->p5, p5_init);",
            "commit_date": "2019-03-08 09:54:04+01:00",
            "commit_hash": "fff684168c7923aa85e6b4381d71d933396e32b0",
            "message": "test/params_test.c: Add run-time constructed OSSL_PARAM variant\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)\nstruct object_st *obj = OPENSSL_zalloc(sizeof(*obj));\nobj->p1 = p1_init;\nobj->p2 = p2_init;\nif (!TEST_true(BN_hex2bn(&obj->p3, p3_init)))\ngoto fail;\nif (!TEST_ptr(obj->p4 = OPENSSL_strdup(p4_init)))\ngoto fail;"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- /dev/null+++ b/test/params_test.c@@ -0,0 +86,12 @@++static void *init_object(void)+{+    struct object_st *obj = OPENSSL_zalloc(sizeof(*obj));++    obj->p1 = p1_init;+    obj->p2 = p2_init;+    if (!TEST_true(BN_hex2bn(&obj->p3, p3_init)))+        goto fail;+    if (!TEST_ptr(obj->p4 = OPENSSL_strdup(p4_init)))+        goto fail;+    obj->p5 = p5_init;",
            "commit_date": "2019-03-04 17:22:45+01:00",
            "commit_hash": "9ad41d246f43d410ab4805e09786a88d56371908",
            "message": "test/params_test.c: Add \"real world\" parameter testing\ntest/params_test.c is a program that tries to mimic how a provider and\nan application would or could handle OSSL_PARAM arrays.\nFor the moment, this program tests a very raw way of handling\nOSSL_PARAM arrays.  It is, however, written in a way that will\nhopefully make it possible to extend with other methods as APIs arise,\nand to set up test cases where a \"provider\" handles the array one way\nwhile the \"application\" handles it another way.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)"
        }
    ],
    "git log -L114,129:providers/implementations/signature/sm2_sig.c": [
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/providers/implementations/signature/sm2sig.c b/providers/implementations/signature/sm2sig.c--- a/providers/implementations/signature/sm2sig.c+++ b/providers/implementations/signature/sm2sig.c@@ -98,15 +106,16 @@+ static void *sm2sig_newctx(void *provctx, const char *propq) {-    /* don't allow to change MD, and in fact there is no such need */-    ctx->flag_allow_md = 0;+    ctx->mdsize = SM3_DIGEST_LENGTH;+    strcpy(ctx->mdname, OSSL_DIGEST_NAME_SM3);",
            "commit_date": "2021-04-28 18:40:37+02:00",
            "commit_hash": "2c181ac5a6fff474bc26bfa93f0c717eebc1ab1b",
            "message": "sm2: Cleanup handling of DIGEST and DIGEST_SIZE parameters\nFixes #14873\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15074)\nPROV_SM2_CTX *ctx = OPENSSL_zalloc(sizeof(PROV_SM2_CTX));\nif (ctx == NULL)\nreturn NULL;\nctx->libctx = PROV_LIBCTX_OF(provctx);\nif (propq != NULL && (ctx->propq = OPENSSL_strdup(propq)) == NULL) {\nOPENSSL_free(ctx);\nERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);\nreturn NULL;\n}"
        },
        {
            "author": {
                "email": "ppzgs1@gmail.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/providers/implementations/signature/sm2sig.c b/providers/implementations/signature/sm2sig.c--- a/providers/implementations/signature/sm2sig.c+++ b/providers/implementations/signature/sm2sig.c@@ -98,15 +98,15 @@ static void *sm2sig_newctx(void *provctx, const char *propq) {-        ctx = NULL;+        return NULL;",
            "commit_date": "2021-03-19 10:19:18+10:00",
            "commit_hash": "fbe286a36efffacc846c9134c4f000f2a49355a0",
            "message": "sm2: fix coverity 1467503: explicit null dereference\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14618)\nPROV_SM2_CTX *ctx = OPENSSL_zalloc(sizeof(PROV_SM2_CTX));\nif (ctx == NULL)\nreturn NULL;\nctx->libctx = PROV_LIBCTX_OF(provctx);\nif (propq != NULL && (ctx->propq = OPENSSL_strdup(propq)) == NULL) {\nOPENSSL_free(ctx);\nERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);\n}\n/* don't allow to change MD, and in fact there is no such need */\nctx->flag_allow_md = 0;"
        },
        {
            "author": {
                "email": "matthias.st.pierre@ncp-e.com",
                "name": "Dr. Matthias St. Pierre"
            },
            "changes": "diff --git a/providers/implementations/signature/sm2sig.c b/providers/implementations/signature/sm2sig.c--- a/providers/implementations/signature/sm2sig.c+++ b/providers/implementations/signature/sm2sig.c@@ -98,15 +98,15 @@ static void *sm2sig_newctx(void *provctx, const char *propq) {-    ctx->libctx = PROV_LIBRARY_CONTEXT_OF(provctx);+    ctx->libctx = PROV_LIBCTX_OF(provctx);",
            "commit_date": "2020-10-15 12:55:50+03:00",
            "commit_hash": "a829b735b645516041b55746e013692babd8cd31",
            "message": "Rename some occurrences of 'library_context' and 'lib_ctx' to 'libctx'\nThis change makes the naming more consistent, because three different terms\nwere used for the same thing. (The term libctx was used by far most often.)\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/12621)\nPROV_SM2_CTX *ctx = OPENSSL_zalloc(sizeof(PROV_SM2_CTX));\nif (ctx == NULL)\nreturn NULL;\nif (propq != NULL && (ctx->propq = OPENSSL_strdup(propq)) == NULL) {\nOPENSSL_free(ctx);\nctx = NULL;\nERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);\n}\n/* don't allow to change MD, and in fact there is no such need */\nctx->flag_allow_md = 0;"
        },
        {
            "author": {
                "email": "kaishen.yy@antfin.com",
                "name": "Paul Yang"
            },
            "changes": "diff --git a/providers/implementations/signature/sm2sig.c b/providers/implementations/signature/sm2sig.c--- /dev/null+++ b/providers/implementations/signature/sm2sig.c@@ -0,0 +129,15 @@+static void *sm2sig_newctx(void *provctx, const char *propq)+{+    PROV_SM2_CTX *ctx = OPENSSL_zalloc(sizeof(PROV_SM2_CTX));++    if (ctx == NULL)+        return NULL;++    ctx->libctx = PROV_LIBRARY_CONTEXT_OF(provctx);+    if (propq != NULL && (ctx->propq = OPENSSL_strdup(propq)) == NULL) {+        OPENSSL_free(ctx);+        ctx = NULL;+        ERR_raise(ERR_LIB_PROV, ERR_R_MALLOC_FAILURE);+    }+    /* don't allow to change MD, and in fact there is no such need */+    ctx->flag_allow_md = 0;",
            "commit_date": "2020-03-04 23:49:43+08:00",
            "commit_hash": "d0b79f8631c0f522c514175be4e4fbe984cf8f6c",
            "message": "Add SM2 signature algorithm to default provider\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/12536)"
        }
    ],
    "git log -L169,190:test/params_test.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -154,26 +165,22 @@ static int raw_get_params(void *vobj, OSSL_PARAM *params) {-            size_t bytes = BN_num_bytes(obj->p3);--            params->return_size = bytes;-            if (!TEST_size_t_ge(params->data_size, bytes))+            params->return_size = BN_num_bytes(obj->p3);+            if (!TEST_size_t_ge(params->data_size, params->return_size))-            BN_bn2nativepad(obj->p3, params->data, bytes);+            BN_bn2nativepad(obj->p3, params->data, params->return_size);-            size_t bytes = strlen(obj->p4) + 1;--            params->return_size = bytes;-            if (!TEST_size_t_ge(params->data_size, bytes))+            params->return_size = strlen(obj->p4);+            if (!TEST_size_t_gt(params->data_size, params->return_size))",
            "commit_date": "2021-02-12 20:30:40+01:00",
            "commit_hash": "247a1786e25dbf77548168572e383d57aa743af4",
            "message": "OSSL_PARAM: Correct the assumptions on the UTF8 string length\nWhen the string \"ABCDEFGH\" is passed, what's considered its data, this?\n{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' }\nor this?\n{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', '\\0' }\nIf it's passed as a pass phrase, should the terminating NUL byte be\nconsidered part of the pass phrase, or not?\nOur treatment of OSSL_PARAMs with the data type OSSL_PARAM_UTF8_STRING\nset the length of the string to include the terminating NUL byte,\nwhich is quite confusing.  What should the recipient of such a string\nbelieve?\nInstead of perpetuating this confusion, we change the assumption to\nset the OSSL_PARAM to the length of the string, not including the\nterminating NUL byte, thereby giving it the same value as a strlen()\ncall would give.\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14168)\nstruct object_st *obj = vobj;\nfor (; params->key != NULL; params++)\nif (strcmp(params->key, \"p1\") == 0) {\nparams->return_size = sizeof(obj->p1);\n*(int *)params->data = obj->p1;\n} else if (strcmp(params->key, \"p2\") == 0) {\nparams->return_size = sizeof(obj->p2);\n*(double *)params->data = obj->p2;\n} else if (strcmp(params->key, \"p3\") == 0) {\nreturn 0;\n} else if (strcmp(params->key, \"p4\") == 0) {\nreturn 0;\nstrcpy(params->data, obj->p4);"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -154,30 +154,26 @@-static int raw_get_params(void *vobj, const OSSL_PARAM *params)+static int raw_get_params(void *vobj, OSSL_PARAM *params) {-            if (params->return_size != NULL)-                *params->return_size = sizeof(obj->p1);+            params->return_size = sizeof(obj->p1);-            if (params->return_size != NULL)-                *params->return_size = sizeof(obj->p2);+            params->return_size = sizeof(obj->p2);-            if (params->return_size != NULL)-                *params->return_size = bytes;+            params->return_size = bytes;-            if (params->return_size != NULL)-                *params->return_size = bytes;+            params->return_size = bytes;",
            "commit_date": "2019-06-24 14:43:55+10:00",
            "commit_hash": "4e7991b497b65145ec5d570485020e1658208866",
            "message": "Change OSSL_PARAM return size to not be a pointer.\nInstead of referencing the return size from the OSSL_PARAM structure, make the\nsize a field within the structure.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9135)\nstruct object_st *obj = vobj;\nfor (; params->key != NULL; params++)\nif (strcmp(params->key, \"p1\") == 0) {\n*(int *)params->data = obj->p1;\n} else if (strcmp(params->key, \"p2\") == 0) {\n*(double *)params->data = obj->p2;\n} else if (strcmp(params->key, \"p3\") == 0) {\nsize_t bytes = BN_num_bytes(obj->p3);\nif (!TEST_size_t_ge(params->data_size, bytes))\nreturn 0;\nBN_bn2nativepad(obj->p3, params->data, bytes);\n} else if (strcmp(params->key, \"p4\") == 0) {\nsize_t bytes = strlen(obj->p4) + 1;\nif (!TEST_size_t_ge(params->data_size, bytes))\nreturn 0;\nstrcpy(params->data, obj->p4);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- /dev/null+++ b/test/params_test.c@@ -0,0 +139,30 @@++static int raw_get_params(void *vobj, const OSSL_PARAM *params)+{+    struct object_st *obj = vobj;++    for (; params->key != NULL; params++)+        if (strcmp(params->key, \"p1\") == 0) {+            if (params->return_size != NULL)+                *params->return_size = sizeof(obj->p1);+            *(int *)params->data = obj->p1;+        } else if (strcmp(params->key, \"p2\") == 0) {+            if (params->return_size != NULL)+                *params->return_size = sizeof(obj->p2);+            *(double *)params->data = obj->p2;+        } else if (strcmp(params->key, \"p3\") == 0) {+            size_t bytes = BN_num_bytes(obj->p3);++            if (params->return_size != NULL)+                *params->return_size = bytes;+            if (!TEST_size_t_ge(params->data_size, bytes))+                return 0;+            BN_bn2nativepad(obj->p3, params->data, bytes);+        } else if (strcmp(params->key, \"p4\") == 0) {+            size_t bytes = strlen(obj->p4) + 1;++            if (params->return_size != NULL)+                *params->return_size = bytes;+            if (!TEST_size_t_ge(params->data_size, bytes))+                return 0;+            strcpy(params->data, obj->p4);",
            "commit_date": "2019-03-04 17:22:45+01:00",
            "commit_hash": "9ad41d246f43d410ab4805e09786a88d56371908",
            "message": "test/params_test.c: Add \"real world\" parameter testing\ntest/params_test.c is a program that tries to mimic how a provider and\nan application would or could handle OSSL_PARAM arrays.\nFor the moment, this program tests a very raw way of handling\nOSSL_PARAM arrays.  It is, however, written in a way that will\nhopefully make it possible to extend with other methods as APIs arise,\nand to set up test cases where a \"provider\" handles the array one way\nwhile the \"application\" handles it another way.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)"
        }
    ],
    "git log -L169,195:test/params_test.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -154,33 +165,27 @@ static int raw_get_params(void *vobj, OSSL_PARAM *params) {-            size_t bytes = BN_num_bytes(obj->p3);--            params->return_size = bytes;-            if (!TEST_size_t_ge(params->data_size, bytes))+            params->return_size = BN_num_bytes(obj->p3);+            if (!TEST_size_t_ge(params->data_size, params->return_size))-            BN_bn2nativepad(obj->p3, params->data, bytes);+            BN_bn2nativepad(obj->p3, params->data, params->return_size);-            size_t bytes = strlen(obj->p4) + 1;--            params->return_size = bytes;-            if (!TEST_size_t_ge(params->data_size, bytes))+            params->return_size = strlen(obj->p4);+            if (!TEST_size_t_gt(params->data_size, params->return_size))-            size_t bytes = strlen(obj->p5) + 1;--            params->return_size = bytes;-            if (!TEST_size_t_ge(params->data_size, bytes))+            params->return_size = strlen(obj->p5);+            if (!TEST_size_t_gt(params->data_size, params->return_size))",
            "commit_date": "2021-02-12 20:30:40+01:00",
            "commit_hash": "247a1786e25dbf77548168572e383d57aa743af4",
            "message": "OSSL_PARAM: Correct the assumptions on the UTF8 string length\nWhen the string \"ABCDEFGH\" is passed, what's considered its data, this?\n{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H' }\nor this?\n{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', '\\0' }\nIf it's passed as a pass phrase, should the terminating NUL byte be\nconsidered part of the pass phrase, or not?\nOur treatment of OSSL_PARAMs with the data type OSSL_PARAM_UTF8_STRING\nset the length of the string to include the terminating NUL byte,\nwhich is quite confusing.  What should the recipient of such a string\nbelieve?\nInstead of perpetuating this confusion, we change the assumption to\nset the OSSL_PARAM to the length of the string, not including the\nterminating NUL byte, thereby giving it the same value as a strlen()\ncall would give.\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14168)\nstruct object_st *obj = vobj;\nfor (; params->key != NULL; params++)\nif (strcmp(params->key, \"p1\") == 0) {\nparams->return_size = sizeof(obj->p1);\n*(int *)params->data = obj->p1;\n} else if (strcmp(params->key, \"p2\") == 0) {\nparams->return_size = sizeof(obj->p2);\n*(double *)params->data = obj->p2;\n} else if (strcmp(params->key, \"p3\") == 0) {\nreturn 0;\n} else if (strcmp(params->key, \"p4\") == 0) {\nreturn 0;\nstrcpy(params->data, obj->p4);\n} else if (strcmp(params->key, \"p5\") == 0) {\nreturn 0;\nstrcpy(params->data, obj->p5);"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -154,38 +154,33 @@-static int raw_get_params(void *vobj, const OSSL_PARAM *params)+static int raw_get_params(void *vobj, OSSL_PARAM *params) {-            if (params->return_size != NULL)-                *params->return_size = sizeof(obj->p1);+            params->return_size = sizeof(obj->p1);-            if (params->return_size != NULL)-                *params->return_size = sizeof(obj->p2);+            params->return_size = sizeof(obj->p2);-            if (params->return_size != NULL)-                *params->return_size = bytes;+            params->return_size = bytes;-            if (params->return_size != NULL)-                *params->return_size = bytes;+            params->return_size = bytes;-            if (params->return_size != NULL)-                *params->return_size = bytes;+            params->return_size = bytes;",
            "commit_date": "2019-06-24 14:43:55+10:00",
            "commit_hash": "4e7991b497b65145ec5d570485020e1658208866",
            "message": "Change OSSL_PARAM return size to not be a pointer.\nInstead of referencing the return size from the OSSL_PARAM structure, make the\nsize a field within the structure.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9135)\nstruct object_st *obj = vobj;\nfor (; params->key != NULL; params++)\nif (strcmp(params->key, \"p1\") == 0) {\n*(int *)params->data = obj->p1;\n} else if (strcmp(params->key, \"p2\") == 0) {\n*(double *)params->data = obj->p2;\n} else if (strcmp(params->key, \"p3\") == 0) {\nsize_t bytes = BN_num_bytes(obj->p3);\nif (!TEST_size_t_ge(params->data_size, bytes))\nreturn 0;\nBN_bn2nativepad(obj->p3, params->data, bytes);\n} else if (strcmp(params->key, \"p4\") == 0) {\nsize_t bytes = strlen(obj->p4) + 1;\nif (!TEST_size_t_ge(params->data_size, bytes))\nreturn 0;\nstrcpy(params->data, obj->p4);\n} else if (strcmp(params->key, \"p5\") == 0) {\nsize_t bytes = strlen(obj->p5) + 1;\nif (!TEST_size_t_ge(params->data_size, bytes))\nreturn 0;\nstrcpy(params->data, obj->p5);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -142,31 +152,38 @@ static int raw_get_params(void *vobj, const OSSL_PARAM *params) {+            size_t bytes = strlen(obj->p5) + 1;++            if (params->return_size != NULL)+                *params->return_size = bytes;+            if (!TEST_size_t_ge(params->data_size, bytes))+                return 0;+            strcpy(params->data, obj->p5);",
            "commit_date": "2019-03-08 09:54:04+01:00",
            "commit_hash": "fff684168c7923aa85e6b4381d71d933396e32b0",
            "message": "test/params_test.c: Add run-time constructed OSSL_PARAM variant\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)\nstruct object_st *obj = vobj;\nfor (; params->key != NULL; params++)\nif (strcmp(params->key, \"p1\") == 0) {\nif (params->return_size != NULL)\n*params->return_size = sizeof(obj->p1);\n*(int *)params->data = obj->p1;\n} else if (strcmp(params->key, \"p2\") == 0) {\nif (params->return_size != NULL)\n*params->return_size = sizeof(obj->p2);\n*(double *)params->data = obj->p2;\n} else if (strcmp(params->key, \"p3\") == 0) {\nsize_t bytes = BN_num_bytes(obj->p3);\nif (params->return_size != NULL)\n*params->return_size = bytes;\nif (!TEST_size_t_ge(params->data_size, bytes))\nreturn 0;\nBN_bn2nativepad(obj->p3, params->data, bytes);\n} else if (strcmp(params->key, \"p4\") == 0) {\nsize_t bytes = strlen(obj->p4) + 1;\nif (params->return_size != NULL)\n*params->return_size = bytes;\nif (!TEST_size_t_ge(params->data_size, bytes))\nreturn 0;\nstrcpy(params->data, obj->p4);\n} else if (strcmp(params->key, \"p5\") == 0) {"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- /dev/null+++ b/test/params_test.c@@ -0,0 +139,31 @@++static int raw_get_params(void *vobj, const OSSL_PARAM *params)+{+    struct object_st *obj = vobj;++    for (; params->key != NULL; params++)+        if (strcmp(params->key, \"p1\") == 0) {+            if (params->return_size != NULL)+                *params->return_size = sizeof(obj->p1);+            *(int *)params->data = obj->p1;+        } else if (strcmp(params->key, \"p2\") == 0) {+            if (params->return_size != NULL)+                *params->return_size = sizeof(obj->p2);+            *(double *)params->data = obj->p2;+        } else if (strcmp(params->key, \"p3\") == 0) {+            size_t bytes = BN_num_bytes(obj->p3);++            if (params->return_size != NULL)+                *params->return_size = bytes;+            if (!TEST_size_t_ge(params->data_size, bytes))+                return 0;+            BN_bn2nativepad(obj->p3, params->data, bytes);+        } else if (strcmp(params->key, \"p4\") == 0) {+            size_t bytes = strlen(obj->p4) + 1;++            if (params->return_size != NULL)+                *params->return_size = bytes;+            if (!TEST_size_t_ge(params->data_size, bytes))+                return 0;+            strcpy(params->data, obj->p4);+        } else if (strcmp(params->key, \"p5\") == 0) {",
            "commit_date": "2019-03-04 17:22:45+01:00",
            "commit_hash": "9ad41d246f43d410ab4805e09786a88d56371908",
            "message": "test/params_test.c: Add \"real world\" parameter testing\ntest/params_test.c is a program that tries to mimic how a provider and\nan application would or could handle OSSL_PARAM arrays.\nFor the moment, this program tests a very raw way of handling\nOSSL_PARAM arrays.  It is, however, written in a way that will\nhopefully make it possible to extend with other methods as APIs arise,\nand to set up test cases where a \"provider\" handles the array one way\nwhile the \"application\" handles it another way.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)"
        }
    ],
    "git log -L404,427:test/drbgtest.c": [
        {
            "author": {
                "email": "matthias.st.pierre@ncp-e.com",
                "name": "Dr. Matthias St. Pierre"
            },
            "changes": "diff --git a/test/drbgtest.c b/test/drbgtest.c--- a/test/drbgtest.c+++ b/test/drbgtest.c@@ -268,0 +392,24 @@++static int test_rand_reseed_on_fork(EVP_RAND_CTX *primary,+                                    EVP_RAND_CTX *public,+                                    EVP_RAND_CTX *private)+{+    unsigned int i;+    pid_t pid = getpid();+    int verbose = (getenv(\"V\") != NULL);+    int success = 1;+    int duplicate[2] = {0, 0};+    unsigned char random[2 * RANDOM_SIZE];+    unsigned char sample[DRBG_FORK_RESULT_COUNT * RANDOM_SIZE];+    unsigned char *psample = &sample[0];+    drbg_fork_result result[DRBG_FORK_RESULT_COUNT];+    drbg_fork_result *presult = &result[2];++    memset(&result,  0, sizeof(result));++    for (i = 1 ; i <= DRBG_FORK_COUNT ; ++i) {++        presult[0].pindex = presult[1].pindex = i;++        sprintf(presult[0].name, \"child %d\", i);+        strcpy(presult[1].name, presult[0].name);",
            "commit_date": "2020-07-08 09:23:29+02:00",
            "commit_hash": "09e76c5dd34515f9df42b2f1deed5166ba6b31fa",
            "message": "test/drbgtest: improve the reseed after fork test\nIssue #12377 demonstrated that it is not sufficient to verify that\nafter a fork a reseeding is triggered in the child. This commit\nenhances the test by collecting the output of the public and private\ndrbg for the parent and all children and checking for duplicates.\nIn case of duplicates, it prints an error message and displays a\nsorted output.\nThe analysis of #12377 (see [1]) showed that due to an error in the\nresetting of the AES-CTR (issue #12405, fixed by #12413), it could\nhappen that only the first n bytes (n=1,...15) of the children's\nrandom output were identical.\nThis test is optimized to detect this issue by only comparing the first\nbyte of the sampled data (i.e., the first 'column' of the output).\nThe number of samples is chosen high enough to keep the chance of false\npositives low. The test is executed sixteen times, each time advancing\nthe internal counter by requesting a single extra byte of random data.\nAnother, more general test splits the entire sampled random data into\ntwo-byte chunks and counts their collisions. If a certain threshold\nis exceeded, it reports an error.\n[1] https://github.com/openssl/openssl/issues/12377#issuecomment-656207334\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12407)"
        }
    ],
    "git log -L194,246:crypto/dso/dso_dlfcn.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -194,53 +194,53 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);-            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);-            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);-            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);",
            "commit_date": "2020-11-04 12:23:19+01:00",
            "commit_hash": "9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2",
            "message": "Convert all {NAME}err() in crypto/ to their corresponding ERR_raise() call\nThis includes error reporting for libcrypto sub-libraries in surprising\nplaces.\nThis was done using util/err-to-raise\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13318)\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nreturn NULL;\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nmerged = OPENSSL_strdup(filespec1);\nif (merged == NULL) {\nreturn NULL;\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nmerged = OPENSSL_strdup(filespec2);\nif (merged == NULL) {\nreturn NULL;\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nreturn NULL;\n}\nstrcpy(merged, filespec2);"
        },
        {
            "author": {
                "email": "kunnpuu@gmail.com",
                "name": "KaoruToda"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -184,53 +184,53 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        return (NULL);+        return NULL;-            return (NULL);+            return NULL;-            return (NULL);+            return NULL;-            return (NULL);+            return NULL;",
            "commit_date": "2017-10-17 23:04:09+09:00",
            "commit_hash": "26a7d938c9bf932a55cb5e4e02abb48fe395c5cd",
            "message": "Remove parentheses of return.\nSince return is inconsistent, I removed unnecessary parentheses and\nunified them.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4541)\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nmerged = OPENSSL_strdup(filespec1);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nmerged = OPENSSL_strdup(filespec2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n}\nstrcpy(merged, filespec2);"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -184,55 +184,53 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        merged = OPENSSL_malloc(strlen(filespec1) + 1);+        merged = OPENSSL_strdup(filespec1);-        strcpy(merged, filespec1);-        merged = OPENSSL_malloc(strlen(filespec2) + 1);+        merged = OPENSSL_strdup(filespec2);-        strcpy(merged, filespec2);",
            "commit_date": "2017-09-14 16:13:53-04:00",
            "commit_hash": "297002a332302a102a9fd802012f12ba2ad056c1",
            "message": "Replace malloc+strcpy with strdup\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4371)\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -184,53 +184,55 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        merged = OPENSSL_strdup(filespec1);+        merged = OPENSSL_malloc(strlen(filespec1) + 1);+        strcpy(merged, filespec1);-        merged = OPENSSL_strdup(filespec2);+        merged = OPENSSL_malloc(strlen(filespec2) + 1);+        strcpy(merged, filespec2);",
            "commit_date": "2017-09-12 09:13:00+10:00",
            "commit_hash": "4cacc9d510c20368d13dcaf2c95c25d6d1ceef6c",
            "message": "Revert \"GH614: Use memcpy()/strdup() when possible\"\nThis reverts commit a89c9a0d855bce735116acfe147b24e386f566ba.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4357)\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);"
        },
        {
            "author": {
                "email": "wipedout@yandex.ru",
                "name": "Dmitry-Me"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -268,55 +268,53 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        merged = OPENSSL_malloc(strlen(filespec1) + 1);+        merged = OPENSSL_strdup(filespec1);-        strcpy(merged, filespec1);-        merged = OPENSSL_malloc(strlen(filespec2) + 1);+        merged = OPENSSL_strdup(filespec2);-        strcpy(merged, filespec2);",
            "commit_date": "2016-02-03 17:34:14+03:00",
            "commit_hash": "a89c9a0d855bce735116acfe147b24e386f566ba",
            "message": "GH614: Use memcpy()/strdup() when possible\nSigned-off-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Kurt Roeckx <kurt@openssl.org>\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -269,55 +269,55 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        if (!merged) {+        if (merged == NULL) {-        if (!merged) {+        if (merged == NULL) {-        if (!merged) {+        if (merged == NULL) {",
            "commit_date": "2015-10-30 11:12:26+00:00",
            "commit_hash": "90945fa31a42dcf3beb90540c618e4d627c595ea",
            "message": "Continue standardising malloc style for libcrypto\nContinuing from previous commit ensure our style is consistent for malloc\nreturn checks.\nReviewed-by: Kurt Roeckx <kurt@openssl.org>\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec1);\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -270,56 +270,55 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-    } else+    } else {-    {-        len = spec2len + (filespec1 ? strlen(filespec1) : 0);+        len = spec2len + strlen(filespec1);-        if (filespec2 && filespec2[spec2len - 1] == '/') {+        if (spec2len && filespec2[spec2len - 1] == '/') {",
            "commit_date": "2015-03-12 14:08:21+00:00",
            "commit_hash": "b7573c597c1932ef709b2455ffab47348b5c54e5",
            "message": "Remove dead code from crypto\nSome miscellaneous removal of dead code from lib crypto.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\nif (!merged) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec1);\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\nif (!merged) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (!merged) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -289,74 +281,56 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1,-\tconst char *filespec2)-\t{-\tchar *merged;--\tif(!filespec1 && !filespec2)-\t\t{-\t\tDSOerr(DSO_F_DLFCN_MERGER,-\t\t\t\tERR_R_PASSED_NULL_PARAMETER);-\t\treturn(NULL);-\t\t}-\t/* If the first file specification is a rooted path, it rules.-\t   same goes if the second file specification is missing. */-\tif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/'))-\t\t{-\t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1);-\t\tif(!merged)-\t\t\t{-\t\t\tDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);-\t\t\treturn(NULL);-\t\t\t}-\t\tstrcpy(merged, filespec1);-\t\t}-\t/* If the first file specification is missing, the second one rules. */-\telse if (!filespec1)-\t\t{-\t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1);-\t\tif(!merged)-\t\t\t{-\t\t\tDSOerr(DSO_F_DLFCN_MERGER,-\t\t\t\tERR_R_MALLOC_FAILURE);-\t\t\treturn(NULL);-\t\t\t}-\t\tstrcpy(merged, filespec2);-\t\t}-\telse-\t\t/* This part isn't as trivial as it looks.  It assumes that-\t\t   the second file specification really is a directory, and-\t\t   makes no checks whatsoever.  Therefore, the result becomes-\t\t   the concatenation of filespec2 followed by a slash followed-\t\t   by filespec1. */-\t\t{-\t\tint spec2len, len;--\t\tspec2len = strlen(filespec2);-\t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0);--\t\tif(filespec2 && filespec2[spec2len - 1] == '/')-\t\t\t{-\t\t\tspec2len--;-\t\t\tlen--;-\t\t\t}-\t\tmerged = OPENSSL_malloc(len + 2);-\t\tif(!merged)-\t\t\t{-\t\t\tDSOerr(DSO_F_DLFCN_MERGER,-\t\t\t\tERR_R_MALLOC_FAILURE);-\t\t\treturn(NULL);-\t\t\t}-\t\tstrcpy(merged, filespec2);-\t\tmerged[spec2len] = '/';-\t\tstrcpy(&merged[spec2len + 1], filespec1);-\t\t}-\treturn(merged);-\t}--#ifdef OPENSSL_SYS_MACOSX-#define DSO_ext\t\".dylib\"-#define DSO_extlen 6-#else-#define DSO_ext\t\".so\"-#define DSO_extlen 3-#endif+                          const char *filespec2)+{+    char *merged;++    if (!filespec1 && !filespec2) {+        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);+        return (NULL);+    }+    /*+     * If the first file specification is a rooted path, it rules. same goes+     * if the second file specification is missing.+     */+    if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {+        merged = OPENSSL_malloc(strlen(filespec1) + 1);+        if (!merged) {+            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            return (NULL);+        }+        strcpy(merged, filespec1);+    }+    /*+     * If the first file specification is missing, the second one rules.+     */+    else if (!filespec1) {+        merged = OPENSSL_malloc(strlen(filespec2) + 1);+        if (!merged) {+            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            return (NULL);+        }+        strcpy(merged, filespec2);+    } else+        /*+         * This part isn't as trivial as it looks.  It assumes that the+         * second file specification really is a directory, and makes no+         * checks whatsoever.  Therefore, the result becomes the+         * concatenation of filespec2 followed by a slash followed by+         * filespec1.+         */+    {+        int spec2len, len;++        spec2len = strlen(filespec2);+        len = spec2len + (filespec1 ? strlen(filespec1) : 0);++        if (filespec2 && filespec2[spec2len - 1] == '/') {+            spec2len--;+            len--;+        }+        merged = OPENSSL_malloc(len + 2);+        if (!merged) {+            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            return (NULL);+        }+        strcpy(merged, filespec2);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -287,74 +287,74 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, \tconst char *filespec2) \t{ \tchar *merged; \tif(!filespec1 && !filespec2) \t\t{ \t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\treturn(NULL); \t\t} \t/* If the first file specification is a rooted path, it rules. \t   same goes if the second file specification is missing. */ \tif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec1); \t\t} \t/* If the first file specification is missing, the second one rules. */ \telse if (!filespec1) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\t} \telse \t\t/* This part isn't as trivial as it looks.  It assumes that \t\t   the second file specification really is a directory, and \t\t   makes no checks whatsoever.  Therefore, the result becomes \t\t   the concatenation of filespec2 followed by a slash followed \t\t   by filespec1. */ \t\t{ \t\tint spec2len, len; \t\tspec2len = strlen(filespec2); \t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0); \t\tif(filespec2 && filespec2[spec2len - 1] == '/') \t\t\t{ \t\t\tspec2len--; \t\t\tlen--; \t\t\t} \t\tmerged = OPENSSL_malloc(len + 2); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\tmerged[spec2len] = '/'; \t\tstrcpy(&merged[spec2len + 1], filespec1); \t\t} \treturn(merged); \t}-#ifdef OPENSSL_SYS_MAC-#define DSO_ext\t\".dynlib\"-#define DSO_extlen 7+#ifdef OPENSSL_SYS_MACOSX+#define DSO_ext\t\".dylib\"+#define DSO_extlen 6 #else #define DSO_ext\t\".so\" #define DSO_extlen 3 #endif",
            "commit_date": "2009-07-16 09:52:59+00:00",
            "commit_hash": "3c630352e22f2f8295d70cceb8f034294aadc822",
            "message": "Use correct extension and OSX detection."
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -287,67 +287,74 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, \tconst char *filespec2) \t{ \tchar *merged; \tif(!filespec1 && !filespec2) \t\t{ \t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\treturn(NULL); \t\t} \t/* If the first file specification is a rooted path, it rules. \t   same goes if the second file specification is missing. */ \tif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec1); \t\t} \t/* If the first file specification is missing, the second one rules. */ \telse if (!filespec1) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\t} \telse \t\t/* This part isn't as trivial as it looks.  It assumes that \t\t   the second file specification really is a directory, and \t\t   makes no checks whatsoever.  Therefore, the result becomes \t\t   the concatenation of filespec2 followed by a slash followed \t\t   by filespec1. */ \t\t{ \t\tint spec2len, len; \t\tspec2len = strlen(filespec2); \t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0); \t\tif(filespec2 && filespec2[spec2len - 1] == '/') \t\t\t{ \t\t\tspec2len--; \t\t\tlen--; \t\t\t} \t\tmerged = OPENSSL_malloc(len + 2); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\tmerged[spec2len] = '/'; \t\tstrcpy(&merged[spec2len + 1], filespec1); \t\t} \treturn(merged); \t}+#ifdef OPENSSL_SYS_MAC+#define DSO_ext\t\".dynlib\"+#define DSO_extlen 7+#else+#define DSO_ext\t\".so\"+#define DSO_extlen 3+#endif",
            "commit_date": "2009-07-15 18:00:04+00:00",
            "commit_hash": "4a620922e243fae11fe3702c4183a80592b03701",
            "message": "Updates from 1.0.0-stable"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -285,68 +285,67 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, \tconst char *filespec2) \t{ \tchar *merged; \tif(!filespec1 && !filespec2) \t\t{ \t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\treturn(NULL); \t\t} \t/* If the first file specification is a rooted path, it rules. \t   same goes if the second file specification is missing. */-\tif (!filespec2 || filespec1[0] == '/')+\tif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1); \t\tif(!merged) \t\t\t{-\t\t\tDSOerr(DSO_F_DLFCN_MERGER,-\t\t\t\tERR_R_MALLOC_FAILURE);+\t\t\tDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec1); \t\t} \t/* If the first file specification is missing, the second one rules. */ \telse if (!filespec1) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\t} \telse \t\t/* This part isn't as trivial as it looks.  It assumes that \t\t   the second file specification really is a directory, and \t\t   makes no checks whatsoever.  Therefore, the result becomes \t\t   the concatenation of filespec2 followed by a slash followed \t\t   by filespec1. */ \t\t{ \t\tint spec2len, len; \t\tspec2len = strlen(filespec2); \t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0); \t\tif(filespec2 && filespec2[spec2len - 1] == '/') \t\t\t{ \t\t\tspec2len--; \t\t\tlen--; \t\t\t} \t\tmerged = OPENSSL_malloc(len + 2); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\tmerged[spec2len] = '/'; \t\tstrcpy(&merged[spec2len + 1], filespec1); \t\t} \treturn(merged); \t}",
            "commit_date": "2007-04-02 20:02:27+00:00",
            "commit_hash": "c971ca4c86b0a7bb4bb7a7d1a3c183b78dfbf144",
            "message": "check if pointer is != NULL before dereferencing it (Coverity CID 40)"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -282,68 +282,68 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, \tconst char *filespec2) \t{ \tchar *merged; \tif(!filespec1 && !filespec2) \t\t{ \t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\treturn(NULL); \t\t} \t/* If the first file specification is a rooted path, it rules. \t   same goes if the second file specification is missing. */ \tif (!filespec2 || filespec1[0] == '/') \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec1); \t\t} \t/* If the first file specification is missing, the second one rules. */ \telse if (!filespec1) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\t} \telse \t\t/* This part isn't as trivial as it looks.  It assumes that \t\t   the second file specification really is a directory, and \t\t   makes no checks whatsoever.  Therefore, the result becomes \t\t   the concatenation of filespec2 followed by a slash followed \t\t   by filespec1. */ \t\t{ \t\tint spec2len, len;-\t\tspec2len = (filespec2 ? strlen(filespec2) : 0);+\t\tspec2len = strlen(filespec2); \t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0); \t\tif(filespec2 && filespec2[spec2len - 1] == '/') \t\t\t{ \t\t\tspec2len--; \t\t\tlen--; \t\t\t} \t\tmerged = OPENSSL_malloc(len + 2); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\tmerged[spec2len] = '/'; \t\tstrcpy(&merged[spec2len + 1], filespec1); \t\t} \treturn(merged); \t}",
            "commit_date": "2006-03-15 17:45:43+00:00",
            "commit_hash": "67b6f1ca889d789e04c58e5b2fbad0944bb1cd1a",
            "message": "fix problems found by coverity: remove useless code"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -254,1 +257,68 @@+static char *dlfcn_merger(DSO *dso, const char *filespec1,+\tconst char *filespec2)+\t{+\tchar *merged;++\tif(!filespec1 && !filespec2)+\t\t{+\t\tDSOerr(DSO_F_DLFCN_MERGER,+\t\t\t\tERR_R_PASSED_NULL_PARAMETER);+\t\treturn(NULL);+\t\t}+\t/* If the first file specification is a rooted path, it rules.+\t   same goes if the second file specification is missing. */+\tif (!filespec2 || filespec1[0] == '/')+\t\t{+\t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1);+\t\tif(!merged)+\t\t\t{+\t\t\tDSOerr(DSO_F_DLFCN_MERGER,+\t\t\t\tERR_R_MALLOC_FAILURE);+\t\t\treturn(NULL);+\t\t\t}+\t\tstrcpy(merged, filespec1);+\t\t}+\t/* If the first file specification is missing, the second one rules. */+\telse if (!filespec1)+\t\t{+\t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1);+\t\tif(!merged)+\t\t\t{+\t\t\tDSOerr(DSO_F_DLFCN_MERGER,+\t\t\t\tERR_R_MALLOC_FAILURE);+\t\t\treturn(NULL);+\t\t\t}+\t\tstrcpy(merged, filespec2);+\t\t}+\telse+\t\t/* This part isn't as trivial as it looks.  It assumes that+\t\t   the second file specification really is a directory, and+\t\t   makes no checks whatsoever.  Therefore, the result becomes+\t\t   the concatenation of filespec2 followed by a slash followed+\t\t   by filespec1. */+\t\t{+\t\tint spec2len, len;++\t\tspec2len = (filespec2 ? strlen(filespec2) : 0);+\t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0);++\t\tif(filespec2 && filespec2[spec2len - 1] == '/')+\t\t\t{+\t\t\tspec2len--;+\t\t\tlen--;+\t\t\t}+\t\tmerged = OPENSSL_malloc(len + 2);+\t\tif(!merged)+\t\t\t{+\t\t\tDSOerr(DSO_F_DLFCN_MERGER,+\t\t\t\tERR_R_MALLOC_FAILURE);+\t\t\treturn(NULL);+\t\t\t}+\t\tstrcpy(merged, filespec2);+\t\tmerged[spec2len] = '/';+\t\tstrcpy(&merged[spec2len + 1], filespec1);+\t\t}+\treturn(merged);+\t}+",
            "commit_date": "2002-07-15 15:35:40+00:00",
            "commit_hash": "cbecb3ac3763f1179dc220a69d28e92f58e9443e",
            "message": "There's an ongoing project to bring some kind of path selection\nmechanism to the ENGINE framework.  This means there there are going\nto be new functionality for the DSO part, and ultimately some way of\nmerging two file specifications together.\nThis commit places the merging code into the repository.  It's\ncurrently not used anywhere, and hasn't been tested at all.  It may be\nfull of errors, including syntactical ones.  Those will be fixed as\npromptly as possible."
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- /dev/null+++ b/crypto/dso/dso_dlfcn.c@@ -0,0 +178,1 @@+",
            "commit_date": "2000-04-04 21:57:11+00:00",
            "commit_hash": "8f4fac7f965b4604bc71be4bd486a8641c0504ab",
            "message": "This is a set of startup code for the DSO support, it's not yet linked into\nthe build process (an upcoming commit no doubt), and is very much *new*\ncode - what that means is that it compiles ok - usually. It certainly\ndoesn't mean it runs well or even properly yet. Please don't muck round\nwith this unless you're looking to help out and hunt bugs. :-)\nCurrently this code doesn't have any support for controlling the \"load\"\nbehaviour (eg. paths, filename translations, etc). That'll be handled\nusing DSO_ctrl() and various flags, once we work out a sensible set of\nflags."
        }
    ],
    "git log -L194,248:crypto/dso/dso_dlfcn.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -194,55 +194,55 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);+        ERR_raise(ERR_LIB_DSO, ERR_R_PASSED_NULL_PARAMETER);-            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);-            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);-            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            ERR_raise(ERR_LIB_DSO, ERR_R_MALLOC_FAILURE);",
            "commit_date": "2020-11-04 12:23:19+01:00",
            "commit_hash": "9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2",
            "message": "Convert all {NAME}err() in crypto/ to their corresponding ERR_raise() call\nThis includes error reporting for libcrypto sub-libraries in surprising\nplaces.\nThis was done using util/err-to-raise\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13318)\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nreturn NULL;\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nmerged = OPENSSL_strdup(filespec1);\nif (merged == NULL) {\nreturn NULL;\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nmerged = OPENSSL_strdup(filespec2);\nif (merged == NULL) {\nreturn NULL;\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nreturn NULL;\n}\nstrcpy(merged, filespec2);\nmerged[spec2len] = '/';\nstrcpy(&merged[spec2len + 1], filespec1);"
        },
        {
            "author": {
                "email": "kunnpuu@gmail.com",
                "name": "KaoruToda"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -184,55 +184,55 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        return (NULL);+        return NULL;-            return (NULL);+            return NULL;-            return (NULL);+            return NULL;-            return (NULL);+            return NULL;",
            "commit_date": "2017-10-17 23:04:09+09:00",
            "commit_hash": "26a7d938c9bf932a55cb5e4e02abb48fe395c5cd",
            "message": "Remove parentheses of return.\nSince return is inconsistent, I removed unnecessary parentheses and\nunified them.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4541)\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nmerged = OPENSSL_strdup(filespec1);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nmerged = OPENSSL_strdup(filespec2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\n}\nstrcpy(merged, filespec2);\nmerged[spec2len] = '/';\nstrcpy(&merged[spec2len + 1], filespec1);"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -184,57 +184,55 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        merged = OPENSSL_malloc(strlen(filespec1) + 1);+        merged = OPENSSL_strdup(filespec1);-        strcpy(merged, filespec1);-        merged = OPENSSL_malloc(strlen(filespec2) + 1);+        merged = OPENSSL_strdup(filespec2);-        strcpy(merged, filespec2);",
            "commit_date": "2017-09-14 16:13:53-04:00",
            "commit_hash": "297002a332302a102a9fd802012f12ba2ad056c1",
            "message": "Replace malloc+strcpy with strdup\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4371)\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);\nmerged[spec2len] = '/';\nstrcpy(&merged[spec2len + 1], filespec1);"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -184,55 +184,57 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        merged = OPENSSL_strdup(filespec1);+        merged = OPENSSL_malloc(strlen(filespec1) + 1);+        strcpy(merged, filespec1);-        merged = OPENSSL_strdup(filespec2);+        merged = OPENSSL_malloc(strlen(filespec2) + 1);+        strcpy(merged, filespec2);",
            "commit_date": "2017-09-12 09:13:00+10:00",
            "commit_hash": "4cacc9d510c20368d13dcaf2c95c25d6d1ceef6c",
            "message": "Revert \"GH614: Use memcpy()/strdup() when possible\"\nThis reverts commit a89c9a0d855bce735116acfe147b24e386f566ba.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4357)\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);\nmerged[spec2len] = '/';\nstrcpy(&merged[spec2len + 1], filespec1);"
        },
        {
            "author": {
                "email": "wipedout@yandex.ru",
                "name": "Dmitry-Me"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -268,57 +268,55 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        merged = OPENSSL_malloc(strlen(filespec1) + 1);+        merged = OPENSSL_strdup(filespec1);-        strcpy(merged, filespec1);-        merged = OPENSSL_malloc(strlen(filespec2) + 1);+        merged = OPENSSL_strdup(filespec2);-        strcpy(merged, filespec2);",
            "commit_date": "2016-02-03 17:34:14+03:00",
            "commit_hash": "a89c9a0d855bce735116acfe147b24e386f566ba",
            "message": "GH614: Use memcpy()/strdup() when possible\nSigned-off-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Kurt Roeckx <kurt@openssl.org>\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (merged == NULL) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);\nmerged[spec2len] = '/';\nstrcpy(&merged[spec2len + 1], filespec1);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -269,57 +269,57 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-        if (!merged) {+        if (merged == NULL) {-        if (!merged) {+        if (merged == NULL) {-        if (!merged) {+        if (merged == NULL) {",
            "commit_date": "2015-10-30 11:12:26+00:00",
            "commit_hash": "90945fa31a42dcf3beb90540c618e4d627c595ea",
            "message": "Continue standardising malloc style for libcrypto\nContinuing from previous commit ensure our style is consistent for malloc\nreturn checks.\nReviewed-by: Kurt Roeckx <kurt@openssl.org>\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec1);\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);\n} else {\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nlen = spec2len + strlen(filespec1);\nif (spec2len && filespec2[spec2len - 1] == '/') {\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);\nmerged[spec2len] = '/';\nstrcpy(&merged[spec2len + 1], filespec1);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -270,58 +270,57 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, {-    } else+    } else {-    {-        len = spec2len + (filespec1 ? strlen(filespec1) : 0);+        len = spec2len + strlen(filespec1);-        if (filespec2 && filespec2[spec2len - 1] == '/') {+        if (spec2len && filespec2[spec2len - 1] == '/') {",
            "commit_date": "2015-03-12 14:08:21+00:00",
            "commit_hash": "b7573c597c1932ef709b2455ffab47348b5c54e5",
            "message": "Remove dead code from crypto\nSome miscellaneous removal of dead code from lib crypto.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nconst char *filespec2)\nchar *merged;\nif (!filespec1 && !filespec2) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);\nreturn (NULL);\n}\n/*\n* If the first file specification is a rooted path, it rules. same goes\n* if the second file specification is missing.\n*/\nif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {\nmerged = OPENSSL_malloc(strlen(filespec1) + 1);\nif (!merged) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec1);\n}\n/*\n* If the first file specification is missing, the second one rules.\n*/\nelse if (!filespec1) {\nmerged = OPENSSL_malloc(strlen(filespec2) + 1);\nif (!merged) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);\n/*\n* This part isn't as trivial as it looks.  It assumes that the\n* second file specification really is a directory, and makes no\n* checks whatsoever.  Therefore, the result becomes the\n* concatenation of filespec2 followed by a slash followed by\n* filespec1.\n*/\nint spec2len, len;\nspec2len = strlen(filespec2);\nspec2len--;\nlen--;\n}\nmerged = OPENSSL_malloc(len + 2);\nif (!merged) {\nDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);\nreturn (NULL);\n}\nstrcpy(merged, filespec2);\nmerged[spec2len] = '/';\nstrcpy(&merged[spec2len + 1], filespec1);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -289,74 +281,58 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1,-\tconst char *filespec2)-\t{-\tchar *merged;--\tif(!filespec1 && !filespec2)-\t\t{-\t\tDSOerr(DSO_F_DLFCN_MERGER,-\t\t\t\tERR_R_PASSED_NULL_PARAMETER);-\t\treturn(NULL);-\t\t}-\t/* If the first file specification is a rooted path, it rules.-\t   same goes if the second file specification is missing. */-\tif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/'))-\t\t{-\t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1);-\t\tif(!merged)-\t\t\t{-\t\t\tDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);-\t\t\treturn(NULL);-\t\t\t}-\t\tstrcpy(merged, filespec1);-\t\t}-\t/* If the first file specification is missing, the second one rules. */-\telse if (!filespec1)-\t\t{-\t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1);-\t\tif(!merged)-\t\t\t{-\t\t\tDSOerr(DSO_F_DLFCN_MERGER,-\t\t\t\tERR_R_MALLOC_FAILURE);-\t\t\treturn(NULL);-\t\t\t}-\t\tstrcpy(merged, filespec2);-\t\t}-\telse-\t\t/* This part isn't as trivial as it looks.  It assumes that-\t\t   the second file specification really is a directory, and-\t\t   makes no checks whatsoever.  Therefore, the result becomes-\t\t   the concatenation of filespec2 followed by a slash followed-\t\t   by filespec1. */-\t\t{-\t\tint spec2len, len;--\t\tspec2len = strlen(filespec2);-\t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0);--\t\tif(filespec2 && filespec2[spec2len - 1] == '/')-\t\t\t{-\t\t\tspec2len--;-\t\t\tlen--;-\t\t\t}-\t\tmerged = OPENSSL_malloc(len + 2);-\t\tif(!merged)-\t\t\t{-\t\t\tDSOerr(DSO_F_DLFCN_MERGER,-\t\t\t\tERR_R_MALLOC_FAILURE);-\t\t\treturn(NULL);-\t\t\t}-\t\tstrcpy(merged, filespec2);-\t\tmerged[spec2len] = '/';-\t\tstrcpy(&merged[spec2len + 1], filespec1);-\t\t}-\treturn(merged);-\t}--#ifdef OPENSSL_SYS_MACOSX-#define DSO_ext\t\".dylib\"-#define DSO_extlen 6-#else-#define DSO_ext\t\".so\"-#define DSO_extlen 3-#endif+                          const char *filespec2)+{+    char *merged;++    if (!filespec1 && !filespec2) {+        DSOerr(DSO_F_DLFCN_MERGER, ERR_R_PASSED_NULL_PARAMETER);+        return (NULL);+    }+    /*+     * If the first file specification is a rooted path, it rules. same goes+     * if the second file specification is missing.+     */+    if (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) {+        merged = OPENSSL_malloc(strlen(filespec1) + 1);+        if (!merged) {+            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            return (NULL);+        }+        strcpy(merged, filespec1);+    }+    /*+     * If the first file specification is missing, the second one rules.+     */+    else if (!filespec1) {+        merged = OPENSSL_malloc(strlen(filespec2) + 1);+        if (!merged) {+            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            return (NULL);+        }+        strcpy(merged, filespec2);+    } else+        /*+         * This part isn't as trivial as it looks.  It assumes that the+         * second file specification really is a directory, and makes no+         * checks whatsoever.  Therefore, the result becomes the+         * concatenation of filespec2 followed by a slash followed by+         * filespec1.+         */+    {+        int spec2len, len;++        spec2len = strlen(filespec2);+        len = spec2len + (filespec1 ? strlen(filespec1) : 0);++        if (filespec2 && filespec2[spec2len - 1] == '/') {+            spec2len--;+            len--;+        }+        merged = OPENSSL_malloc(len + 2);+        if (!merged) {+            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);+            return (NULL);+        }+        strcpy(merged, filespec2);+        merged[spec2len] = '/';+        strcpy(&merged[spec2len + 1], filespec1);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -287,74 +287,74 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, \tconst char *filespec2) \t{ \tchar *merged; \tif(!filespec1 && !filespec2) \t\t{ \t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\treturn(NULL); \t\t} \t/* If the first file specification is a rooted path, it rules. \t   same goes if the second file specification is missing. */ \tif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec1); \t\t} \t/* If the first file specification is missing, the second one rules. */ \telse if (!filespec1) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\t} \telse \t\t/* This part isn't as trivial as it looks.  It assumes that \t\t   the second file specification really is a directory, and \t\t   makes no checks whatsoever.  Therefore, the result becomes \t\t   the concatenation of filespec2 followed by a slash followed \t\t   by filespec1. */ \t\t{ \t\tint spec2len, len; \t\tspec2len = strlen(filespec2); \t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0); \t\tif(filespec2 && filespec2[spec2len - 1] == '/') \t\t\t{ \t\t\tspec2len--; \t\t\tlen--; \t\t\t} \t\tmerged = OPENSSL_malloc(len + 2); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\tmerged[spec2len] = '/'; \t\tstrcpy(&merged[spec2len + 1], filespec1); \t\t} \treturn(merged); \t}-#ifdef OPENSSL_SYS_MAC-#define DSO_ext\t\".dynlib\"-#define DSO_extlen 7+#ifdef OPENSSL_SYS_MACOSX+#define DSO_ext\t\".dylib\"+#define DSO_extlen 6 #else #define DSO_ext\t\".so\" #define DSO_extlen 3 #endif",
            "commit_date": "2009-07-16 09:52:59+00:00",
            "commit_hash": "3c630352e22f2f8295d70cceb8f034294aadc822",
            "message": "Use correct extension and OSX detection."
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -287,67 +287,74 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, \tconst char *filespec2) \t{ \tchar *merged; \tif(!filespec1 && !filespec2) \t\t{ \t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\treturn(NULL); \t\t} \t/* If the first file specification is a rooted path, it rules. \t   same goes if the second file specification is missing. */ \tif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec1); \t\t} \t/* If the first file specification is missing, the second one rules. */ \telse if (!filespec1) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\t} \telse \t\t/* This part isn't as trivial as it looks.  It assumes that \t\t   the second file specification really is a directory, and \t\t   makes no checks whatsoever.  Therefore, the result becomes \t\t   the concatenation of filespec2 followed by a slash followed \t\t   by filespec1. */ \t\t{ \t\tint spec2len, len; \t\tspec2len = strlen(filespec2); \t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0); \t\tif(filespec2 && filespec2[spec2len - 1] == '/') \t\t\t{ \t\t\tspec2len--; \t\t\tlen--; \t\t\t} \t\tmerged = OPENSSL_malloc(len + 2); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\tmerged[spec2len] = '/'; \t\tstrcpy(&merged[spec2len + 1], filespec1); \t\t} \treturn(merged); \t}+#ifdef OPENSSL_SYS_MAC+#define DSO_ext\t\".dynlib\"+#define DSO_extlen 7+#else+#define DSO_ext\t\".so\"+#define DSO_extlen 3+#endif",
            "commit_date": "2009-07-15 18:00:04+00:00",
            "commit_hash": "4a620922e243fae11fe3702c4183a80592b03701",
            "message": "Updates from 1.0.0-stable"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -285,68 +285,67 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, \tconst char *filespec2) \t{ \tchar *merged; \tif(!filespec1 && !filespec2) \t\t{ \t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\treturn(NULL); \t\t} \t/* If the first file specification is a rooted path, it rules. \t   same goes if the second file specification is missing. */-\tif (!filespec2 || filespec1[0] == '/')+\tif (!filespec2 || (filespec1 != NULL && filespec1[0] == '/')) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1); \t\tif(!merged) \t\t\t{-\t\t\tDSOerr(DSO_F_DLFCN_MERGER,-\t\t\t\tERR_R_MALLOC_FAILURE);+\t\t\tDSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec1); \t\t} \t/* If the first file specification is missing, the second one rules. */ \telse if (!filespec1) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\t} \telse \t\t/* This part isn't as trivial as it looks.  It assumes that \t\t   the second file specification really is a directory, and \t\t   makes no checks whatsoever.  Therefore, the result becomes \t\t   the concatenation of filespec2 followed by a slash followed \t\t   by filespec1. */ \t\t{ \t\tint spec2len, len; \t\tspec2len = strlen(filespec2); \t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0); \t\tif(filespec2 && filespec2[spec2len - 1] == '/') \t\t\t{ \t\t\tspec2len--; \t\t\tlen--; \t\t\t} \t\tmerged = OPENSSL_malloc(len + 2); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\tmerged[spec2len] = '/'; \t\tstrcpy(&merged[spec2len + 1], filespec1); \t\t} \treturn(merged); \t}",
            "commit_date": "2007-04-02 20:02:27+00:00",
            "commit_hash": "c971ca4c86b0a7bb4bb7a7d1a3c183b78dfbf144",
            "message": "check if pointer is != NULL before dereferencing it (Coverity CID 40)"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -282,68 +282,68 @@ static char *dlfcn_merger(DSO *dso, const char *filespec1, \tconst char *filespec2) \t{ \tchar *merged; \tif(!filespec1 && !filespec2) \t\t{ \t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\treturn(NULL); \t\t} \t/* If the first file specification is a rooted path, it rules. \t   same goes if the second file specification is missing. */ \tif (!filespec2 || filespec1[0] == '/') \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec1); \t\t} \t/* If the first file specification is missing, the second one rules. */ \telse if (!filespec1) \t\t{ \t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\t} \telse \t\t/* This part isn't as trivial as it looks.  It assumes that \t\t   the second file specification really is a directory, and \t\t   makes no checks whatsoever.  Therefore, the result becomes \t\t   the concatenation of filespec2 followed by a slash followed \t\t   by filespec1. */ \t\t{ \t\tint spec2len, len;-\t\tspec2len = (filespec2 ? strlen(filespec2) : 0);+\t\tspec2len = strlen(filespec2); \t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0); \t\tif(filespec2 && filespec2[spec2len - 1] == '/') \t\t\t{ \t\t\tspec2len--; \t\t\tlen--; \t\t\t} \t\tmerged = OPENSSL_malloc(len + 2); \t\tif(!merged) \t\t\t{ \t\t\tDSOerr(DSO_F_DLFCN_MERGER, \t\t\t\tERR_R_MALLOC_FAILURE); \t\t\treturn(NULL); \t\t\t} \t\tstrcpy(merged, filespec2); \t\tmerged[spec2len] = '/'; \t\tstrcpy(&merged[spec2len + 1], filespec1); \t\t} \treturn(merged); \t}",
            "commit_date": "2006-03-15 17:45:43+00:00",
            "commit_hash": "67b6f1ca889d789e04c58e5b2fbad0944bb1cd1a",
            "message": "fix problems found by coverity: remove useless code"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- a/crypto/dso/dso_dlfcn.c+++ b/crypto/dso/dso_dlfcn.c@@ -254,1 +257,68 @@+static char *dlfcn_merger(DSO *dso, const char *filespec1,+\tconst char *filespec2)+\t{+\tchar *merged;++\tif(!filespec1 && !filespec2)+\t\t{+\t\tDSOerr(DSO_F_DLFCN_MERGER,+\t\t\t\tERR_R_PASSED_NULL_PARAMETER);+\t\treturn(NULL);+\t\t}+\t/* If the first file specification is a rooted path, it rules.+\t   same goes if the second file specification is missing. */+\tif (!filespec2 || filespec1[0] == '/')+\t\t{+\t\tmerged = OPENSSL_malloc(strlen(filespec1) + 1);+\t\tif(!merged)+\t\t\t{+\t\t\tDSOerr(DSO_F_DLFCN_MERGER,+\t\t\t\tERR_R_MALLOC_FAILURE);+\t\t\treturn(NULL);+\t\t\t}+\t\tstrcpy(merged, filespec1);+\t\t}+\t/* If the first file specification is missing, the second one rules. */+\telse if (!filespec1)+\t\t{+\t\tmerged = OPENSSL_malloc(strlen(filespec2) + 1);+\t\tif(!merged)+\t\t\t{+\t\t\tDSOerr(DSO_F_DLFCN_MERGER,+\t\t\t\tERR_R_MALLOC_FAILURE);+\t\t\treturn(NULL);+\t\t\t}+\t\tstrcpy(merged, filespec2);+\t\t}+\telse+\t\t/* This part isn't as trivial as it looks.  It assumes that+\t\t   the second file specification really is a directory, and+\t\t   makes no checks whatsoever.  Therefore, the result becomes+\t\t   the concatenation of filespec2 followed by a slash followed+\t\t   by filespec1. */+\t\t{+\t\tint spec2len, len;++\t\tspec2len = (filespec2 ? strlen(filespec2) : 0);+\t\tlen = spec2len + (filespec1 ? strlen(filespec1) : 0);++\t\tif(filespec2 && filespec2[spec2len - 1] == '/')+\t\t\t{+\t\t\tspec2len--;+\t\t\tlen--;+\t\t\t}+\t\tmerged = OPENSSL_malloc(len + 2);+\t\tif(!merged)+\t\t\t{+\t\t\tDSOerr(DSO_F_DLFCN_MERGER,+\t\t\t\tERR_R_MALLOC_FAILURE);+\t\t\treturn(NULL);+\t\t\t}+\t\tstrcpy(merged, filespec2);+\t\tmerged[spec2len] = '/';+\t\tstrcpy(&merged[spec2len + 1], filespec1);+\t\t}+\treturn(merged);+\t}+",
            "commit_date": "2002-07-15 15:35:40+00:00",
            "commit_hash": "cbecb3ac3763f1179dc220a69d28e92f58e9443e",
            "message": "There's an ongoing project to bring some kind of path selection\nmechanism to the ENGINE framework.  This means there there are going\nto be new functionality for the DSO part, and ultimately some way of\nmerging two file specifications together.\nThis commit places the merging code into the repository.  It's\ncurrently not used anywhere, and hasn't been tested at all.  It may be\nfull of errors, including syntactical ones.  Those will be fixed as\npromptly as possible."
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/dso/dso_dlfcn.c b/crypto/dso/dso_dlfcn.c--- /dev/null+++ b/crypto/dso/dso_dlfcn.c@@ -0,0 +178,1 @@+",
            "commit_date": "2000-04-04 21:57:11+00:00",
            "commit_hash": "8f4fac7f965b4604bc71be4bd486a8641c0504ab",
            "message": "This is a set of startup code for the DSO support, it's not yet linked into\nthe build process (an upcoming commit no doubt), and is very much *new*\ncode - what that means is that it compiles ok - usually. It certainly\ndoesn't mean it runs well or even properly yet. Please don't muck round\nwith this unless you're looking to help out and hunt bugs. :-)\nCurrently this code doesn't have any support for controlling the \"load\"\nbehaviour (eg. paths, filename translations, etc). That'll be handled\nusing DSO_ctrl() and various flags, once we work out a sensible set of\nflags."
        }
    ],
    "git log -L411,428:test/testutil/driver.c": [
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/test/testutil/driver.c b/test/testutil/driver.c--- a/test/testutil/driver.c+++ b/test/testutil/driver.c@@ -275,0 +278,18 @@+ */+char *glue_strings(const char *list[], size_t *out_len)+{+    size_t len = 0;+    char *p, *ret;+    int i;++    for (i = 0; list[i] != NULL; i++)+        len += strlen(list[i]);++    if (out_len != NULL)+        *out_len = len;++    if (!TEST_ptr(ret = p = OPENSSL_malloc(len + 1)))+        return NULL;++    for (i = 0; list[i] != NULL; i++)+        p += strlen(strcpy(p, list[i]));",
            "commit_date": "2017-11-07 11:50:30+01:00",
            "commit_hash": "4483fbae10a9277812cc8a587ef58a5a512fe7c9",
            "message": "Factorise duplicated code.\nExtract and factorise duplicated string glue code.\nCache strlen result to avoid duplicate calls.\n[extended tests]\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4719)"
        }
    ],
    "git log -L63,113:crypto/engine/eng_ctrl.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -63,51 +63,51 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, {-            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);+            ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);-            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NAME);-        ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NUMBER);",
            "commit_date": "2020-11-04 12:23:19+01:00",
            "commit_hash": "9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2",
            "message": "Convert all {NAME}err() in crypto/ to their corresponding ERR_raise() call\nThis includes error reporting for libcrypto sub-libraries in surprising\nplaces.\nThis was done using util/err-to-raise\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13318)\nvoid (*f) (void))\nint idx;\nchar *s = (char *)p;\nconst ENGINE_CMD_DEFN *cdp;\n/* Take care of the easy one first (eg. it requires no searches) */\nif (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\nif ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\nreturn 0;\nreturn e->cmd_defns->cmd_num;\n}\n/* One or two commands require that \"p\" be a valid string buffer */\nif ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\nif (s == NULL) {\nreturn -1;\n}\n}\n/* Now handle cmd_name -> cmd_num conversion */\nif (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\nreturn -1;\n}\nreturn e->cmd_defns[idx].cmd_num;\n}\n/*\n* For the rest of the commands, the 'long' argument must specify a valid\n* command number - so we need to conduct a search.\n*/\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_num(e->cmd_defns, (unsigned int)i)) < 0)) {\nreturn -1;\n}\n/* Now the logic splits depending on command type */\ncdp = &e->cmd_defns[idx];\nswitch (cmd) {\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\ncdp++;\nreturn int_ctrl_cmd_is_null(cdp) ? 0 : cdp->cmd_num;\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\nreturn strlen(cdp->cmd_name);\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\nreturn strlen(strcpy(s, cdp->cmd_name));"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -60,53 +60,51 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, {+    const ENGINE_CMD_DEFN *cdp;+-    if ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,-                                                              (unsigned int)-                                                              i)) < 0)) {+    if ((e->cmd_defns == NULL)+        || ((idx = int_ctrl_cmd_by_num(e->cmd_defns, (unsigned int)i)) < 0)) {+    cdp = &e->cmd_defns[idx];-        idx++;-        if (int_ctrl_cmd_is_null(e->cmd_defns + idx))-            /* end-of-list */-            return 0;-        else-            return e->cmd_defns[idx].cmd_num;+        cdp++;+        return int_ctrl_cmd_is_null(cdp) ? 0 : cdp->cmd_num;-        return strlen(e->cmd_defns[idx].cmd_name);+        return strlen(cdp->cmd_name);-        return sprintf(s, \"%s\", e->cmd_defns[idx].cmd_name);+        return strlen(strcpy(s, cdp->cmd_name));",
            "commit_date": "2017-08-25 09:01:17-04:00",
            "commit_hash": "b5fe5dfbdaf8ee25e45c9a94736a1478a355e136",
            "message": "Use strcpy instead of sprintf %s\nAlso use a local variable, collapse some code.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4258)\nvoid (*f) (void))\nint idx;\nchar *s = (char *)p;\n/* Take care of the easy one first (eg. it requires no searches) */\nif (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\nif ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\nreturn 0;\nreturn e->cmd_defns->cmd_num;\n}\n/* One or two commands require that \"p\" be a valid string buffer */\nif ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\nif (s == NULL) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);\nreturn -1;\n}\n}\n/* Now handle cmd_name -> cmd_num conversion */\nif (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);\nreturn -1;\n}\nreturn e->cmd_defns[idx].cmd_num;\n}\n/*\n* For the rest of the commands, the 'long' argument must specify a valid\n* command number - so we need to conduct a search.\n*/\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);\nreturn -1;\n}\n/* Now the logic splits depending on command type */\nswitch (cmd) {\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -60,54 +60,53 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, {-        return BIO_snprintf(s, strlen(e->cmd_defns[idx].cmd_name) + 1,-                            \"%s\", e->cmd_defns[idx].cmd_name);+        return sprintf(s, \"%s\", e->cmd_defns[idx].cmd_name);",
            "commit_date": "2017-06-14 20:34:37-04:00",
            "commit_hash": "0904e79a6e6109240d5a552f2699408b26cf63ee",
            "message": "Undo commit d420ac2\n[extended tests]\nOriginal text:\nUse BUF_strlcpy() instead of strcpy().\nUse BUF_strlcat() instead of strcat().\nUse BIO_snprintf() instead of sprintf().\nIn some cases, keep better track of buffer lengths.\nThis is part of a large change submitted by Markus Friedl <markus@openbsd.org>\nReviewed-by: Tim Hudson <tjh@openssl.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/3701)\nvoid (*f) (void))\nint idx;\nchar *s = (char *)p;\n/* Take care of the easy one first (eg. it requires no searches) */\nif (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\nif ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\nreturn 0;\nreturn e->cmd_defns->cmd_num;\n}\n/* One or two commands require that \"p\" be a valid string buffer */\nif ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\nif (s == NULL) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);\nreturn -1;\n}\n}\n/* Now handle cmd_name -> cmd_num conversion */\nif (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);\nreturn -1;\n}\nreturn e->cmd_defns[idx].cmd_num;\n}\n/*\n* For the rest of the commands, the 'long' argument must specify a valid\n* command number - so we need to conduct a search.\n*/\nif ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,\n(unsigned int)\ni)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);\nreturn -1;\n}\n/* Now the logic splits depending on command type */\nswitch (cmd) {\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\nidx++;\nif (int_ctrl_cmd_is_null(e->cmd_defns + idx))\n/* end-of-list */\nreturn 0;\nelse\nreturn e->cmd_defns[idx].cmd_num;\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\nreturn strlen(e->cmd_defns[idx].cmd_name);\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:"
        },
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -105,54 +105,54 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, {-     * For the rest of the commands, the 'long' argument must specify a valie+     * For the rest of the commands, the 'long' argument must specify a valid",
            "commit_date": "2016-02-05 15:23:54-05:00",
            "commit_hash": "0d4fb8439092ff8253af72ac6bc193e77ebbcf2f",
            "message": "GH601: Various spelling fixes.\nSigned-off-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nvoid (*f) (void))\nint idx;\nchar *s = (char *)p;\n/* Take care of the easy one first (eg. it requires no searches) */\nif (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\nif ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\nreturn 0;\nreturn e->cmd_defns->cmd_num;\n}\n/* One or two commands require that \"p\" be a valid string buffer */\nif ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\nif (s == NULL) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);\nreturn -1;\n}\n}\n/* Now handle cmd_name -> cmd_num conversion */\nif (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);\nreturn -1;\n}\nreturn e->cmd_defns[idx].cmd_num;\n}\n/*\n* command number - so we need to conduct a search.\n*/\nif ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,\n(unsigned int)\ni)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);\nreturn -1;\n}\n/* Now the logic splits depending on command type */\nswitch (cmd) {\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\nidx++;\nif (int_ctrl_cmd_is_null(e->cmd_defns + idx))\n/* end-of-list */\nreturn 0;\nelse\nreturn e->cmd_defns[idx].cmd_num;\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\nreturn strlen(e->cmd_defns[idx].cmd_name);\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\nreturn BIO_snprintf(s, strlen(e->cmd_defns[idx].cmd_name) + 1,\n\"%s\", e->cmd_defns[idx].cmd_name);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -102,79 +106,54 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,-\t\t\t   void (*f)(void))-\t{-\tint idx;-\tchar *s = (char *)p;-\t/* Take care of the easy one first (eg. it requires no searches) */-\tif(cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE)-\t\t{-\t\tif((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))-\t\t\treturn 0;-\t\treturn e->cmd_defns->cmd_num;-\t\t}-\t/* One or two commands require that \"p\" be a valid string buffer */-\tif((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||-\t\t\t(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||-\t\t\t(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD))-\t\t{-\t\tif(s == NULL)-\t\t\t{-\t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,-\t\t\t\tERR_R_PASSED_NULL_PARAMETER);-\t\t\treturn -1;-\t\t\t}-\t\t}-\t/* Now handle cmd_name -> cmd_num conversion */-\tif(cmd == ENGINE_CTRL_GET_CMD_FROM_NAME)-\t\t{-\t\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(-\t\t\t\t\t\te->cmd_defns, s)) < 0))-\t\t\t{-\t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,-\t\t\t\tENGINE_R_INVALID_CMD_NAME);-\t\t\treturn -1;-\t\t\t}-\t\treturn e->cmd_defns[idx].cmd_num;-\t\t}-\t/* For the rest of the commands, the 'long' argument must specify a-\t * valie command number - so we need to conduct a search. */-\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,-\t\t\t\t\t(unsigned int)i)) < 0))-\t\t{-\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,-\t\t\tENGINE_R_INVALID_CMD_NUMBER);-\t\treturn -1;-\t\t}-\t/* Now the logic splits depending on command type */-\tswitch(cmd)-\t\t{-\tcase ENGINE_CTRL_GET_NEXT_CMD_TYPE:-\t\tidx++;-\t\tif(int_ctrl_cmd_is_null(e->cmd_defns + idx))-\t\t\t/* end-of-list */-\t\t\treturn 0;-\t\telse-\t\t\treturn e->cmd_defns[idx].cmd_num;-\tcase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:-\t\treturn strlen(e->cmd_defns[idx].cmd_name);-\tcase ENGINE_CTRL_GET_NAME_FROM_CMD:-\t\treturn BIO_snprintf(s,strlen(e->cmd_defns[idx].cmd_name) + 1,-\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_name);-\tcase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:-\t\tif(e->cmd_defns[idx].cmd_desc)-\t\t\treturn strlen(e->cmd_defns[idx].cmd_desc);-\t\treturn strlen(int_no_description);-\tcase ENGINE_CTRL_GET_DESC_FROM_CMD:-\t\tif(e->cmd_defns[idx].cmd_desc)-\t\t\treturn BIO_snprintf(s,-\t\t\t\t\t    strlen(e->cmd_defns[idx].cmd_desc) + 1,-\t\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_desc);-\t\treturn BIO_snprintf(s, strlen(int_no_description) + 1,\"%s\",-\t\t\t\t    int_no_description);-\tcase ENGINE_CTRL_GET_CMD_FLAGS:-\t\treturn e->cmd_defns[idx].cmd_flags;-\t\t}-\t/* Shouldn't really be here ... */-\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,ENGINE_R_INTERNAL_LIST_ERROR);-\treturn -1;-\t}+                           void (*f) (void))+{+    int idx;+    char *s = (char *)p;+    /* Take care of the easy one first (eg. it requires no searches) */+    if (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {+        if ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))+            return 0;+        return e->cmd_defns->cmd_num;+    }+    /* One or two commands require that \"p\" be a valid string buffer */+    if ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||+        (cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||+        (cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {+        if (s == NULL) {+            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);+            return -1;+        }+    }+    /* Now handle cmd_name -> cmd_num conversion */+    if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {+        if ((e->cmd_defns == NULL)+            || ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {+            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);+            return -1;+        }+        return e->cmd_defns[idx].cmd_num;+    }+    /*+     * For the rest of the commands, the 'long' argument must specify a valie+     * command number - so we need to conduct a search.+     */+    if ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,+                                                              (unsigned int)+                                                              i)) < 0)) {+        ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);+        return -1;+    }+    /* Now the logic splits depending on command type */+    switch (cmd) {+    case ENGINE_CTRL_GET_NEXT_CMD_TYPE:+        idx++;+        if (int_ctrl_cmd_is_null(e->cmd_defns + idx))+            /* end-of-list */+            return 0;+        else+            return e->cmd_defns[idx].cmd_num;+    case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:+        return strlen(e->cmd_defns[idx].cmd_name);+    case ENGINE_CTRL_GET_NAME_FROM_CMD:+        return BIO_snprintf(s, strlen(e->cmd_defns[idx].cmd_name) + 1,+                            \"%s\", e->cmd_defns[idx].cmd_name);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -102,78 +102,79 @@-static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f)())+static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,+\t\t\t   void (*f)(void)) \t{ \tint idx; \tchar *s = (char *)p; \t/* Take care of the easy one first (eg. it requires no searches) */ \tif(cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) \t\t{ \t\tif((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns)) \t\t\treturn 0; \t\treturn e->cmd_defns->cmd_num; \t\t} \t/* One or two commands require that \"p\" be a valid string buffer */ \tif((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) || \t\t\t(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) || \t\t\t(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) \t\t{ \t\tif(s == NULL) \t\t\t{ \t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\t\treturn -1; \t\t\t} \t\t} \t/* Now handle cmd_name -> cmd_num conversion */ \tif(cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) \t\t{ \t\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name( \t\t\t\t\t\te->cmd_defns, s)) < 0)) \t\t\t{ \t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\t\tENGINE_R_INVALID_CMD_NAME); \t\t\treturn -1; \t\t\t} \t\treturn e->cmd_defns[idx].cmd_num; \t\t} \t/* For the rest of the commands, the 'long' argument must specify a \t * valie command number - so we need to conduct a search. */ \tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns, \t\t\t\t\t(unsigned int)i)) < 0)) \t\t{ \t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\tENGINE_R_INVALID_CMD_NUMBER); \t\treturn -1; \t\t} \t/* Now the logic splits depending on command type */ \tswitch(cmd) \t\t{ \tcase ENGINE_CTRL_GET_NEXT_CMD_TYPE: \t\tidx++; \t\tif(int_ctrl_cmd_is_null(e->cmd_defns + idx)) \t\t\t/* end-of-list */ \t\t\treturn 0; \t\telse \t\t\treturn e->cmd_defns[idx].cmd_num; \tcase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: \t\treturn strlen(e->cmd_defns[idx].cmd_name); \tcase ENGINE_CTRL_GET_NAME_FROM_CMD: \t\treturn BIO_snprintf(s,strlen(e->cmd_defns[idx].cmd_name) + 1, \t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_name); \tcase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: \t\tif(e->cmd_defns[idx].cmd_desc) \t\t\treturn strlen(e->cmd_defns[idx].cmd_desc); \t\treturn strlen(int_no_description); \tcase ENGINE_CTRL_GET_DESC_FROM_CMD: \t\tif(e->cmd_defns[idx].cmd_desc) \t\t\treturn BIO_snprintf(s, \t\t\t\t\t    strlen(e->cmd_defns[idx].cmd_desc) + 1, \t\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_desc); \t\treturn BIO_snprintf(s, strlen(int_no_description) + 1,\"%s\", \t\t\t\t    int_no_description); \tcase ENGINE_CTRL_GET_CMD_FLAGS: \t\treturn e->cmd_defns[idx].cmd_flags; \t\t} \t/* Shouldn't really be here ... */ \tENGINEerr(ENGINE_F_INT_CTRL_HELPER,ENGINE_R_INTERNAL_LIST_ERROR); \treturn -1; \t}",
            "commit_date": "2005-03-31 09:26:39+00:00",
            "commit_hash": "41a15c4f0f2535591ba9f258cf76119f86477c43",
            "message": "Give everything prototypes (well, everything that's actually used)."
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -105,74 +105,78 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f)()) \t{ \tint idx; \tchar *s = (char *)p; \t/* Take care of the easy one first (eg. it requires no searches) */ \tif(cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) \t\t{ \t\tif((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns)) \t\t\treturn 0; \t\treturn e->cmd_defns->cmd_num; \t\t} \t/* One or two commands require that \"p\" be a valid string buffer */ \tif((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) || \t\t\t(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) || \t\t\t(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) \t\t{ \t\tif(s == NULL) \t\t\t{ \t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\t\treturn -1; \t\t\t} \t\t} \t/* Now handle cmd_name -> cmd_num conversion */ \tif(cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) \t\t{ \t\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name( \t\t\t\t\t\te->cmd_defns, s)) < 0)) \t\t\t{ \t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\t\tENGINE_R_INVALID_CMD_NAME); \t\t\treturn -1; \t\t\t} \t\treturn e->cmd_defns[idx].cmd_num; \t\t} \t/* For the rest of the commands, the 'long' argument must specify a \t * valie command number - so we need to conduct a search. */ \tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns, \t\t\t\t\t(unsigned int)i)) < 0)) \t\t{ \t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\tENGINE_R_INVALID_CMD_NUMBER); \t\treturn -1; \t\t} \t/* Now the logic splits depending on command type */ \tswitch(cmd) \t\t{ \tcase ENGINE_CTRL_GET_NEXT_CMD_TYPE: \t\tidx++; \t\tif(int_ctrl_cmd_is_null(e->cmd_defns + idx)) \t\t\t/* end-of-list */ \t\t\treturn 0; \t\telse \t\t\treturn e->cmd_defns[idx].cmd_num; \tcase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: \t\treturn strlen(e->cmd_defns[idx].cmd_name); \tcase ENGINE_CTRL_GET_NAME_FROM_CMD:-\t\treturn sprintf(s, \"%s\", e->cmd_defns[idx].cmd_name);+\t\treturn BIO_snprintf(s,strlen(e->cmd_defns[idx].cmd_name) + 1,+\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_name); \tcase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: \t\tif(e->cmd_defns[idx].cmd_desc) \t\t\treturn strlen(e->cmd_defns[idx].cmd_desc); \t\treturn strlen(int_no_description); \tcase ENGINE_CTRL_GET_DESC_FROM_CMD: \t\tif(e->cmd_defns[idx].cmd_desc)-\t\t\treturn sprintf(s, \"%s\", e->cmd_defns[idx].cmd_desc);-\t\treturn sprintf(s, \"%s\", int_no_description);+\t\t\treturn BIO_snprintf(s,+\t\t\t\t\t    strlen(e->cmd_defns[idx].cmd_desc) + 1,+\t\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_desc);+\t\treturn BIO_snprintf(s, strlen(int_no_description) + 1,\"%s\",+\t\t\t\t    int_no_description); \tcase ENGINE_CTRL_GET_CMD_FLAGS: \t\treturn e->cmd_defns[idx].cmd_flags; \t\t} \t/* Shouldn't really be here ... */ \tENGINEerr(ENGINE_F_INT_CTRL_HELPER,ENGINE_R_INTERNAL_LIST_ERROR); \treturn -1; \t}",
            "commit_date": "2003-12-27 14:40:17+00:00",
            "commit_hash": "d420ac2c7d4ba9d99ff2c257a3ad71ecc6d876e2",
            "message": "Use BUF_strlcpy() instead of strcpy().\nUse BUF_strlcat() instead of strcat().\nUse BIO_snprintf() instead of sprintf().\nIn some cases, keep better track of buffer lengths.\nThis is part of a large change submitted by Markus Friedl <markus@openbsd.org>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- /dev/null+++ b/crypto/engine/eng_ctrl.c@@ -0,0 +105,74 @@++static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f)())+\t{+\tint idx;+\tchar *s = (char *)p;+\t/* Take care of the easy one first (eg. it requires no searches) */+\tif(cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE)+\t\t{+\t\tif((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))+\t\t\treturn 0;+\t\treturn e->cmd_defns->cmd_num;+\t\t}+\t/* One or two commands require that \"p\" be a valid string buffer */+\tif((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||+\t\t\t(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||+\t\t\t(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD))+\t\t{+\t\tif(s == NULL)+\t\t\t{+\t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,+\t\t\t\tERR_R_PASSED_NULL_PARAMETER);+\t\t\treturn -1;+\t\t\t}+\t\t}+\t/* Now handle cmd_name -> cmd_num conversion */+\tif(cmd == ENGINE_CTRL_GET_CMD_FROM_NAME)+\t\t{+\t\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(+\t\t\t\t\t\te->cmd_defns, s)) < 0))+\t\t\t{+\t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,+\t\t\t\tENGINE_R_INVALID_CMD_NAME);+\t\t\treturn -1;+\t\t\t}+\t\treturn e->cmd_defns[idx].cmd_num;+\t\t}+\t/* For the rest of the commands, the 'long' argument must specify a+\t * valie command number - so we need to conduct a search. */+\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,+\t\t\t\t\t(unsigned int)i)) < 0))+\t\t{+\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,+\t\t\tENGINE_R_INVALID_CMD_NUMBER);+\t\treturn -1;+\t\t}+\t/* Now the logic splits depending on command type */+\tswitch(cmd)+\t\t{+\tcase ENGINE_CTRL_GET_NEXT_CMD_TYPE:+\t\tidx++;+\t\tif(int_ctrl_cmd_is_null(e->cmd_defns + idx))+\t\t\t/* end-of-list */+\t\t\treturn 0;+\t\telse+\t\t\treturn e->cmd_defns[idx].cmd_num;+\tcase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:+\t\treturn strlen(e->cmd_defns[idx].cmd_name);+\tcase ENGINE_CTRL_GET_NAME_FROM_CMD:+\t\treturn sprintf(s, \"%s\", e->cmd_defns[idx].cmd_name);+\tcase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:+\t\tif(e->cmd_defns[idx].cmd_desc)+\t\t\treturn strlen(e->cmd_defns[idx].cmd_desc);+\t\treturn strlen(int_no_description);+\tcase ENGINE_CTRL_GET_DESC_FROM_CMD:+\t\tif(e->cmd_defns[idx].cmd_desc)+\t\t\treturn sprintf(s, \"%s\", e->cmd_defns[idx].cmd_desc);+\t\treturn sprintf(s, \"%s\", int_no_description);+\tcase ENGINE_CTRL_GET_CMD_FLAGS:+\t\treturn e->cmd_defns[idx].cmd_flags;+\t\t}+\t/* Shouldn't really be here ... */+\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,ENGINE_R_INTERNAL_LIST_ERROR);+\treturn -1;+\t}",
            "commit_date": "2001-09-25 20:00:51+00:00",
            "commit_hash": "b6d1e52d454bb321153c70cf763945d4b0d4f78e",
            "message": "This change replaces the ENGINE's underlying mechanics with the new\nENGINE_TABLE-based stuff - as described in crypto/engine/README.\nAssociated miscellaneous changes;\n- the previous cipher/digest hooks that hardwired directly to EVP's\nOBJ_NAME-based storage have been backed out. New cipher/digest support\nhas been constructed and will be committed shortly.\n- each implementation defines its own ENGINE_load_<name> function now.\n- the \"openssl\" ENGINE isn't needed or loaded any more.\n- core (not algorithm or class specific) ENGINE code has been split into\nmultiple files to increase readability and decrease linker bloat.\n- ENGINE_cpy() has been removed as it wasn't really a good idea in the\nfirst place and now, because of registration issues, can't be\nmeaningfully defined any more.\n- BN_MOD_EXP[_CRT] support is removed as per the README.\n- a bug in enginetest.c has been fixed.\nNB: This commit almost certainly breaks compilation until subsequent\nchanges are committed."
        }
    ],
    "git log -L63,118:crypto/engine/eng_ctrl.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -63,56 +63,56 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, {-            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);+            ERR_raise(ERR_LIB_ENGINE, ERR_R_PASSED_NULL_PARAMETER);-            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);+            ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NAME);-        ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);+        ERR_raise(ERR_LIB_ENGINE, ENGINE_R_INVALID_CMD_NUMBER);",
            "commit_date": "2020-11-04 12:23:19+01:00",
            "commit_hash": "9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2",
            "message": "Convert all {NAME}err() in crypto/ to their corresponding ERR_raise() call\nThis includes error reporting for libcrypto sub-libraries in surprising\nplaces.\nThis was done using util/err-to-raise\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13318)\nvoid (*f) (void))\nint idx;\nchar *s = (char *)p;\nconst ENGINE_CMD_DEFN *cdp;\n/* Take care of the easy one first (eg. it requires no searches) */\nif (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\nif ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\nreturn 0;\nreturn e->cmd_defns->cmd_num;\n}\n/* One or two commands require that \"p\" be a valid string buffer */\nif ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\nif (s == NULL) {\nreturn -1;\n}\n}\n/* Now handle cmd_name -> cmd_num conversion */\nif (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\nreturn -1;\n}\nreturn e->cmd_defns[idx].cmd_num;\n}\n/*\n* For the rest of the commands, the 'long' argument must specify a valid\n* command number - so we need to conduct a search.\n*/\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_num(e->cmd_defns, (unsigned int)i)) < 0)) {\nreturn -1;\n}\n/* Now the logic splits depending on command type */\ncdp = &e->cmd_defns[idx];\nswitch (cmd) {\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\ncdp++;\nreturn int_ctrl_cmd_is_null(cdp) ? 0 : cdp->cmd_num;\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\nreturn strlen(cdp->cmd_name);\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\nreturn strlen(strcpy(s, cdp->cmd_name));\ncase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\nreturn strlen(cdp->cmd_desc == NULL ? int_no_description\n: cdp->cmd_desc);\ncase ENGINE_CTRL_GET_DESC_FROM_CMD:\nreturn strlen(strcpy(s, cdp->cmd_desc == NULL ? int_no_description"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -60,61 +60,56 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, {+    const ENGINE_CMD_DEFN *cdp;+-    if ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,-                                                              (unsigned int)-                                                              i)) < 0)) {+    if ((e->cmd_defns == NULL)+        || ((idx = int_ctrl_cmd_by_num(e->cmd_defns, (unsigned int)i)) < 0)) {+    cdp = &e->cmd_defns[idx];-        idx++;-        if (int_ctrl_cmd_is_null(e->cmd_defns + idx))-            /* end-of-list */-            return 0;-        else-            return e->cmd_defns[idx].cmd_num;+        cdp++;+        return int_ctrl_cmd_is_null(cdp) ? 0 : cdp->cmd_num;-        return strlen(e->cmd_defns[idx].cmd_name);+        return strlen(cdp->cmd_name);-        return sprintf(s, \"%s\", e->cmd_defns[idx].cmd_name);+        return strlen(strcpy(s, cdp->cmd_name));-        if (e->cmd_defns[idx].cmd_desc)-            return strlen(e->cmd_defns[idx].cmd_desc);-        return strlen(int_no_description);+        return strlen(cdp->cmd_desc == NULL ? int_no_description+                                            : cdp->cmd_desc);-        if (e->cmd_defns[idx].cmd_desc)-            return sprintf(s, \"%s\", e->cmd_defns[idx].cmd_desc);-        return sprintf(s, \"%s\", int_no_description);+        return strlen(strcpy(s, cdp->cmd_desc == NULL ? int_no_description",
            "commit_date": "2017-08-25 09:01:17-04:00",
            "commit_hash": "b5fe5dfbdaf8ee25e45c9a94736a1478a355e136",
            "message": "Use strcpy instead of sprintf %s\nAlso use a local variable, collapse some code.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4258)\nvoid (*f) (void))\nint idx;\nchar *s = (char *)p;\n/* Take care of the easy one first (eg. it requires no searches) */\nif (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\nif ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\nreturn 0;\nreturn e->cmd_defns->cmd_num;\n}\n/* One or two commands require that \"p\" be a valid string buffer */\nif ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\nif (s == NULL) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);\nreturn -1;\n}\n}\n/* Now handle cmd_name -> cmd_num conversion */\nif (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);\nreturn -1;\n}\nreturn e->cmd_defns[idx].cmd_num;\n}\n/*\n* For the rest of the commands, the 'long' argument must specify a valid\n* command number - so we need to conduct a search.\n*/\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);\nreturn -1;\n}\n/* Now the logic splits depending on command type */\nswitch (cmd) {\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\ncase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\ncase ENGINE_CTRL_GET_DESC_FROM_CMD:"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -60,65 +60,61 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, {-        return BIO_snprintf(s, strlen(e->cmd_defns[idx].cmd_name) + 1,-                            \"%s\", e->cmd_defns[idx].cmd_name);+        return sprintf(s, \"%s\", e->cmd_defns[idx].cmd_name);-            return BIO_snprintf(s,-                                strlen(e->cmd_defns[idx].cmd_desc) + 1,-                                \"%s\", e->cmd_defns[idx].cmd_desc);-        return BIO_snprintf(s, strlen(int_no_description) + 1, \"%s\",-                            int_no_description);+            return sprintf(s, \"%s\", e->cmd_defns[idx].cmd_desc);+        return sprintf(s, \"%s\", int_no_description);",
            "commit_date": "2017-06-14 20:34:37-04:00",
            "commit_hash": "0904e79a6e6109240d5a552f2699408b26cf63ee",
            "message": "Undo commit d420ac2\n[extended tests]\nOriginal text:\nUse BUF_strlcpy() instead of strcpy().\nUse BUF_strlcat() instead of strcat().\nUse BIO_snprintf() instead of sprintf().\nIn some cases, keep better track of buffer lengths.\nThis is part of a large change submitted by Markus Friedl <markus@openbsd.org>\nReviewed-by: Tim Hudson <tjh@openssl.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/3701)\nvoid (*f) (void))\nint idx;\nchar *s = (char *)p;\n/* Take care of the easy one first (eg. it requires no searches) */\nif (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\nif ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\nreturn 0;\nreturn e->cmd_defns->cmd_num;\n}\n/* One or two commands require that \"p\" be a valid string buffer */\nif ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\nif (s == NULL) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);\nreturn -1;\n}\n}\n/* Now handle cmd_name -> cmd_num conversion */\nif (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);\nreturn -1;\n}\nreturn e->cmd_defns[idx].cmd_num;\n}\n/*\n* For the rest of the commands, the 'long' argument must specify a valid\n* command number - so we need to conduct a search.\n*/\nif ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,\n(unsigned int)\ni)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);\nreturn -1;\n}\n/* Now the logic splits depending on command type */\nswitch (cmd) {\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\nidx++;\nif (int_ctrl_cmd_is_null(e->cmd_defns + idx))\n/* end-of-list */\nreturn 0;\nelse\nreturn e->cmd_defns[idx].cmd_num;\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\nreturn strlen(e->cmd_defns[idx].cmd_name);\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\ncase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\nif (e->cmd_defns[idx].cmd_desc)\nreturn strlen(e->cmd_defns[idx].cmd_desc);\nreturn strlen(int_no_description);\ncase ENGINE_CTRL_GET_DESC_FROM_CMD:\nif (e->cmd_defns[idx].cmd_desc)"
        },
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -105,65 +105,65 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, {-     * For the rest of the commands, the 'long' argument must specify a valie+     * For the rest of the commands, the 'long' argument must specify a valid",
            "commit_date": "2016-02-05 15:23:54-05:00",
            "commit_hash": "0d4fb8439092ff8253af72ac6bc193e77ebbcf2f",
            "message": "GH601: Various spelling fixes.\nSigned-off-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nvoid (*f) (void))\nint idx;\nchar *s = (char *)p;\n/* Take care of the easy one first (eg. it requires no searches) */\nif (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {\nif ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))\nreturn 0;\nreturn e->cmd_defns->cmd_num;\n}\n/* One or two commands require that \"p\" be a valid string buffer */\nif ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||\n(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||\n(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {\nif (s == NULL) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);\nreturn -1;\n}\n}\n/* Now handle cmd_name -> cmd_num conversion */\nif (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {\nif ((e->cmd_defns == NULL)\n|| ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);\nreturn -1;\n}\nreturn e->cmd_defns[idx].cmd_num;\n}\n/*\n* command number - so we need to conduct a search.\n*/\nif ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,\n(unsigned int)\ni)) < 0)) {\nENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);\nreturn -1;\n}\n/* Now the logic splits depending on command type */\nswitch (cmd) {\ncase ENGINE_CTRL_GET_NEXT_CMD_TYPE:\nidx++;\nif (int_ctrl_cmd_is_null(e->cmd_defns + idx))\n/* end-of-list */\nreturn 0;\nelse\nreturn e->cmd_defns[idx].cmd_num;\ncase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:\nreturn strlen(e->cmd_defns[idx].cmd_name);\ncase ENGINE_CTRL_GET_NAME_FROM_CMD:\nreturn BIO_snprintf(s, strlen(e->cmd_defns[idx].cmd_name) + 1,\n\"%s\", e->cmd_defns[idx].cmd_name);\ncase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:\nif (e->cmd_defns[idx].cmd_desc)\nreturn strlen(e->cmd_defns[idx].cmd_desc);\nreturn strlen(int_no_description);\ncase ENGINE_CTRL_GET_DESC_FROM_CMD:\nif (e->cmd_defns[idx].cmd_desc)\nreturn BIO_snprintf(s,\nstrlen(e->cmd_defns[idx].cmd_desc) + 1,\n\"%s\", e->cmd_defns[idx].cmd_desc);\nreturn BIO_snprintf(s, strlen(int_no_description) + 1, \"%s\",\nint_no_description);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -102,79 +106,65 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,-\t\t\t   void (*f)(void))-\t{-\tint idx;-\tchar *s = (char *)p;-\t/* Take care of the easy one first (eg. it requires no searches) */-\tif(cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE)-\t\t{-\t\tif((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))-\t\t\treturn 0;-\t\treturn e->cmd_defns->cmd_num;-\t\t}-\t/* One or two commands require that \"p\" be a valid string buffer */-\tif((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||-\t\t\t(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||-\t\t\t(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD))-\t\t{-\t\tif(s == NULL)-\t\t\t{-\t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,-\t\t\t\tERR_R_PASSED_NULL_PARAMETER);-\t\t\treturn -1;-\t\t\t}-\t\t}-\t/* Now handle cmd_name -> cmd_num conversion */-\tif(cmd == ENGINE_CTRL_GET_CMD_FROM_NAME)-\t\t{-\t\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(-\t\t\t\t\t\te->cmd_defns, s)) < 0))-\t\t\t{-\t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,-\t\t\t\tENGINE_R_INVALID_CMD_NAME);-\t\t\treturn -1;-\t\t\t}-\t\treturn e->cmd_defns[idx].cmd_num;-\t\t}-\t/* For the rest of the commands, the 'long' argument must specify a-\t * valie command number - so we need to conduct a search. */-\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,-\t\t\t\t\t(unsigned int)i)) < 0))-\t\t{-\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,-\t\t\tENGINE_R_INVALID_CMD_NUMBER);-\t\treturn -1;-\t\t}-\t/* Now the logic splits depending on command type */-\tswitch(cmd)-\t\t{-\tcase ENGINE_CTRL_GET_NEXT_CMD_TYPE:-\t\tidx++;-\t\tif(int_ctrl_cmd_is_null(e->cmd_defns + idx))-\t\t\t/* end-of-list */-\t\t\treturn 0;-\t\telse-\t\t\treturn e->cmd_defns[idx].cmd_num;-\tcase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:-\t\treturn strlen(e->cmd_defns[idx].cmd_name);-\tcase ENGINE_CTRL_GET_NAME_FROM_CMD:-\t\treturn BIO_snprintf(s,strlen(e->cmd_defns[idx].cmd_name) + 1,-\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_name);-\tcase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:-\t\tif(e->cmd_defns[idx].cmd_desc)-\t\t\treturn strlen(e->cmd_defns[idx].cmd_desc);-\t\treturn strlen(int_no_description);-\tcase ENGINE_CTRL_GET_DESC_FROM_CMD:-\t\tif(e->cmd_defns[idx].cmd_desc)-\t\t\treturn BIO_snprintf(s,-\t\t\t\t\t    strlen(e->cmd_defns[idx].cmd_desc) + 1,-\t\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_desc);-\t\treturn BIO_snprintf(s, strlen(int_no_description) + 1,\"%s\",-\t\t\t\t    int_no_description);-\tcase ENGINE_CTRL_GET_CMD_FLAGS:-\t\treturn e->cmd_defns[idx].cmd_flags;-\t\t}-\t/* Shouldn't really be here ... */-\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,ENGINE_R_INTERNAL_LIST_ERROR);-\treturn -1;-\t}+                           void (*f) (void))+{+    int idx;+    char *s = (char *)p;+    /* Take care of the easy one first (eg. it requires no searches) */+    if (cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) {+        if ((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))+            return 0;+        return e->cmd_defns->cmd_num;+    }+    /* One or two commands require that \"p\" be a valid string buffer */+    if ((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||+        (cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||+        (cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) {+        if (s == NULL) {+            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ERR_R_PASSED_NULL_PARAMETER);+            return -1;+        }+    }+    /* Now handle cmd_name -> cmd_num conversion */+    if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) {+        if ((e->cmd_defns == NULL)+            || ((idx = int_ctrl_cmd_by_name(e->cmd_defns, s)) < 0)) {+            ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME);+            return -1;+        }+        return e->cmd_defns[idx].cmd_num;+    }+    /*+     * For the rest of the commands, the 'long' argument must specify a valie+     * command number - so we need to conduct a search.+     */+    if ((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,+                                                              (unsigned int)+                                                              i)) < 0)) {+        ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER);+        return -1;+    }+    /* Now the logic splits depending on command type */+    switch (cmd) {+    case ENGINE_CTRL_GET_NEXT_CMD_TYPE:+        idx++;+        if (int_ctrl_cmd_is_null(e->cmd_defns + idx))+            /* end-of-list */+            return 0;+        else+            return e->cmd_defns[idx].cmd_num;+    case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:+        return strlen(e->cmd_defns[idx].cmd_name);+    case ENGINE_CTRL_GET_NAME_FROM_CMD:+        return BIO_snprintf(s, strlen(e->cmd_defns[idx].cmd_name) + 1,+                            \"%s\", e->cmd_defns[idx].cmd_name);+    case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:+        if (e->cmd_defns[idx].cmd_desc)+            return strlen(e->cmd_defns[idx].cmd_desc);+        return strlen(int_no_description);+    case ENGINE_CTRL_GET_DESC_FROM_CMD:+        if (e->cmd_defns[idx].cmd_desc)+            return BIO_snprintf(s,+                                strlen(e->cmd_defns[idx].cmd_desc) + 1,+                                \"%s\", e->cmd_defns[idx].cmd_desc);+        return BIO_snprintf(s, strlen(int_no_description) + 1, \"%s\",+                            int_no_description);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -102,78 +102,79 @@-static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f)())+static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p,+\t\t\t   void (*f)(void)) \t{ \tint idx; \tchar *s = (char *)p; \t/* Take care of the easy one first (eg. it requires no searches) */ \tif(cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) \t\t{ \t\tif((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns)) \t\t\treturn 0; \t\treturn e->cmd_defns->cmd_num; \t\t} \t/* One or two commands require that \"p\" be a valid string buffer */ \tif((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) || \t\t\t(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) || \t\t\t(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) \t\t{ \t\tif(s == NULL) \t\t\t{ \t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\t\treturn -1; \t\t\t} \t\t} \t/* Now handle cmd_name -> cmd_num conversion */ \tif(cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) \t\t{ \t\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name( \t\t\t\t\t\te->cmd_defns, s)) < 0)) \t\t\t{ \t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\t\tENGINE_R_INVALID_CMD_NAME); \t\t\treturn -1; \t\t\t} \t\treturn e->cmd_defns[idx].cmd_num; \t\t} \t/* For the rest of the commands, the 'long' argument must specify a \t * valie command number - so we need to conduct a search. */ \tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns, \t\t\t\t\t(unsigned int)i)) < 0)) \t\t{ \t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\tENGINE_R_INVALID_CMD_NUMBER); \t\treturn -1; \t\t} \t/* Now the logic splits depending on command type */ \tswitch(cmd) \t\t{ \tcase ENGINE_CTRL_GET_NEXT_CMD_TYPE: \t\tidx++; \t\tif(int_ctrl_cmd_is_null(e->cmd_defns + idx)) \t\t\t/* end-of-list */ \t\t\treturn 0; \t\telse \t\t\treturn e->cmd_defns[idx].cmd_num; \tcase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: \t\treturn strlen(e->cmd_defns[idx].cmd_name); \tcase ENGINE_CTRL_GET_NAME_FROM_CMD: \t\treturn BIO_snprintf(s,strlen(e->cmd_defns[idx].cmd_name) + 1, \t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_name); \tcase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: \t\tif(e->cmd_defns[idx].cmd_desc) \t\t\treturn strlen(e->cmd_defns[idx].cmd_desc); \t\treturn strlen(int_no_description); \tcase ENGINE_CTRL_GET_DESC_FROM_CMD: \t\tif(e->cmd_defns[idx].cmd_desc) \t\t\treturn BIO_snprintf(s, \t\t\t\t\t    strlen(e->cmd_defns[idx].cmd_desc) + 1, \t\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_desc); \t\treturn BIO_snprintf(s, strlen(int_no_description) + 1,\"%s\", \t\t\t\t    int_no_description); \tcase ENGINE_CTRL_GET_CMD_FLAGS: \t\treturn e->cmd_defns[idx].cmd_flags; \t\t} \t/* Shouldn't really be here ... */ \tENGINEerr(ENGINE_F_INT_CTRL_HELPER,ENGINE_R_INTERNAL_LIST_ERROR); \treturn -1; \t}",
            "commit_date": "2005-03-31 09:26:39+00:00",
            "commit_hash": "41a15c4f0f2535591ba9f258cf76119f86477c43",
            "message": "Give everything prototypes (well, everything that's actually used)."
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- a/crypto/engine/eng_ctrl.c+++ b/crypto/engine/eng_ctrl.c@@ -105,74 +105,78 @@ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f)()) \t{ \tint idx; \tchar *s = (char *)p; \t/* Take care of the easy one first (eg. it requires no searches) */ \tif(cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE) \t\t{ \t\tif((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns)) \t\t\treturn 0; \t\treturn e->cmd_defns->cmd_num; \t\t} \t/* One or two commands require that \"p\" be a valid string buffer */ \tif((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) || \t\t\t(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) || \t\t\t(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD)) \t\t{ \t\tif(s == NULL) \t\t\t{ \t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\t\tERR_R_PASSED_NULL_PARAMETER); \t\t\treturn -1; \t\t\t} \t\t} \t/* Now handle cmd_name -> cmd_num conversion */ \tif(cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) \t\t{ \t\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name( \t\t\t\t\t\te->cmd_defns, s)) < 0)) \t\t\t{ \t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\t\tENGINE_R_INVALID_CMD_NAME); \t\t\treturn -1; \t\t\t} \t\treturn e->cmd_defns[idx].cmd_num; \t\t} \t/* For the rest of the commands, the 'long' argument must specify a \t * valie command number - so we need to conduct a search. */ \tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns, \t\t\t\t\t(unsigned int)i)) < 0)) \t\t{ \t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER, \t\t\tENGINE_R_INVALID_CMD_NUMBER); \t\treturn -1; \t\t} \t/* Now the logic splits depending on command type */ \tswitch(cmd) \t\t{ \tcase ENGINE_CTRL_GET_NEXT_CMD_TYPE: \t\tidx++; \t\tif(int_ctrl_cmd_is_null(e->cmd_defns + idx)) \t\t\t/* end-of-list */ \t\t\treturn 0; \t\telse \t\t\treturn e->cmd_defns[idx].cmd_num; \tcase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: \t\treturn strlen(e->cmd_defns[idx].cmd_name); \tcase ENGINE_CTRL_GET_NAME_FROM_CMD:-\t\treturn sprintf(s, \"%s\", e->cmd_defns[idx].cmd_name);+\t\treturn BIO_snprintf(s,strlen(e->cmd_defns[idx].cmd_name) + 1,+\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_name); \tcase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: \t\tif(e->cmd_defns[idx].cmd_desc) \t\t\treturn strlen(e->cmd_defns[idx].cmd_desc); \t\treturn strlen(int_no_description); \tcase ENGINE_CTRL_GET_DESC_FROM_CMD: \t\tif(e->cmd_defns[idx].cmd_desc)-\t\t\treturn sprintf(s, \"%s\", e->cmd_defns[idx].cmd_desc);-\t\treturn sprintf(s, \"%s\", int_no_description);+\t\t\treturn BIO_snprintf(s,+\t\t\t\t\t    strlen(e->cmd_defns[idx].cmd_desc) + 1,+\t\t\t\t\t    \"%s\", e->cmd_defns[idx].cmd_desc);+\t\treturn BIO_snprintf(s, strlen(int_no_description) + 1,\"%s\",+\t\t\t\t    int_no_description); \tcase ENGINE_CTRL_GET_CMD_FLAGS: \t\treturn e->cmd_defns[idx].cmd_flags; \t\t} \t/* Shouldn't really be here ... */ \tENGINEerr(ENGINE_F_INT_CTRL_HELPER,ENGINE_R_INTERNAL_LIST_ERROR); \treturn -1; \t}",
            "commit_date": "2003-12-27 14:40:17+00:00",
            "commit_hash": "d420ac2c7d4ba9d99ff2c257a3ad71ecc6d876e2",
            "message": "Use BUF_strlcpy() instead of strcpy().\nUse BUF_strlcat() instead of strcat().\nUse BIO_snprintf() instead of sprintf().\nIn some cases, keep better track of buffer lengths.\nThis is part of a large change submitted by Markus Friedl <markus@openbsd.org>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/engine/eng_ctrl.c b/crypto/engine/eng_ctrl.c--- /dev/null+++ b/crypto/engine/eng_ctrl.c@@ -0,0 +105,74 @@++static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f)())+\t{+\tint idx;+\tchar *s = (char *)p;+\t/* Take care of the easy one first (eg. it requires no searches) */+\tif(cmd == ENGINE_CTRL_GET_FIRST_CMD_TYPE)+\t\t{+\t\tif((e->cmd_defns == NULL) || int_ctrl_cmd_is_null(e->cmd_defns))+\t\t\treturn 0;+\t\treturn e->cmd_defns->cmd_num;+\t\t}+\t/* One or two commands require that \"p\" be a valid string buffer */+\tif((cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) ||+\t\t\t(cmd == ENGINE_CTRL_GET_NAME_FROM_CMD) ||+\t\t\t(cmd == ENGINE_CTRL_GET_DESC_FROM_CMD))+\t\t{+\t\tif(s == NULL)+\t\t\t{+\t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,+\t\t\t\tERR_R_PASSED_NULL_PARAMETER);+\t\t\treturn -1;+\t\t\t}+\t\t}+\t/* Now handle cmd_name -> cmd_num conversion */+\tif(cmd == ENGINE_CTRL_GET_CMD_FROM_NAME)+\t\t{+\t\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(+\t\t\t\t\t\te->cmd_defns, s)) < 0))+\t\t\t{+\t\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,+\t\t\t\tENGINE_R_INVALID_CMD_NAME);+\t\t\treturn -1;+\t\t\t}+\t\treturn e->cmd_defns[idx].cmd_num;+\t\t}+\t/* For the rest of the commands, the 'long' argument must specify a+\t * valie command number - so we need to conduct a search. */+\tif((e->cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e->cmd_defns,+\t\t\t\t\t(unsigned int)i)) < 0))+\t\t{+\t\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,+\t\t\tENGINE_R_INVALID_CMD_NUMBER);+\t\treturn -1;+\t\t}+\t/* Now the logic splits depending on command type */+\tswitch(cmd)+\t\t{+\tcase ENGINE_CTRL_GET_NEXT_CMD_TYPE:+\t\tidx++;+\t\tif(int_ctrl_cmd_is_null(e->cmd_defns + idx))+\t\t\t/* end-of-list */+\t\t\treturn 0;+\t\telse+\t\t\treturn e->cmd_defns[idx].cmd_num;+\tcase ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:+\t\treturn strlen(e->cmd_defns[idx].cmd_name);+\tcase ENGINE_CTRL_GET_NAME_FROM_CMD:+\t\treturn sprintf(s, \"%s\", e->cmd_defns[idx].cmd_name);+\tcase ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:+\t\tif(e->cmd_defns[idx].cmd_desc)+\t\t\treturn strlen(e->cmd_defns[idx].cmd_desc);+\t\treturn strlen(int_no_description);+\tcase ENGINE_CTRL_GET_DESC_FROM_CMD:+\t\tif(e->cmd_defns[idx].cmd_desc)+\t\t\treturn sprintf(s, \"%s\", e->cmd_defns[idx].cmd_desc);+\t\treturn sprintf(s, \"%s\", int_no_description);+\tcase ENGINE_CTRL_GET_CMD_FLAGS:+\t\treturn e->cmd_defns[idx].cmd_flags;+\t\t}+\t/* Shouldn't really be here ... */+\tENGINEerr(ENGINE_F_INT_CTRL_HELPER,ENGINE_R_INTERNAL_LIST_ERROR);+\treturn -1;+\t}",
            "commit_date": "2001-09-25 20:00:51+00:00",
            "commit_hash": "b6d1e52d454bb321153c70cf763945d4b0d4f78e",
            "message": "This change replaces the ENGINE's underlying mechanics with the new\nENGINE_TABLE-based stuff - as described in crypto/engine/README.\nAssociated miscellaneous changes;\n- the previous cipher/digest hooks that hardwired directly to EVP's\nOBJ_NAME-based storage have been backed out. New cipher/digest support\nhas been constructed and will be committed shortly.\n- each implementation defines its own ENGINE_load_<name> function now.\n- the \"openssl\" ENGINE isn't needed or loaded any more.\n- core (not algorithm or class specific) ENGINE code has been split into\nmultiple files to increase readability and decrease linker bloat.\n- ENGINE_cpy() has been removed as it wasn't really a good idea in the\nfirst place and now, because of registration issues, can't be\nmeaningfully defined any more.\n- BN_MOD_EXP[_CRT] support is removed as per the README.\n- a bug in enginetest.c has been fixed.\nNB: This commit almost certainly breaks compilation until subsequent\nchanges are committed."
        }
    ],
    "git log -L6366,6399:ssl/ssl_lib.c": [
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c--- a/ssl/ssl_lib.c+++ b/ssl/ssl_lib.c@@ -5512,33 +6298,34 @@ static int nss_keylog_int(const char *prefix,-                          SSL *ssl,+                          SSL_CONNECTION *sc, {+    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(sc);-    if (ssl->ctx->keylog_callback == NULL)+    if (sctx->keylog_callback == NULL)-        SSLfatal(ssl, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);+        SSLfatal(sc, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);",
            "commit_date": "2022-06-20 17:11:28+02:00",
            "commit_hash": "38b051a1fedc79ebf24a96de2e9a326ad3665baf",
            "message": "SSL object refactoring using SSL_CONNECTION object\nMake the SSL object polymorphic based on whether this is\na traditional SSL connection, QUIC connection, or later\nto be implemented a QUIC stream.\nIt requires adding if after every SSL_CONNECTION_FROM_SSL() call\nwhich itself has to be added to almost every public SSL_ API call.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Hugo Landau <hlandau@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/18612)\nconst uint8_t *parameter_1,\nsize_t parameter_1_len,\nconst uint8_t *parameter_2,\nsize_t parameter_2_len)\nchar *out = NULL;\nchar *cursor = NULL;\nsize_t out_len = 0;\nsize_t i;\nsize_t prefix_len;\nreturn 1;\n/*\n* Our output buffer will contain the following strings, rendered with\n* space characters in between, terminated by a NULL character: first the\n* prefix, then the first parameter, then the second parameter. The\n* meaning of each parameter depends on the specific key material being\n* logged. Note that the first and second parameters are encoded in\n* hexadecimal, so we need a buffer that is twice their lengths.\n*/\nprefix_len = strlen(prefix);\nout_len = prefix_len + (2 * parameter_1_len) + (2 * parameter_2_len) + 3;\nif ((out = cursor = OPENSSL_malloc(out_len)) == NULL) {\nreturn 0;\n}\nstrcpy(cursor, prefix);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c--- a/ssl/ssl_lib.c+++ b/ssl/ssl_lib.c@@ -5441,34 +5436,33 @@ static int nss_keylog_int(const char *prefix, {-        SSLfatal(ssl, SSL_AD_INTERNAL_ERROR, SSL_F_NSS_KEYLOG_INT,-                 ERR_R_MALLOC_FAILURE);+        SSLfatal(ssl, SSL_AD_INTERNAL_ERROR, ERR_R_MALLOC_FAILURE);",
            "commit_date": "2020-11-04 14:39:57+01:00",
            "commit_hash": "c48ffbcca1d0213c6bcbe85de7bb5dd23c76438d",
            "message": "SSL: refactor all SSLfatal() calls\nSince SSLfatal() doesn't take a function code any more, we drop that\nargument everywhere.  Also, we convert all combinations of SSLfatal()\nand ERR_add_data() to an SSLfatal_data() call.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13316)\nSSL *ssl,\nconst uint8_t *parameter_1,\nsize_t parameter_1_len,\nconst uint8_t *parameter_2,\nsize_t parameter_2_len)\nchar *out = NULL;\nchar *cursor = NULL;\nsize_t out_len = 0;\nsize_t i;\nsize_t prefix_len;\nif (ssl->ctx->keylog_callback == NULL)\nreturn 1;\n/*\n* Our output buffer will contain the following strings, rendered with\n* space characters in between, terminated by a NULL character: first the\n* prefix, then the first parameter, then the second parameter. The\n* meaning of each parameter depends on the specific key material being\n* logged. Note that the first and second parameters are encoded in\n* hexadecimal, so we need a buffer that is twice their lengths.\n*/\nprefix_len = strlen(prefix);\nout_len = prefix_len + (2 * parameter_1_len) + (2 * parameter_2_len) + 3;\nif ((out = cursor = OPENSSL_malloc(out_len)) == NULL) {\nreturn 0;\n}\nstrcpy(cursor, prefix);"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c--- a/ssl/ssl_lib.c+++ b/ssl/ssl_lib.c@@ -5093,33 +5093,34 @@ static int nss_keylog_int(const char *prefix, {-    if (ssl->ctx->keylog_callback == NULL) return 1;+    if (ssl->ctx->keylog_callback == NULL)+        return 1;",
            "commit_date": "2018-11-06 07:06:25+10:00",
            "commit_hash": "2087028612027368e9508e1b253aab715a5a35d6",
            "message": "Fix return formatting.\nReviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>\n(Merged from https://github.com/openssl/openssl/pull/7564)\nSSL *ssl,\nconst uint8_t *parameter_1,\nsize_t parameter_1_len,\nconst uint8_t *parameter_2,\nsize_t parameter_2_len)\nchar *out = NULL;\nchar *cursor = NULL;\nsize_t out_len = 0;\nsize_t i;\nsize_t prefix_len;\n/*\n* Our output buffer will contain the following strings, rendered with\n* space characters in between, terminated by a NULL character: first the\n* prefix, then the first parameter, then the second parameter. The\n* meaning of each parameter depends on the specific key material being\n* logged. Note that the first and second parameters are encoded in\n* hexadecimal, so we need a buffer that is twice their lengths.\n*/\nprefix_len = strlen(prefix);\nout_len = prefix_len + (2 * parameter_1_len) + (2 * parameter_2_len) + 3;\nif ((out = cursor = OPENSSL_malloc(out_len)) == NULL) {\nSSLfatal(ssl, SSL_AD_INTERNAL_ERROR, SSL_F_NSS_KEYLOG_INT,\nERR_R_MALLOC_FAILURE);\nreturn 0;\n}\nstrcpy(cursor, prefix);"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c--- a/ssl/ssl_lib.c+++ b/ssl/ssl_lib.c@@ -5093,33 +5093,33 @@ static int nss_keylog_int(const char *prefix, {-    out_len = prefix_len + (2*parameter_1_len) + (2*parameter_2_len) + 3;+    out_len = prefix_len + (2 * parameter_1_len) + (2 * parameter_2_len) + 3;",
            "commit_date": "2018-11-05 11:04:23+10:00",
            "commit_hash": "e931f370aa38d8645b35fb8d6260cb44d37b6b61",
            "message": "Cleanse the key log buffer.\nReviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>\n(Merged from https://github.com/openssl/openssl/pull/7564)\nSSL *ssl,\nconst uint8_t *parameter_1,\nsize_t parameter_1_len,\nconst uint8_t *parameter_2,\nsize_t parameter_2_len)\nchar *out = NULL;\nchar *cursor = NULL;\nsize_t out_len = 0;\nsize_t i;\nsize_t prefix_len;\nif (ssl->ctx->keylog_callback == NULL) return 1;\n/*\n* Our output buffer will contain the following strings, rendered with\n* space characters in between, terminated by a NULL character: first the\n* prefix, then the first parameter, then the second parameter. The\n* meaning of each parameter depends on the specific key material being\n* logged. Note that the first and second parameters are encoded in\n* hexadecimal, so we need a buffer that is twice their lengths.\n*/\nprefix_len = strlen(prefix);\nif ((out = cursor = OPENSSL_malloc(out_len)) == NULL) {\nSSLfatal(ssl, SSL_AD_INTERNAL_ERROR, SSL_F_NSS_KEYLOG_INT,\nERR_R_MALLOC_FAILURE);\nreturn 0;\n}\nstrcpy(cursor, prefix);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c--- a/ssl/ssl_lib.c+++ b/ssl/ssl_lib.c@@ -4875,32 +4886,33 @@ static int nss_keylog_int(const char *prefix, {-        SSLerr(SSL_F_NSS_KEYLOG_INT, ERR_R_MALLOC_FAILURE);+        SSLfatal(ssl, SSL_AD_INTERNAL_ERROR, SSL_F_NSS_KEYLOG_INT,+                 ERR_R_MALLOC_FAILURE);",
            "commit_date": "2017-11-21 17:18:43+00:00",
            "commit_hash": "f63a17d66dec01c123630682e0b20450b34c086a",
            "message": "Convert the state machine code to use SSLfatal()\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4778)\nSSL *ssl,\nconst uint8_t *parameter_1,\nsize_t parameter_1_len,\nconst uint8_t *parameter_2,\nsize_t parameter_2_len)\nchar *out = NULL;\nchar *cursor = NULL;\nsize_t out_len = 0;\nsize_t i;\nsize_t prefix_len;\nif (ssl->ctx->keylog_callback == NULL) return 1;\n/*\n* Our output buffer will contain the following strings, rendered with\n* space characters in between, terminated by a NULL character: first the\n* prefix, then the first parameter, then the second parameter. The\n* meaning of each parameter depends on the specific key material being\n* logged. Note that the first and second parameters are encoded in\n* hexadecimal, so we need a buffer that is twice their lengths.\n*/\nprefix_len = strlen(prefix);\nout_len = prefix_len + (2*parameter_1_len) + (2*parameter_2_len) + 3;\nif ((out = cursor = OPENSSL_malloc(out_len)) == NULL) {\nreturn 0;\n}\nstrcpy(cursor, prefix);"
        },
        {
            "author": {
                "email": "lukasaoz@gmail.com",
                "name": "Cory Benfield"
            },
            "changes": "diff --git a/ssl/ssl_lib.c b/ssl/ssl_lib.c--- a/ssl/ssl_lib.c+++ b/ssl/ssl_lib.c@@ -4347,0 +4357,32 @@++static int nss_keylog_int(const char *prefix,+                          SSL *ssl,+                          const uint8_t *parameter_1,+                          size_t parameter_1_len,+                          const uint8_t *parameter_2,+                          size_t parameter_2_len)+{+    char *out = NULL;+    char *cursor = NULL;+    size_t out_len = 0;+    size_t i;+    size_t prefix_len;++    if (ssl->ctx->keylog_callback == NULL) return 1;++    /*+     * Our output buffer will contain the following strings, rendered with+     * space characters in between, terminated by a NULL character: first the+     * prefix, then the first parameter, then the second parameter. The+     * meaning of each parameter depends on the specific key material being+     * logged. Note that the first and second parameters are encoded in+     * hexadecimal, so we need a buffer that is twice their lengths.+     */+    prefix_len = strlen(prefix);+    out_len = prefix_len + (2*parameter_1_len) + (2*parameter_2_len) + 3;+    if ((out = cursor = OPENSSL_malloc(out_len)) == NULL) {+        SSLerr(SSL_F_NSS_KEYLOG_INT, ERR_R_MALLOC_FAILURE);+        return 0;+    }++    strcpy(cursor, prefix);",
            "commit_date": "2017-01-20 16:22:30+00:00",
            "commit_hash": "2faa1b48fd6864f6bb8f992fd638378202fdd416",
            "message": "Add support for key logging callbacks.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1646)"
        }
    ],
    "git log -L60,82:fuzz/test-corpus.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/fuzz/test-corpus.c b/fuzz/test-corpus.c--- a/fuzz/test-corpus.c+++ b/fuzz/test-corpus.c@@ -43,1 +60,23 @@-        fclose(f);++int main(int argc, char **argv) {+    int n;++    FuzzerInitialize(&argc, &argv);++    for (n = 1; n < argc; ++n) {+        size_t dirname_len = strlen(argv[n]);+        const char *filename = NULL;+        char *pathname = NULL;+        OPENSSL_DIR_CTX *ctx = NULL;+        int wasdir = 0;++        /*+         * We start with trying to read the given path as a directory.+         */+        while ((filename = OPENSSL_DIR_read(&ctx, argv[n])) != NULL) {+            wasdir = 1;+            if (pathname == NULL) {+                pathname = malloc(PATH_MAX);+                if (pathname == NULL)+                    break;+                strcpy(pathname, argv[n]);",
            "commit_date": "2018-03-28 15:46:28+02:00",
            "commit_hash": "9d740909595546ebd34a845e6328cb60afa388b8",
            "message": "Faster fuzz test: teach the fuzz test programs to handle directories\nInstead of invoking the fuzz test programs once for every corpora\nfile, we invoke them once for each directory of corpora files.  This\ndramatically reduces the number of program invikations, as well as the\ntime 99-test_fuzz.t takes to complete.\nfuzz/test-corpus.c was enhanced to handle directories as well as\nregular files.\nReviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5776)"
        },
        {
            "author": {
                "email": "ben@links.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/fuzz/test-corpus.c b/fuzz/test-corpus.c--- /dev/null+++ b/fuzz/test-corpus.c@@ -0,0 +41,1 @@+        fclose(f);",
            "commit_date": "2016-06-04 16:10:49+01:00",
            "commit_hash": "90d28f0519427ffc293f880c423d9c4395a6fcd4",
            "message": "Run the fuzzing corpora as tests.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>"
        }
    ],
    "git log -L60,89:fuzz/test-corpus.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/fuzz/test-corpus.c b/fuzz/test-corpus.c--- a/fuzz/test-corpus.c+++ b/fuzz/test-corpus.c@@ -43,1 +60,30 @@-        fclose(f);++int main(int argc, char **argv) {+    int n;++    FuzzerInitialize(&argc, &argv);++    for (n = 1; n < argc; ++n) {+        size_t dirname_len = strlen(argv[n]);+        const char *filename = NULL;+        char *pathname = NULL;+        OPENSSL_DIR_CTX *ctx = NULL;+        int wasdir = 0;++        /*+         * We start with trying to read the given path as a directory.+         */+        while ((filename = OPENSSL_DIR_read(&ctx, argv[n])) != NULL) {+            wasdir = 1;+            if (pathname == NULL) {+                pathname = malloc(PATH_MAX);+                if (pathname == NULL)+                    break;+                strcpy(pathname, argv[n]);+#ifdef __VMS+                if (strchr(\":<]\", pathname[dirname_len - 1]) == NULL)+#endif+                    pathname[dirname_len++] = '/';+                pathname[dirname_len] = '\\0';+            }+            strcpy(pathname + dirname_len, filename);",
            "commit_date": "2018-03-28 15:46:28+02:00",
            "commit_hash": "9d740909595546ebd34a845e6328cb60afa388b8",
            "message": "Faster fuzz test: teach the fuzz test programs to handle directories\nInstead of invoking the fuzz test programs once for every corpora\nfile, we invoke them once for each directory of corpora files.  This\ndramatically reduces the number of program invikations, as well as the\ntime 99-test_fuzz.t takes to complete.\nfuzz/test-corpus.c was enhanced to handle directories as well as\nregular files.\nReviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5776)"
        },
        {
            "author": {
                "email": "ben@links.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/fuzz/test-corpus.c b/fuzz/test-corpus.c--- /dev/null+++ b/fuzz/test-corpus.c@@ -0,0 +41,1 @@+        fclose(f);",
            "commit_date": "2016-06-04 16:10:49+01:00",
            "commit_hash": "90d28f0519427ffc293f880c423d9c4395a6fcd4",
            "message": "Run the fuzzing corpora as tests.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>"
        }
    ],
    "git log -L20,41:crypto/idea/i_skey.c": [
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -61,22 +61,22 @@ static IDEA_INT inverse(unsigned int xin);-void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks)+void IDEA_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks) {",
            "commit_date": "2016-04-18 07:43:54-04:00",
            "commit_hash": "9021a5dfb37fd3a6f7726f07ef0f27dcb71048e2",
            "message": "Rename some lowercase API's\nMake OBJ_name_cmp internal\nRename idea_xxx to IDEA_xxx\nRename get_rfc_xxx to BN_get_rfc_xxx\nRename v3_addr and v3_asid functions to X509v3_...\nReviewed-by: Richard Levitte <levitte@openssl.org>\nint i;\nregister IDEA_INT *kt, *kf, r0, r1, r2;\nkt = &(ks->data[0][0]);\nn2s(key, kt[0]);\nn2s(key, kt[1]);\nn2s(key, kt[2]);\nn2s(key, kt[3]);\nn2s(key, kt[4]);\nn2s(key, kt[5]);\nn2s(key, kt[6]);\nn2s(key, kt[7]);\nkf = kt;\nkt += 8;\nfor (i = 0; i < 6; i++) {\nr2 = kf[1];\nr1 = kf[2];\n*(kt++) = ((r2 << 9) | (r1 >> 7)) & 0xffff;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -62,34 +62,22 @@ static IDEA_INT inverse(unsigned int xin); void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks)-\t{-\tint i;-\tregister IDEA_INT *kt,*kf,r0,r1,r2;+{+    int i;+    register IDEA_INT *kt, *kf, r0, r1, r2;-\tkt= &(ks->data[0][0]);-\tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]);-\tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]);+    kt = &(ks->data[0][0]);+    n2s(key, kt[0]);+    n2s(key, kt[1]);+    n2s(key, kt[2]);+    n2s(key, kt[3]);+    n2s(key, kt[4]);+    n2s(key, kt[5]);+    n2s(key, kt[6]);+    n2s(key, kt[7]);-\tkf=kt;-\tkt+=8;-\tfor (i=0; i<6; i++)-\t\t{-\t\tr2= kf[1];-\t\tr1= kf[2];-\t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff;-\t\tr0= kf[3];-\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;-\t\tr1= kf[4];-\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;-\t\tr0= kf[5];-\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;-\t\tr1= kf[6];-\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;-\t\tr0= kf[7];-\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;-\t\tr1= kf[0];-\t\tif (i >= 5) break;-\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;-\t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff;-\t\tkf+=8;-\t\t}-\t}+    kf = kt;+    kt += 8;+    for (i = 0; i < 6; i++) {+        r2 = kf[1];+        r1 = kf[2];+        *(kt++) = ((r2 << 9) | (r1 >> 7)) & 0xffff;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -62,34 +62,34 @@ static IDEA_INT inverse(unsigned int xin);-void idea_set_encrypt_key(unsigned char *key, IDEA_KEY_SCHEDULE *ks)+void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks) \t{ \tint i; \tregister IDEA_INT *kt,*kf,r0,r1,r2; \tkt= &(ks->data[0][0]); \tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]); \tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]); \tkf=kt; \tkt+=8; \tfor (i=0; i<6; i++) \t\t{ \t\tr2= kf[1]; \t\tr1= kf[2]; \t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff; \t\tr0= kf[3]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[4]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[5]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[6]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[7]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[0]; \t\tif (i >= 5) break; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff; \t\tkf+=8; \t\t} \t}",
            "commit_date": "2000-06-03 14:13:58+00:00",
            "commit_hash": "1921eaad645c9a9f62c1ed79b7ae87c417aa8a3c",
            "message": "EVP constification."
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -63,38 +62,34 @@ static IDEA_INT inverse(unsigned int xin);-#else-static IDEA_INT inverse();-#endif- void idea_set_encrypt_key(unsigned char *key, IDEA_KEY_SCHEDULE *ks) \t{ \tint i; \tregister IDEA_INT *kt,*kf,r0,r1,r2; \tkt= &(ks->data[0][0]); \tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]); \tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]); \tkf=kt; \tkt+=8; \tfor (i=0; i<6; i++) \t\t{ \t\tr2= kf[1]; \t\tr1= kf[2]; \t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff; \t\tr0= kf[3]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[4]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[5]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[6]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[7]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[0]; \t\tif (i >= 5) break; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff; \t\tkf+=8; \t\t} \t}",
            "commit_date": "1999-04-26 16:43:10+00:00",
            "commit_hash": "a9be3af5ad4836f7e50f0546311ca90c717b861e",
            "message": "Remove NOPROTO definitions and error code comments."
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -63,40 +63,38 @@ static IDEA_INT inverse(unsigned int xin); #else static IDEA_INT inverse(); #endif-void idea_set_encrypt_key(key, ks)-unsigned char *key;-IDEA_KEY_SCHEDULE *ks;+void idea_set_encrypt_key(unsigned char *key, IDEA_KEY_SCHEDULE *ks) \t{ \tint i; \tregister IDEA_INT *kt,*kf,r0,r1,r2; \tkt= &(ks->data[0][0]); \tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]); \tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]); \tkf=kt; \tkt+=8; \tfor (i=0; i<6; i++) \t\t{ \t\tr2= kf[1]; \t\tr1= kf[2]; \t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff; \t\tr0= kf[3]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[4]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[5]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[6]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[7]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[0]; \t\tif (i >= 5) break; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff; \t\tkf+=8; \t\t} \t}",
            "commit_date": "1999-04-19 21:31:43+00:00",
            "commit_hash": "6b691a5c85ddc4e407e32781841fee5c029506cd",
            "message": "Change functions to ANSI C."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- /dev/null+++ b/crypto/idea/i_skey.c@@ -0,0 +63,40 @@+static IDEA_INT inverse(unsigned int xin);+#else+static IDEA_INT inverse();+#endif++void idea_set_encrypt_key(key, ks)+unsigned char *key;+IDEA_KEY_SCHEDULE *ks;+\t{+\tint i;+\tregister IDEA_INT *kt,*kf,r0,r1,r2;++\tkt= &(ks->data[0][0]);+\tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]);+\tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]);++\tkf=kt;+\tkt+=8;+\tfor (i=0; i<6; i++)+\t\t{+\t\tr2= kf[1];+\t\tr1= kf[2];+\t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff;+\t\tr0= kf[3];+\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;+\t\tr1= kf[4];+\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;+\t\tr0= kf[5];+\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;+\t\tr1= kf[6];+\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;+\t\tr0= kf[7];+\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;+\t\tr1= kf[0];+\t\tif (i >= 5) break;+\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;+\t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff;+\t\tkf+=8;+\t\t}+\t}",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L537,616:crypto/aria/aria.c": [
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/crypto/aria/aria.c b/crypto/aria/aria.c--- a/crypto/aria/aria.c+++ b/crypto/aria/aria.c@@ -537,80 +537,80 @@-int aria_set_encrypt_key(const unsigned char *userKey, const int bits,-                         ARIA_KEY *key)+int ossl_aria_set_encrypt_key(const unsigned char *userKey, const int bits,+                              ARIA_KEY *key) {",
            "commit_date": "2021-03-09 11:47:48+10:00",
            "commit_hash": "78f32a316589c93bfbb06cb58d996a39c3f43678",
            "message": "Add ossl_aria symbols\nPartial fix for #12964\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14473)\nregister uint32_t reg0, reg1, reg2, reg3;\nuint32_t w0[4], w1[4], w2[4], w3[4];\nconst uint32_t *ck;\nARIA_u128 *rk;\nint Nr = (bits + 256) / 32;\nif (userKey == NULL || key == NULL) {\nreturn -1;\n}\nif (bits != 128 && bits != 192 && bits != 256) {\nreturn -2;\n}\nrk = key->rd_key;\nkey->rounds = Nr;\nck = &Key_RC[(bits - 128) / 64][0];\nw0[0] = GET_U32_BE(userKey, 0);\nw0[1] = GET_U32_BE(userKey, 1);\nw0[2] = GET_U32_BE(userKey, 2);\nw0[3] = GET_U32_BE(userKey, 3);\nreg0 = w0[0] ^ ck[0];\nreg1 = w0[1] ^ ck[1];\nreg2 = w0[2] ^ ck[2];\nreg3 = w0[3] ^ ck[3];\nARIA_SUBST_DIFF_ODD(reg0, reg1, reg2, reg3);\nif (bits > 128) {\nw1[0] = GET_U32_BE(userKey, 4);\nw1[1] = GET_U32_BE(userKey, 5);\nif (bits > 192) {\nw1[2] = GET_U32_BE(userKey, 6);\nw1[3] = GET_U32_BE(userKey, 7);\n}\nelse {\nw1[2] = w1[3] = 0;\n}\n}\nelse {\nw1[0] = w1[1] = w1[2] = w1[3] = 0;\n}\nw1[0] ^= reg0;\nw1[1] ^= reg1;\nw1[2] ^= reg2;\nw1[3] ^= reg3;\nreg0 = w1[0];\nreg1 = w1[1];\nreg2 = w1[2];\nreg3 = w1[3];\nreg0 ^= ck[4];\nreg1 ^= ck[5];\nreg2 ^= ck[6];\nreg3 ^= ck[7];\nARIA_SUBST_DIFF_EVEN(reg0, reg1, reg2, reg3);\nreg0 ^= w0[0];\nreg1 ^= w0[1];\nreg2 ^= w0[2];\nreg3 ^= w0[3];\nw2[0] = reg0;\nw2[1] = reg1;\nw2[2] = reg2;\nw2[3] = reg3;\nreg0 ^= ck[8];\nreg1 ^= ck[9];\nreg2 ^= ck[10];\nreg3 ^= ck[11];"
        },
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/crypto/aria/aria.c b/crypto/aria/aria.c--- a/crypto/aria/aria.c+++ b/crypto/aria/aria.c@@ -537,79 +537,80 @@ int aria_set_encrypt_key(const unsigned char *userKey, const int bits, {-    ARIA_u128 *rk = key->rd_key;+    ARIA_u128 *rk;+    rk = key->rd_key;",
            "commit_date": "2017-08-30 14:04:08+10:00",
            "commit_hash": "1c2ac294721b636665aa7d62f5e3f843d3b1ac71",
            "message": "Fix potential null pointer dereference in ARIA implementation\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4286)\nARIA_KEY *key)\nregister uint32_t reg0, reg1, reg2, reg3;\nuint32_t w0[4], w1[4], w2[4], w3[4];\nconst uint32_t *ck;\nint Nr = (bits + 256) / 32;\nif (userKey == NULL || key == NULL) {\nreturn -1;\n}\nif (bits != 128 && bits != 192 && bits != 256) {\nreturn -2;\n}\nkey->rounds = Nr;\nck = &Key_RC[(bits - 128) / 64][0];\nw0[0] = GET_U32_BE(userKey, 0);\nw0[1] = GET_U32_BE(userKey, 1);\nw0[2] = GET_U32_BE(userKey, 2);\nw0[3] = GET_U32_BE(userKey, 3);\nreg0 = w0[0] ^ ck[0];\nreg1 = w0[1] ^ ck[1];\nreg2 = w0[2] ^ ck[2];\nreg3 = w0[3] ^ ck[3];\nARIA_SUBST_DIFF_ODD(reg0, reg1, reg2, reg3);\nif (bits > 128) {\nw1[0] = GET_U32_BE(userKey, 4);\nw1[1] = GET_U32_BE(userKey, 5);\nif (bits > 192) {\nw1[2] = GET_U32_BE(userKey, 6);\nw1[3] = GET_U32_BE(userKey, 7);\n}\nelse {\nw1[2] = w1[3] = 0;\n}\n}\nelse {\nw1[0] = w1[1] = w1[2] = w1[3] = 0;\n}\nw1[0] ^= reg0;\nw1[1] ^= reg1;\nw1[2] ^= reg2;\nw1[3] ^= reg3;\nreg0 = w1[0];\nreg1 = w1[1];\nreg2 = w1[2];\nreg3 = w1[3];\nreg0 ^= ck[4];\nreg1 ^= ck[5];\nreg2 ^= ck[6];\nreg3 ^= ck[7];\nARIA_SUBST_DIFF_EVEN(reg0, reg1, reg2, reg3);\nreg0 ^= w0[0];\nreg1 ^= w0[1];\nreg2 ^= w0[2];\nreg3 ^= w0[3];\nw2[0] = reg0;\nw2[1] = reg1;\nw2[2] = reg2;\nw2[3] = reg3;\nreg0 ^= ck[8];\nreg1 ^= ck[9];\nreg2 ^= ck[10];\nreg3 ^= ck[11];"
        },
        {
            "author": {
                "email": "letrhee@nsr.re.kr",
                "name": "letrhee-nsr"
            },
            "changes": "diff --git a/crypto/aria/aria.c b/crypto/aria/aria.c--- a/crypto/aria/aria.c+++ b/crypto/aria/aria.c@@ -19,0 +540,79 @@++int aria_set_encrypt_key(const unsigned char *userKey, const int bits,+                         ARIA_KEY *key)+{+    register uint32_t reg0, reg1, reg2, reg3;+    uint32_t w0[4], w1[4], w2[4], w3[4];+    const uint32_t *ck;++    ARIA_u128 *rk = key->rd_key;+    int Nr = (bits + 256) / 32;++    if (userKey == NULL || key == NULL) {+        return -1;+    }+    if (bits != 128 && bits != 192 && bits != 256) {+        return -2;+    }++    key->rounds = Nr;+    ck = &Key_RC[(bits - 128) / 64][0];++    w0[0] = GET_U32_BE(userKey, 0);+    w0[1] = GET_U32_BE(userKey, 1);+    w0[2] = GET_U32_BE(userKey, 2);+    w0[3] = GET_U32_BE(userKey, 3);++    reg0 = w0[0] ^ ck[0];+    reg1 = w0[1] ^ ck[1];+    reg2 = w0[2] ^ ck[2];+    reg3 = w0[3] ^ ck[3];++    ARIA_SUBST_DIFF_ODD(reg0, reg1, reg2, reg3);++    if (bits > 128) {+        w1[0] = GET_U32_BE(userKey, 4);+        w1[1] = GET_U32_BE(userKey, 5);+        if (bits > 192) {+            w1[2] = GET_U32_BE(userKey, 6);+            w1[3] = GET_U32_BE(userKey, 7);+        }+        else {+            w1[2] = w1[3] = 0;+        }+    }+    else {+        w1[0] = w1[1] = w1[2] = w1[3] = 0;+    }++    w1[0] ^= reg0;+    w1[1] ^= reg1;+    w1[2] ^= reg2;+    w1[3] ^= reg3;++    reg0 = w1[0];+    reg1 = w1[1];+    reg2 = w1[2];+    reg3 = w1[3];++    reg0 ^= ck[4];+    reg1 ^= ck[5];+    reg2 ^= ck[6];+    reg3 ^= ck[7];++    ARIA_SUBST_DIFF_EVEN(reg0, reg1, reg2, reg3);++    reg0 ^= w0[0];+    reg1 ^= w0[1];+    reg2 ^= w0[2];+    reg3 ^= w0[3];++    w2[0] = reg0;+    w2[1] = reg1;+    w2[2] = reg2;+    w2[3] = reg3;++    reg0 ^= ck[8];+    reg1 ^= ck[9];+    reg2 ^= ck[10];+    reg3 ^= ck[11];",
            "commit_date": "2017-04-18 19:39:46+09:00",
            "commit_hash": "dc99b885ded3cbc586d5ffec779f0e75a269bda3",
            "message": "Add ARIA 32-bit implementation\nModified code from http://seed.kisa.or.kr to human readable code.\nPrevious 8-bit code is available with -DOPENSSL_SMALL_FOOTPRINT.\nNew code is >2x faster.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3242)"
        }
    ],
    "git log -L37,56:test/aesgcmtest.c": [
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/aesgcmtest.c b/test/aesgcmtest.c--- /dev/null+++ b/test/aesgcmtest.c@@ -0,0 +37,20 @@++static int do_encrypt(unsigned char *iv_gen, unsigned char *ct, int *ct_len,+                      unsigned char *tag, int *tag_len)+{+    int ret = 0;+    EVP_CIPHER_CTX *ctx = NULL;+    int outlen;+    unsigned char outbuf[64];++    *tag_len = 16;+    ret = TEST_ptr(ctx = EVP_CIPHER_CTX_new())+          && TEST_true(EVP_EncryptInit_ex(ctx, EVP_aes_256_gcm(), NULL, NULL,+                                          NULL) > 0)+          && TEST_true(EVP_EncryptInit_ex(ctx, NULL, NULL, gcm_key,+                                          iv_gen != NULL ? NULL : gcm_iv) > 0)+          && TEST_true(EVP_EncryptUpdate(ctx, NULL, &outlen, gcm_aad,+                                         sizeof(gcm_aad)) > 0)+          && TEST_true(EVP_EncryptUpdate(ctx, ct, ct_len, gcm_pt,+                                         sizeof(gcm_pt)) > 0)+          && TEST_true(EVP_EncryptFinal_ex(ctx, outbuf, &outlen) > 0)",
            "commit_date": "2019-02-21 08:27:25+10:00",
            "commit_hash": "bcf082d130a413a728a382bd6e6bfdbf2cedba45",
            "message": "FIPS AES_GCM IV gen changes\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8393)"
        }
    ],
    "git log -L60,76:crypto/idea/i_skey.c": [
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -101,17 +101,17 @@-void idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk)+void IDEA_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk) {",
            "commit_date": "2016-04-18 07:43:54-04:00",
            "commit_hash": "9021a5dfb37fd3a6f7726f07ef0f27dcb71048e2",
            "message": "Rename some lowercase API's\nMake OBJ_name_cmp internal\nRename idea_xxx to IDEA_xxx\nRename get_rfc_xxx to BN_get_rfc_xxx\nRename v3_addr and v3_asid functions to X509v3_...\nReviewed-by: Richard Levitte <levitte@openssl.org>\nint r;\nregister IDEA_INT *fp, *tp, t;\ntp = &(dk->data[0][0]);\nfp = &(ek->data[8][0]);\nfor (r = 0; r < 9; r++) {\n*(tp++) = inverse(fp[0]);\n*(tp++) = ((int)(0x10000L - fp[2]) & 0xffff);\n*(tp++) = ((int)(0x10000L - fp[1]) & 0xffff);\n*(tp++) = inverse(fp[3]);\nif (r == 8)\nbreak;\nfp -= 6;\n*(tp++) = fp[4];"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -96,19 +102,17 @@ void idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk)-\t{-\tint r;-\tregister IDEA_INT *fp,*tp,t;+{+    int r;+    register IDEA_INT *fp, *tp, t;-\ttp= &(dk->data[0][0]);-\tfp= &(ek->data[8][0]);-\tfor (r=0; r<9; r++)-\t\t{-\t\t*(tp++)=inverse(fp[0]);-\t\t*(tp++)=((int)(0x10000L-fp[2])&0xffff);-\t\t*(tp++)=((int)(0x10000L-fp[1])&0xffff);-\t\t*(tp++)=inverse(fp[3]);-\t\tif (r == 8) break;-\t\tfp-=6;-\t\t*(tp++)=fp[4];-\t\t*(tp++)=fp[5];-\t\t}+    tp = &(dk->data[0][0]);+    fp = &(ek->data[8][0]);+    for (r = 0; r < 9; r++) {+        *(tp++) = inverse(fp[0]);+        *(tp++) = ((int)(0x10000L - fp[2]) & 0xffff);+        *(tp++) = ((int)(0x10000L - fp[1]) & 0xffff);+        *(tp++) = inverse(fp[3]);+        if (r == 8)+            break;+        fp -= 6;+        *(tp++) = fp[4];",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -103,21 +101,19 @@-void idea_set_decrypt_key(ek, dk)-IDEA_KEY_SCHEDULE *ek;-IDEA_KEY_SCHEDULE *dk;+void idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk) \t{ \tint r; \tregister IDEA_INT *fp,*tp,t; \ttp= &(dk->data[0][0]); \tfp= &(ek->data[8][0]); \tfor (r=0; r<9; r++) \t\t{ \t\t*(tp++)=inverse(fp[0]); \t\t*(tp++)=((int)(0x10000L-fp[2])&0xffff); \t\t*(tp++)=((int)(0x10000L-fp[1])&0xffff); \t\t*(tp++)=inverse(fp[3]); \t\tif (r == 8) break; \t\tfp-=6; \t\t*(tp++)=fp[4]; \t\t*(tp++)=fp[5]; \t\t}",
            "commit_date": "1999-04-19 21:31:43+00:00",
            "commit_hash": "6b691a5c85ddc4e407e32781841fee5c029506cd",
            "message": "Change functions to ANSI C."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- /dev/null+++ b/crypto/idea/i_skey.c@@ -0,0 +103,21 @@++void idea_set_decrypt_key(ek, dk)+IDEA_KEY_SCHEDULE *ek;+IDEA_KEY_SCHEDULE *dk;+\t{+\tint r;+\tregister IDEA_INT *fp,*tp,t;++\ttp= &(dk->data[0][0]);+\tfp= &(ek->data[8][0]);+\tfor (r=0; r<9; r++)+\t\t{+\t\t*(tp++)=inverse(fp[0]);+\t\t*(tp++)=((int)(0x10000L-fp[2])&0xffff);+\t\t*(tp++)=((int)(0x10000L-fp[1])&0xffff);+\t\t*(tp++)=inverse(fp[3]);+\t\tif (r == 8) break;+\t\tfp-=6;+\t\t*(tp++)=fp[4];+\t\t*(tp++)=fp[5];+\t\t}",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L537,599:crypto/aria/aria.c": [
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/crypto/aria/aria.c b/crypto/aria/aria.c--- a/crypto/aria/aria.c+++ b/crypto/aria/aria.c@@ -537,63 +537,63 @@-int aria_set_encrypt_key(const unsigned char *userKey, const int bits,-                         ARIA_KEY *key)+int ossl_aria_set_encrypt_key(const unsigned char *userKey, const int bits,+                              ARIA_KEY *key) {",
            "commit_date": "2021-03-09 11:47:48+10:00",
            "commit_hash": "78f32a316589c93bfbb06cb58d996a39c3f43678",
            "message": "Add ossl_aria symbols\nPartial fix for #12964\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14473)\nregister uint32_t reg0, reg1, reg2, reg3;\nuint32_t w0[4], w1[4], w2[4], w3[4];\nconst uint32_t *ck;\nARIA_u128 *rk;\nint Nr = (bits + 256) / 32;\nif (userKey == NULL || key == NULL) {\nreturn -1;\n}\nif (bits != 128 && bits != 192 && bits != 256) {\nreturn -2;\n}\nrk = key->rd_key;\nkey->rounds = Nr;\nck = &Key_RC[(bits - 128) / 64][0];\nw0[0] = GET_U32_BE(userKey, 0);\nw0[1] = GET_U32_BE(userKey, 1);\nw0[2] = GET_U32_BE(userKey, 2);\nw0[3] = GET_U32_BE(userKey, 3);\nreg0 = w0[0] ^ ck[0];\nreg1 = w0[1] ^ ck[1];\nreg2 = w0[2] ^ ck[2];\nreg3 = w0[3] ^ ck[3];\nARIA_SUBST_DIFF_ODD(reg0, reg1, reg2, reg3);\nif (bits > 128) {\nw1[0] = GET_U32_BE(userKey, 4);\nw1[1] = GET_U32_BE(userKey, 5);\nif (bits > 192) {\nw1[2] = GET_U32_BE(userKey, 6);\nw1[3] = GET_U32_BE(userKey, 7);\n}\nelse {\nw1[2] = w1[3] = 0;\n}\n}\nelse {\nw1[0] = w1[1] = w1[2] = w1[3] = 0;\n}\nw1[0] ^= reg0;\nw1[1] ^= reg1;\nw1[2] ^= reg2;\nw1[3] ^= reg3;\nreg0 = w1[0];\nreg1 = w1[1];\nreg2 = w1[2];\nreg3 = w1[3];\nreg0 ^= ck[4];\nreg1 ^= ck[5];\nreg2 ^= ck[6];\nreg3 ^= ck[7];"
        },
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/crypto/aria/aria.c b/crypto/aria/aria.c--- a/crypto/aria/aria.c+++ b/crypto/aria/aria.c@@ -537,62 +537,63 @@ int aria_set_encrypt_key(const unsigned char *userKey, const int bits, {-    ARIA_u128 *rk = key->rd_key;+    ARIA_u128 *rk;+    rk = key->rd_key;",
            "commit_date": "2017-08-30 14:04:08+10:00",
            "commit_hash": "1c2ac294721b636665aa7d62f5e3f843d3b1ac71",
            "message": "Fix potential null pointer dereference in ARIA implementation\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4286)\nARIA_KEY *key)\nregister uint32_t reg0, reg1, reg2, reg3;\nuint32_t w0[4], w1[4], w2[4], w3[4];\nconst uint32_t *ck;\nint Nr = (bits + 256) / 32;\nif (userKey == NULL || key == NULL) {\nreturn -1;\n}\nif (bits != 128 && bits != 192 && bits != 256) {\nreturn -2;\n}\nkey->rounds = Nr;\nck = &Key_RC[(bits - 128) / 64][0];\nw0[0] = GET_U32_BE(userKey, 0);\nw0[1] = GET_U32_BE(userKey, 1);\nw0[2] = GET_U32_BE(userKey, 2);\nw0[3] = GET_U32_BE(userKey, 3);\nreg0 = w0[0] ^ ck[0];\nreg1 = w0[1] ^ ck[1];\nreg2 = w0[2] ^ ck[2];\nreg3 = w0[3] ^ ck[3];\nARIA_SUBST_DIFF_ODD(reg0, reg1, reg2, reg3);\nif (bits > 128) {\nw1[0] = GET_U32_BE(userKey, 4);\nw1[1] = GET_U32_BE(userKey, 5);\nif (bits > 192) {\nw1[2] = GET_U32_BE(userKey, 6);\nw1[3] = GET_U32_BE(userKey, 7);\n}\nelse {\nw1[2] = w1[3] = 0;\n}\n}\nelse {\nw1[0] = w1[1] = w1[2] = w1[3] = 0;\n}\nw1[0] ^= reg0;\nw1[1] ^= reg1;\nw1[2] ^= reg2;\nw1[3] ^= reg3;\nreg0 = w1[0];\nreg1 = w1[1];\nreg2 = w1[2];\nreg3 = w1[3];\nreg0 ^= ck[4];\nreg1 ^= ck[5];\nreg2 ^= ck[6];\nreg3 ^= ck[7];"
        },
        {
            "author": {
                "email": "letrhee@nsr.re.kr",
                "name": "letrhee-nsr"
            },
            "changes": "diff --git a/crypto/aria/aria.c b/crypto/aria/aria.c--- a/crypto/aria/aria.c+++ b/crypto/aria/aria.c@@ -19,0 +540,62 @@++int aria_set_encrypt_key(const unsigned char *userKey, const int bits,+                         ARIA_KEY *key)+{+    register uint32_t reg0, reg1, reg2, reg3;+    uint32_t w0[4], w1[4], w2[4], w3[4];+    const uint32_t *ck;++    ARIA_u128 *rk = key->rd_key;+    int Nr = (bits + 256) / 32;++    if (userKey == NULL || key == NULL) {+        return -1;+    }+    if (bits != 128 && bits != 192 && bits != 256) {+        return -2;+    }++    key->rounds = Nr;+    ck = &Key_RC[(bits - 128) / 64][0];++    w0[0] = GET_U32_BE(userKey, 0);+    w0[1] = GET_U32_BE(userKey, 1);+    w0[2] = GET_U32_BE(userKey, 2);+    w0[3] = GET_U32_BE(userKey, 3);++    reg0 = w0[0] ^ ck[0];+    reg1 = w0[1] ^ ck[1];+    reg2 = w0[2] ^ ck[2];+    reg3 = w0[3] ^ ck[3];++    ARIA_SUBST_DIFF_ODD(reg0, reg1, reg2, reg3);++    if (bits > 128) {+        w1[0] = GET_U32_BE(userKey, 4);+        w1[1] = GET_U32_BE(userKey, 5);+        if (bits > 192) {+            w1[2] = GET_U32_BE(userKey, 6);+            w1[3] = GET_U32_BE(userKey, 7);+        }+        else {+            w1[2] = w1[3] = 0;+        }+    }+    else {+        w1[0] = w1[1] = w1[2] = w1[3] = 0;+    }++    w1[0] ^= reg0;+    w1[1] ^= reg1;+    w1[2] ^= reg2;+    w1[3] ^= reg3;++    reg0 = w1[0];+    reg1 = w1[1];+    reg2 = w1[2];+    reg3 = w1[3];++    reg0 ^= ck[4];+    reg1 ^= ck[5];+    reg2 ^= ck[6];+    reg3 ^= ck[7];",
            "commit_date": "2017-04-18 19:39:46+09:00",
            "commit_hash": "dc99b885ded3cbc586d5ffec779f0e75a269bda3",
            "message": "Add ARIA 32-bit implementation\nModified code from http://seed.kisa.or.kr to human readable code.\nPrevious 8-bit code is available with -DOPENSSL_SMALL_FOOTPRINT.\nNew code is >2x faster.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3242)"
        }
    ],
    "git log -L20,50:crypto/idea/i_skey.c": [
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -61,31 +61,31 @@ static IDEA_INT inverse(unsigned int xin);-void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks)+void IDEA_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks) {",
            "commit_date": "2016-04-18 07:43:54-04:00",
            "commit_hash": "9021a5dfb37fd3a6f7726f07ef0f27dcb71048e2",
            "message": "Rename some lowercase API's\nMake OBJ_name_cmp internal\nRename idea_xxx to IDEA_xxx\nRename get_rfc_xxx to BN_get_rfc_xxx\nRename v3_addr and v3_asid functions to X509v3_...\nReviewed-by: Richard Levitte <levitte@openssl.org>\nint i;\nregister IDEA_INT *kt, *kf, r0, r1, r2;\nkt = &(ks->data[0][0]);\nn2s(key, kt[0]);\nn2s(key, kt[1]);\nn2s(key, kt[2]);\nn2s(key, kt[3]);\nn2s(key, kt[4]);\nn2s(key, kt[5]);\nn2s(key, kt[6]);\nn2s(key, kt[7]);\nkf = kt;\nkt += 8;\nfor (i = 0; i < 6; i++) {\nr2 = kf[1];\nr1 = kf[2];\n*(kt++) = ((r2 << 9) | (r1 >> 7)) & 0xffff;\nr0 = kf[3];\n*(kt++) = ((r1 << 9) | (r0 >> 7)) & 0xffff;\nr1 = kf[4];\n*(kt++) = ((r0 << 9) | (r1 >> 7)) & 0xffff;\nr0 = kf[5];\n*(kt++) = ((r1 << 9) | (r0 >> 7)) & 0xffff;\nr1 = kf[6];\n*(kt++) = ((r0 << 9) | (r1 >> 7)) & 0xffff;\nr0 = kf[7];"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -62,34 +62,31 @@ static IDEA_INT inverse(unsigned int xin); void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks)-\t{-\tint i;-\tregister IDEA_INT *kt,*kf,r0,r1,r2;+{+    int i;+    register IDEA_INT *kt, *kf, r0, r1, r2;-\tkt= &(ks->data[0][0]);-\tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]);-\tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]);+    kt = &(ks->data[0][0]);+    n2s(key, kt[0]);+    n2s(key, kt[1]);+    n2s(key, kt[2]);+    n2s(key, kt[3]);+    n2s(key, kt[4]);+    n2s(key, kt[5]);+    n2s(key, kt[6]);+    n2s(key, kt[7]);-\tkf=kt;-\tkt+=8;-\tfor (i=0; i<6; i++)-\t\t{-\t\tr2= kf[1];-\t\tr1= kf[2];-\t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff;-\t\tr0= kf[3];-\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;-\t\tr1= kf[4];-\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;-\t\tr0= kf[5];-\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;-\t\tr1= kf[6];-\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;-\t\tr0= kf[7];-\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;-\t\tr1= kf[0];-\t\tif (i >= 5) break;-\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;-\t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff;-\t\tkf+=8;-\t\t}-\t}+    kf = kt;+    kt += 8;+    for (i = 0; i < 6; i++) {+        r2 = kf[1];+        r1 = kf[2];+        *(kt++) = ((r2 << 9) | (r1 >> 7)) & 0xffff;+        r0 = kf[3];+        *(kt++) = ((r1 << 9) | (r0 >> 7)) & 0xffff;+        r1 = kf[4];+        *(kt++) = ((r0 << 9) | (r1 >> 7)) & 0xffff;+        r0 = kf[5];+        *(kt++) = ((r1 << 9) | (r0 >> 7)) & 0xffff;+        r1 = kf[6];+        *(kt++) = ((r0 << 9) | (r1 >> 7)) & 0xffff;+        r0 = kf[7];",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -62,34 +62,34 @@ static IDEA_INT inverse(unsigned int xin);-void idea_set_encrypt_key(unsigned char *key, IDEA_KEY_SCHEDULE *ks)+void idea_set_encrypt_key(const unsigned char *key, IDEA_KEY_SCHEDULE *ks) \t{ \tint i; \tregister IDEA_INT *kt,*kf,r0,r1,r2; \tkt= &(ks->data[0][0]); \tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]); \tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]); \tkf=kt; \tkt+=8; \tfor (i=0; i<6; i++) \t\t{ \t\tr2= kf[1]; \t\tr1= kf[2]; \t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff; \t\tr0= kf[3]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[4]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[5]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[6]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[7]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[0]; \t\tif (i >= 5) break; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff; \t\tkf+=8; \t\t} \t}",
            "commit_date": "2000-06-03 14:13:58+00:00",
            "commit_hash": "1921eaad645c9a9f62c1ed79b7ae87c417aa8a3c",
            "message": "EVP constification."
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -63,38 +62,34 @@ static IDEA_INT inverse(unsigned int xin);-#else-static IDEA_INT inverse();-#endif- void idea_set_encrypt_key(unsigned char *key, IDEA_KEY_SCHEDULE *ks) \t{ \tint i; \tregister IDEA_INT *kt,*kf,r0,r1,r2; \tkt= &(ks->data[0][0]); \tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]); \tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]); \tkf=kt; \tkt+=8; \tfor (i=0; i<6; i++) \t\t{ \t\tr2= kf[1]; \t\tr1= kf[2]; \t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff; \t\tr0= kf[3]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[4]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[5]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[6]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[7]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[0]; \t\tif (i >= 5) break; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff; \t\tkf+=8; \t\t} \t}",
            "commit_date": "1999-04-26 16:43:10+00:00",
            "commit_hash": "a9be3af5ad4836f7e50f0546311ca90c717b861e",
            "message": "Remove NOPROTO definitions and error code comments."
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -63,40 +63,38 @@ static IDEA_INT inverse(unsigned int xin); #else static IDEA_INT inverse(); #endif-void idea_set_encrypt_key(key, ks)-unsigned char *key;-IDEA_KEY_SCHEDULE *ks;+void idea_set_encrypt_key(unsigned char *key, IDEA_KEY_SCHEDULE *ks) \t{ \tint i; \tregister IDEA_INT *kt,*kf,r0,r1,r2; \tkt= &(ks->data[0][0]); \tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]); \tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]); \tkf=kt; \tkt+=8; \tfor (i=0; i<6; i++) \t\t{ \t\tr2= kf[1]; \t\tr1= kf[2]; \t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff; \t\tr0= kf[3]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[4]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[5]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[6]; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\tr0= kf[7]; \t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff; \t\tr1= kf[0]; \t\tif (i >= 5) break; \t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff; \t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff; \t\tkf+=8; \t\t} \t}",
            "commit_date": "1999-04-19 21:31:43+00:00",
            "commit_hash": "6b691a5c85ddc4e407e32781841fee5c029506cd",
            "message": "Change functions to ANSI C."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- /dev/null+++ b/crypto/idea/i_skey.c@@ -0,0 +63,40 @@+static IDEA_INT inverse(unsigned int xin);+#else+static IDEA_INT inverse();+#endif++void idea_set_encrypt_key(key, ks)+unsigned char *key;+IDEA_KEY_SCHEDULE *ks;+\t{+\tint i;+\tregister IDEA_INT *kt,*kf,r0,r1,r2;++\tkt= &(ks->data[0][0]);+\tn2s(key,kt[0]); n2s(key,kt[1]); n2s(key,kt[2]); n2s(key,kt[3]);+\tn2s(key,kt[4]); n2s(key,kt[5]); n2s(key,kt[6]); n2s(key,kt[7]);++\tkf=kt;+\tkt+=8;+\tfor (i=0; i<6; i++)+\t\t{+\t\tr2= kf[1];+\t\tr1= kf[2];+\t\t*(kt++)= ((r2<<9) | (r1>>7))&0xffff;+\t\tr0= kf[3];+\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;+\t\tr1= kf[4];+\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;+\t\tr0= kf[5];+\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;+\t\tr1= kf[6];+\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;+\t\tr0= kf[7];+\t\t*(kt++)= ((r1<<9) | (r0>>7))&0xffff;+\t\tr1= kf[0];+\t\tif (i >= 5) break;+\t\t*(kt++)= ((r0<<9) | (r1>>7))&0xffff;+\t\t*(kt++)= ((r1<<9) | (r2>>7))&0xffff;+\t\tkf+=8;+\t\t}+\t}",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L58,113:test/clienthellotest.c": [
        {
            "author": {
                "email": "xkernel.wang@foxmail.com",
                "name": "x2018"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -58,56 +58,56 @@ static int test_client_hello(int currtest) { #ifdef OPENSSL_NO_TLS1_3 #endif-    switch(currtest) {+    switch (currtest) { #if !defined(OPENSSL_NO_TLS1_3) && defined(OPENSSL_NO_TLS1_2) #else #endif",
            "commit_date": "2021-10-26 15:16:18+08:00",
            "commit_hash": "1287dabd0b23326be491125698dd982e4ae28887",
            "message": "fix some code with obvious wrong coding style\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16918)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt, pkt2, pkt3;\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\nmemset(&pkt, 0, sizeof(pkt));\nmemset(&pkt2, 0, sizeof(pkt2));\nmemset(&pkt3, 0, sizeof(pkt3));\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, 0)))\ngoto end;\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* TLSv1.3 is enabled and TLSv1.2 is disabled so can't do this test */\nSSL_CTX_free(ctx);\nreturn 1;\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:\n/*\n* In this case we're doing TLSv1.3 and we're sending a PSK so the\n* ClientHello is already going to be quite long. To avoid getting one\n* that is too long for this test we use a restricted ciphersuite list\n*/\nif (!TEST_false(SSL_CTX_set_cipher_list(ctx, \"\")))"
        },
        {
            "author": {
                "email": "rashok.svks@gmail.com",
                "name": "raja-ashok"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -52,55 +52,56 @@ static int test_client_hello(int currtest) { #ifdef OPENSSL_NO_TLS1_3 #endif #if !defined(OPENSSL_NO_TLS1_3) && defined(OPENSSL_NO_TLS1_2)+        SSL_CTX_free(ctx); #else #endif",
            "commit_date": "2019-05-31 08:50:54+05:30",
            "commit_hash": "5bf2eade559a0d3081013048b1373da460701ba5",
            "message": "Test SSL_set_ciphersuites\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9079)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt, pkt2, pkt3;\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\nmemset(&pkt, 0, sizeof(pkt));\nmemset(&pkt2, 0, sizeof(pkt2));\nmemset(&pkt3, 0, sizeof(pkt3));\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, 0)))\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* TLSv1.3 is enabled and TLSv1.2 is disabled so can't do this test */\nreturn 1;\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:\n/*\n* In this case we're doing TLSv1.3 and we're sending a PSK so the\n* ClientHello is already going to be quite long. To avoid getting one\n* that is too long for this test we use a restricted ciphersuite list\n*/\nif (!TEST_false(SSL_CTX_set_cipher_list(ctx, \"\")))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -52,51 +52,55 @@ static int test_client_hello(int currtest) {-    PACKET pkt = {0}, pkt2 = {0}, pkt3 = {0};+    PACKET pkt, pkt2, pkt3; #ifdef OPENSSL_NO_TLS1_3 #endif+    memset(&pkt, 0, sizeof(pkt));+    memset(&pkt2, 0, sizeof(pkt2));+    memset(&pkt3, 0, sizeof(pkt3));+ #if !defined(OPENSSL_NO_TLS1_3) && defined(OPENSSL_NO_TLS1_2) #else #endif",
            "commit_date": "2019-03-29 18:42:37+10:00",
            "commit_hash": "72962d025f875ac35114ac090b878ee18b246144",
            "message": "Correctly initialise PACKET to zero in the tests to avoid possible problems\nwith padding bytes.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/8611)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, 0)))\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* TLSv1.3 is enabled and TLSv1.2 is disabled so can't do this test */\nreturn 1;\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:\n/*\n* In this case we're doing TLSv1.3 and we're sending a PSK so the\n* ClientHello is already going to be quite long. To avoid getting one\n* that is too long for this test we use a restricted ciphersuite list\n*/\nif (!TEST_false(SSL_CTX_set_cipher_list(ctx, \"\")))"
        },
        {
            "author": {
                "email": "rsam@ca.ibm.com",
                "name": "Sam Roberts"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -52,51 +52,51 @@ static int test_client_hello(int currtest) { #ifdef OPENSSL_NO_TLS1_3 #endif #if !defined(OPENSSL_NO_TLS1_3) && defined(OPENSSL_NO_TLS1_2) #else #endif-        if (!TEST_true(SSL_CTX_set_cipher_list(ctx, \"\")))+        if (!TEST_false(SSL_CTX_set_cipher_list(ctx, \"\")))",
            "commit_date": "2018-11-26 13:58:52-08:00",
            "commit_hash": "3c83c5ba4f6502c708b7a5f55c98a10e312668da",
            "message": "Ignore cipher suites when setting cipher list\nset_cipher_list() sets TLSv1.2 (and below) ciphers, and its success or\nfailure should not depend on whether set_ciphersuites() has been used to\nsetup TLSv1.3 ciphers.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Ben Kaduk <kaduk@mit.edu>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/7759)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt = {0}, pkt2 = {0}, pkt3 = {0};\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, 0)))\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* TLSv1.3 is enabled and TLSv1.2 is disabled so can't do this test */\nreturn 1;\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:\n/*\n* In this case we're doing TLSv1.3 and we're sending a PSK so the\n* ClientHello is already going to be quite long. To avoid getting one\n* that is too long for this test we use a restricted ciphersuite list\n*/"
        },
        {
            "author": {
                "email": "kurt@roeckx.be",
                "name": "Kurt Roeckx"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -52,51 +52,51 @@ static int test_client_hello(int currtest) { #ifdef OPENSSL_NO_TLS1_3 #endif-    if (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS_MAX_VERSION)))+    if (!TEST_true(SSL_CTX_set_max_proto_version(ctx, 0))) #if !defined(OPENSSL_NO_TLS1_3) && defined(OPENSSL_NO_TLS1_2) #else #endif",
            "commit_date": "2018-12-09 20:53:05+01:00",
            "commit_hash": "5c587fb6b996d47771bcaecd71489e4849103f56",
            "message": "Use (D)TLS_MAX_VERSION_INTERNAL internally\nUse 0 if we don't want to set a minimum or maximum version\nReviewed-by: Matt Caswell <matt@openssl.org>\nGH: #7260\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt = {0}, pkt2 = {0}, pkt3 = {0};\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* TLSv1.3 is enabled and TLSv1.2 is disabled so can't do this test */\nreturn 1;\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:\n/*\n* In this case we're doing TLSv1.3 and we're sending a PSK so the\n* ClientHello is already going to be quite long. To avoid getting one\n* that is too long for this test we use a restricted ciphersuite list\n*/\nif (!TEST_true(SSL_CTX_set_cipher_list(ctx, \"\")))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -52,49 +52,51 @@ static int test_client_hello(int currtest) { #ifdef OPENSSL_NO_TLS1_3 #endif+    if (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS_MAX_VERSION)))+        goto end; #if !defined(OPENSSL_NO_TLS1_3) && defined(OPENSSL_NO_TLS1_2) #else #endif",
            "commit_date": "2018-03-19 09:08:06+01:00",
            "commit_hash": "7d7f6834e542e53f604b46a72d57fad773d4b2bc",
            "message": "Enhance ssltestlib's create_ssl_ctx_pair to take min and max proto version\nHave all test programs using that function specify those versions.\nAdditionally, have the remaining test programs that use SSL_CTX_new\ndirectly specify at least the maximum protocol version.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5663)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt = {0}, pkt2 = {0}, pkt3 = {0};\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* TLSv1.3 is enabled and TLSv1.2 is disabled so can't do this test */\nreturn 1;\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:\n/*\n* In this case we're doing TLSv1.3 and we're sending a PSK so the\n* ClientHello is already going to be quite long. To avoid getting one\n* that is too long for this test we use a restricted ciphersuite list\n*/\nif (!TEST_true(SSL_CTX_set_cipher_list(ctx, \"\")))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -52,50 +52,49 @@ static int test_client_hello(int currtest) { #ifdef OPENSSL_NO_TLS1_3 #endif #if !defined(OPENSSL_NO_TLS1_3) && defined(OPENSSL_NO_TLS1_2) #else #endif-        if (!TEST_true(SSL_CTX_set_cipher_list(ctx,-                                               \"TLS13-AES-128-GCM-SHA256\")))+        if (!TEST_true(SSL_CTX_set_cipher_list(ctx, \"\")))",
            "commit_date": "2018-02-16 11:26:02+00:00",
            "commit_hash": "f865b08143b453962ad4afccd69e698d13c60f77",
            "message": "Split configuration of TLSv1.3 ciphers from older ciphers\nWith the current mechanism, old cipher strings that used to work in 1.1.0,\nmay inadvertently disable all TLSv1.3 ciphersuites causing connections to\nfail. This is confusing for users.\nIn reality TLSv1.3 are quite different to older ciphers. They are much\nsimpler and there are only a small number of them so, arguably, they don't\nneed the same level of control that the older ciphers have.\nThis change splits the configuration of TLSv1.3 ciphers from older ones.\nBy default the TLSv1.3 ciphers are on, so you cannot inadvertently disable\nthem through your existing config.\nFixes #5359\nReviewed-by: Tim Hudson <tjh@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5392)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt = {0}, pkt2 = {0}, pkt3 = {0};\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* TLSv1.3 is enabled and TLSv1.2 is disabled so can't do this test */\nreturn 1;\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:\n/*\n* In this case we're doing TLSv1.3 and we're sending a PSK so the\n* ClientHello is already going to be quite long. To avoid getting one\n* that is too long for this test we use a restricted ciphersuite list\n*/"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -52,45 +52,50 @@ static int test_client_hello(int currtest) { #ifdef OPENSSL_NO_TLS1_3 #endif+#if !defined(OPENSSL_NO_TLS1_3) && defined(OPENSSL_NO_TLS1_2)+        /* TLSv1.3 is enabled and TLSv1.2 is disabled so can't do this test */+        return 1;+#else+#endif",
            "commit_date": "2018-02-09 10:19:14+00:00",
            "commit_hash": "c423ecaa7f6d0cc77c4f121c6de7d585439bca8f",
            "message": "Fixes for no-tls1_2 and no-tls1_2-method\nThe no-tls1_2 option does not work properly in conjunction with TLSv1.3\nbeing enabled (which is now the default). This commit fixes the issues.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5301)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt = {0}, pkt2 = {0}, pkt3 = {0};\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:\n/*\n* In this case we're doing TLSv1.3 and we're sending a PSK so the\n* ClientHello is already going to be quite long. To avoid getting one\n* that is too long for this test we use a restricted ciphersuite list\n*/\nif (!TEST_true(SSL_CTX_set_cipher_list(ctx,\n\"TLS13-AES-128-GCM-SHA256\")))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -52,38 +52,45 @@ static int test_client_hello(int currtest) { #ifdef OPENSSL_NO_TLS1_3 #endif+        /*+         * In this case we're doing TLSv1.3 and we're sending a PSK so the+         * ClientHello is already going to be quite long. To avoid getting one+         * that is too long for this test we use a restricted ciphersuite list+         */+        if (!TEST_true(SSL_CTX_set_cipher_list(ctx,+                                               \"TLS13-AES-128-GCM-SHA256\")))",
            "commit_date": "2018-02-07 10:55:02+00:00",
            "commit_hash": "0f41dc0e9e9e6a8c2a43fa6af5fdf5359283e2ba",
            "message": "Fix clienthellotest with TLSv1.3\nIf TLSv1.3 is enabled and combined with other options that extend the\nsize of the ClientHello, then the clienthello test can sometimes fail\nbecause the ClientHello has grown too large. Part of the purpose of the\ntest is to check that the padding extension works properly. This requires\nthe ClientHello size to be kept within certain bounds.\nBy restricting the number of ciphersuites sent we can reduce the size of\nthe ClientHello.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5266)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt = {0}, pkt2 = {0}, pkt3 = {0};\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:"
        },
        {
            "author": {
                "email": "bernd.edlinger@hotmail.de",
                "name": "Bernd Edlinger"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -51,38 +51,38 @@ static int test_client_hello(int currtest) {-    PACKET pkt, pkt2, pkt3;+    PACKET pkt = {0}, pkt2 = {0}, pkt3 = {0}; #ifdef OPENSSL_NO_TLS1_3 #endif",
            "commit_date": "2017-04-27 01:00:08+02:00",
            "commit_hash": "8f3f9623a46fb4e294a7e4c3db3168002e3f781b",
            "message": "Fix a pedantic gcc-7 warning.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3328)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nchar *dummytick = \"Hello World!\";\nunsigned int type = 0;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (!TEST_ptr(ctx))\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -52,38 +52,38 @@ static int test_client_hello(int currtest) {-    unsigned int type;+    unsigned int type = 0; #ifdef OPENSSL_NO_TLS1_3 #endif-    if (ctx == NULL)+    if (!TEST_ptr(ctx))-        if (!SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION))+        if (!TEST_true(SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION)))",
            "commit_date": "2017-04-11 17:36:01+01:00",
            "commit_hash": "a105d5603bcb93597866ab20a0ef2acaf6e7b3f6",
            "message": "Convert clienthellotest for the new test framework\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3186)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt, pkt2, pkt3;\nchar *dummytick = \"Hello World!\";\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\nif (currtest == TEST_ADD_PADDING_AND_PSK)\nreturn 1;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -48,33 +52,38 @@ static int test_client_hello(int currtest) {+#ifdef OPENSSL_NO_TLS1_3+    if (currtest == TEST_ADD_PADDING_AND_PSK)+        return 1;+#endif+",
            "commit_date": "2017-03-16 15:09:59+00:00",
            "commit_hash": "6828358c6565af0e31ac1a9ff9c54c94a04bec75",
            "message": "Handle TLSv1.3 being disabled in clienthello test\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2968)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt, pkt2, pkt3;\nchar *dummytick = \"Hello World!\";\nunsigned int type;\nint testresult = 0;\nsize_t msglen;\nBIO *sessbio = NULL;\nSSL_SESSION *sess = NULL;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nctx = SSL_CTX_new(TLS_method());\nif (ctx == NULL)\ngoto end;\nswitch(currtest) {\ncase TEST_SET_SESSION_TICK_DATA_VER_NEG:\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (!SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION))\ngoto end;\nbreak;\ncase TEST_ADD_PADDING_AND_PSK:"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -31,35 +48,33 @@-int main(int argc, char *argv[])+static int test_client_hello(int currtest) {-    BIO *err;-    int currtest = 0;--    err = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);--    CRYPTO_set_mem_debug(1);-    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);+    size_t msglen;+    BIO *sessbio = NULL;+    SSL_SESSION *sess = NULL;-    for (; currtest < TOTAL_NUM_TESTS; currtest++) {-        testresult = 0;-        ctx = SSL_CTX_new(TLS_method());+    ctx = SSL_CTX_new(TLS_method());+    if (ctx == NULL)+        goto end;+    switch(currtest) {+    case TEST_SET_SESSION_TICK_DATA_VER_NEG:-        if (ctx == NULL || !SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION))+        if (!SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION))--        con = SSL_new(ctx);-        if (con == NULL)+        break;++    case TEST_ADD_PADDING_AND_PSK:",
            "commit_date": "2017-03-16 12:11:23+00:00",
            "commit_hash": "6bc6ca623b1785653ae2e0332957f0355f496509",
            "message": "Add tests for the padding extension\nCheck that the padding extension pads correctly for various scenarios.\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2968)\nSSL_CTX *ctx;\nSSL *con = NULL;\nBIO *rbio;\nBIO *wbio;\nlong len;\nunsigned char *data;\nPACKET pkt, pkt2, pkt3;\nchar *dummytick = \"Hello World!\";\nunsigned int type;\nint testresult = 0;\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\ngoto end;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -31,35 +31,35 @@ int main(int argc, char *argv[]) {-    SSL *con;+    SSL *con = NULL;",
            "commit_date": "2016-11-24 09:19:04+00:00",
            "commit_hash": "f231b4e7a651713c2a792c71b30aa0398d14b9f1",
            "message": "Fix a warning about an uninit var\nReviewed-by: Richard Levitte <levitte@openssl.org>\nSSL_CTX *ctx;\nBIO *rbio;\nBIO *wbio;\nBIO *err;\nlong len;\nunsigned char *data;\nPACKET pkt, pkt2, pkt3;\nchar *dummytick = \"Hello World!\";\nunsigned int type;\nint testresult = 0;\nint currtest = 0;\nerr = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);\nCRYPTO_set_mem_debug(1);\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nfor (; currtest < TOTAL_NUM_TESTS; currtest++) {\ntestresult = 0;\nctx = SSL_CTX_new(TLS_method());\n/* Testing for session tickets <= TLS1.2; not relevant for 1.3 */\nif (ctx == NULL || !SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION))\ngoto end;\ncon = SSL_new(ctx);\nif (con == NULL)"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -31,38 +31,35 @@ int main(int argc, char *argv[]) {-        /*-         * This test is testing session tickets for <= TLS1.2. It isn't relevant-         * for TLS1.3-         */+        /* Testing for session tickets <= TLS1.2; not relevant for 1.3 */",
            "commit_date": "2016-11-23 15:38:32+00:00",
            "commit_hash": "6530c4909ffbf4fd655416cbd765b1e7174b9b83",
            "message": "Fix some style issues with TLSv1.3 state machine PR\nReviewed-by: Rich Salz <rsalz@openssl.org>\nSSL_CTX *ctx;\nSSL *con;\nBIO *rbio;\nBIO *wbio;\nBIO *err;\nlong len;\nunsigned char *data;\nPACKET pkt, pkt2, pkt3;\nchar *dummytick = \"Hello World!\";\nunsigned int type;\nint testresult = 0;\nint currtest = 0;\nerr = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);\nCRYPTO_set_mem_debug(1);\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nfor (; currtest < TOTAL_NUM_TESTS; currtest++) {\ntestresult = 0;\nctx = SSL_CTX_new(TLS_method());\nif (ctx == NULL || !SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION))\ngoto end;\ncon = SSL_new(ctx);\nif (con == NULL)"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -31,29 +31,38 @@ int main(int argc, char *argv[]) {++        /*+         * This test is testing session tickets for <= TLS1.2. It isn't relevant+         * for TLS1.3+         */+        if (ctx == NULL || !SSL_CTX_set_max_proto_version(ctx, TLS1_2_VERSION))+            goto end;++        if (con == NULL)",
            "commit_date": "2016-11-08 16:10:21+00:00",
            "commit_hash": "9362c93ebc5b14bf18e82cdebf380ccc52f3d92f",
            "message": "Remove old style NewSessionTicket from TLSv1.3\nTLSv1.3 has a NewSessionTicket message, but it is *completely* different to\nthe TLSv1.2 one and may as well have been called something else. This commit\nremoves the old style NewSessionTicket from TLSv1.3. We will have to add the\nnew style one back in later.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nSSL_CTX *ctx;\nSSL *con;\nBIO *rbio;\nBIO *wbio;\nBIO *err;\nlong len;\nunsigned char *data;\nPACKET pkt, pkt2, pkt3;\nchar *dummytick = \"Hello World!\";\nunsigned int type;\nint testresult = 0;\nint currtest = 0;\nerr = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);\nCRYPTO_set_mem_debug(1);\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nfor (; currtest < TOTAL_NUM_TESTS; currtest++) {\ntestresult = 0;\nctx = SSL_CTX_new(TLS_method());\ncon = SSL_new(ctx);"
        },
        {
            "author": {
                "email": "David.Woodhouse@intel.com",
                "name": "David Woodhouse"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -36,31 +31,29 @@ int main(int argc, char *argv[]) {-    unsigned char *dataend;+    PACKET pkt, pkt2, pkt3;-    unsigned int tmplen;-    unsigned int size;",
            "commit_date": "2016-08-05 14:58:32+01:00",
            "commit_hash": "c14e790d6c46907ad0974f0ba7f640aafb2bdedf",
            "message": "Fix clienthellotest to use PACKET functions\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nSSL_CTX *ctx;\nSSL *con;\nBIO *rbio;\nBIO *wbio;\nBIO *err;\nlong len;\nunsigned char *data;\nchar *dummytick = \"Hello World!\";\nunsigned int type;\nint testresult = 0;\nint currtest = 0;\nerr = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);\nCRYPTO_set_mem_debug(1);\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nfor (; currtest < TOTAL_NUM_TESTS; currtest++) {\ntestresult = 0;\nctx = SSL_CTX_new(TLS_method());\ncon = SSL_new(ctx);"
        },
        {
            "author": {
                "email": "kurt@roeckx.be",
                "name": "Kurt Roeckx"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -88,40 +82,31 @@ int main(int argc, char *argv[]) {-        if (currtest == TEST_SET_SESSION_TICK_DATA_TLS_1_2) {-#ifndef OPENSSL_NO_TLS1_2_METHOD-            ctx = SSL_CTX_new(TLSv1_2_method());-#else-            testresult = 1;-            continue;-#endif-        } else {-            ctx = SSL_CTX_new(TLS_method());-        }+        ctx = SSL_CTX_new(TLS_method());",
            "commit_date": "2016-03-02 22:38:08+01:00",
            "commit_hash": "885e601d97ff235615809db832874ff8dad9cb24",
            "message": "Use version flexible method instead of fixed version\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\nMR: #1824\nSSL_CTX *ctx;\nSSL *con;\nBIO *rbio;\nBIO *wbio;\nBIO *err;\nlong len;\nunsigned char *data;\nunsigned char *dataend;\nchar *dummytick = \"Hello World!\";\nunsigned int tmplen;\nunsigned int type;\nunsigned int size;\nint testresult = 0;\nint currtest = 0;\nerr = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);\nCRYPTO_set_mem_debug(1);\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nfor (; currtest < TOTAL_NUM_TESTS; currtest++) {\ntestresult = 0;\ncon = SSL_new(ctx);"
        },
        {
            "author": {
                "email": "kurt@roeckx.be",
                "name": "Kurt Roeckx"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -88,39 +88,40 @@ int main(int argc, char *argv[]) {-#ifndef OPENSSL_NO_TLS1_2+#ifndef OPENSSL_NO_TLS1_2_METHOD #else+            testresult = 1; #endif",
            "commit_date": "2016-02-02 23:16:20+01:00",
            "commit_hash": "1fc7d6664a3d118f9d5de217c9ffd154ed9ddb6f",
            "message": "Fix usage of OPENSSL_NO_*_METHOD\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\nMR: #1824\nSSL_CTX *ctx;\nSSL *con;\nBIO *rbio;\nBIO *wbio;\nBIO *err;\nlong len;\nunsigned char *data;\nunsigned char *dataend;\nchar *dummytick = \"Hello World!\";\nunsigned int tmplen;\nunsigned int type;\nunsigned int size;\nint testresult = 0;\nint currtest = 0;\nerr = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);\nCRYPTO_set_mem_debug(1);\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nfor (; currtest < TOTAL_NUM_TESTS; currtest++) {\ntestresult = 0;\nif (currtest == TEST_SET_SESSION_TICK_DATA_TLS_1_2) {\nctx = SSL_CTX_new(TLSv1_2_method());\ncontinue;\n} else {\nctx = SSL_CTX_new(TLS_method());\n}\ncon = SSL_new(ctx);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -88,42 +88,39 @@ int main(int argc, char *argv[]) {-    SSL_library_init();-    SSL_load_error_strings();- #ifndef OPENSSL_NO_TLS1_2 #else #endif",
            "commit_date": "2016-02-08 16:45:35+00:00",
            "commit_hash": "8793f012f11416abd300aa524057c863e8c16dd5",
            "message": "Clean up the tests for auto-init/de-init\nRemove the need to explicitly initialise/deinitialise for the tests\nReviewed-by: Richard Levitte <levitte@openssl.org>\nSSL_CTX *ctx;\nSSL *con;\nBIO *rbio;\nBIO *wbio;\nBIO *err;\nlong len;\nunsigned char *data;\nunsigned char *dataend;\nchar *dummytick = \"Hello World!\";\nunsigned int tmplen;\nunsigned int type;\nunsigned int size;\nint testresult = 0;\nint currtest = 0;\nerr = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);\nCRYPTO_set_mem_debug(1);\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nfor (; currtest < TOTAL_NUM_TESTS; currtest++) {\ntestresult = 0;\nif (currtest == TEST_SET_SESSION_TICK_DATA_TLS_1_2) {\nctx = SSL_CTX_new(TLSv1_2_method());\ncontinue;\n} else {\nctx = SSL_CTX_new(TLS_method());\n}\ncon = SSL_new(ctx);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -87,38 +88,42 @@ int main(int argc, char *argv[]) {+#ifndef OPENSSL_NO_TLS1_2+#else+            continue;+#endif",
            "commit_date": "2016-02-04 00:25:49+01:00",
            "commit_hash": "47c1a0e06e2f25d8bf6c6568ba4e3a11fdae422a",
            "message": "Only use TLS1.2 when it's available\nReviewed-by: Ben Laurie <ben@openssl.org>\nSSL_CTX *ctx;\nSSL *con;\nBIO *rbio;\nBIO *wbio;\nBIO *err;\nlong len;\nunsigned char *data;\nunsigned char *dataend;\nchar *dummytick = \"Hello World!\";\nunsigned int tmplen;\nunsigned int type;\nunsigned int size;\nint testresult = 0;\nint currtest = 0;\nSSL_library_init();\nSSL_load_error_strings();\nerr = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);\nCRYPTO_set_mem_debug(1);\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nfor (; currtest < TOTAL_NUM_TESTS; currtest++) {\ntestresult = 0;\nif (currtest == TEST_SET_SESSION_TICK_DATA_TLS_1_2) {\nctx = SSL_CTX_new(TLSv1_2_method());\n} else {\nctx = SSL_CTX_new(TLS_method());\n}\ncon = SSL_new(ctx);"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- a/test/clienthellotest.c+++ b/test/clienthellotest.c@@ -87,39 +87,38 @@ int main(int argc, char *argv[]) {-    CRYPTO_malloc_debug_init();-    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);+    CRYPTO_set_mem_debug(1);",
            "commit_date": "2016-01-07 15:06:38-05:00",
            "commit_hash": "bbd86bf5424a611cb6b77a3a17fc522931c4dcb8",
            "message": "mem functions cleanup\nOnly two macros CRYPTO_MDEBUG and CRYPTO_MDEBUG_ABORT to control this.\nIf CRYPTO_MDEBUG is not set, #ifdef out the whole debug machinery.\n(Thanks to Jakob Bohm for the suggestion!)\nMake the \"change wrapper functions\" be the only paradigm.\nWrote documentation!\nFormat the 'set func' functions so their paramlists are legible.\nFormat some multi-line comments.\nRemove ability to get/set the \"memory debug\" functions at runtme.\nRemove MemCheck_* and CRYPTO_malloc_debug_init macros.\nAdd CRYPTO_mem_debug(int flag) function.\nAdd test/memleaktest.\nRename CRYPTO_malloc_init to OPENSSL_malloc_init; remove needless calls.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nSSL_CTX *ctx;\nSSL *con;\nBIO *rbio;\nBIO *wbio;\nBIO *err;\nlong len;\nunsigned char *data;\nunsigned char *dataend;\nchar *dummytick = \"Hello World!\";\nunsigned int tmplen;\nunsigned int type;\nunsigned int size;\nint testresult = 0;\nint currtest = 0;\nSSL_library_init();\nSSL_load_error_strings();\nerr = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);\nCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);\n/*\n* For each test set up an SSL_CTX and SSL and see what ClientHello gets\n* produced when we try to connect\n*/\nfor (; currtest < TOTAL_NUM_TESTS; currtest++) {\ntestresult = 0;\nif (currtest == TEST_SET_SESSION_TICK_DATA_TLS_1_2) {\nctx = SSL_CTX_new(TLSv1_2_method());\n} else {\nctx = SSL_CTX_new(TLS_method());\n}\ncon = SSL_new(ctx);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/clienthellotest.c b/test/clienthellotest.c--- /dev/null+++ b/test/clienthellotest.c@@ -0,0 +87,39 @@++int main(int argc, char *argv[])+{+    SSL_CTX *ctx;+    SSL *con;+    BIO *rbio;+    BIO *wbio;+    BIO *err;+    long len;+    unsigned char *data;+    unsigned char *dataend;+    char *dummytick = \"Hello World!\";+    unsigned int tmplen;+    unsigned int type;+    unsigned int size;+    int testresult = 0;+    int currtest = 0;++    SSL_library_init();+    SSL_load_error_strings();++    err = BIO_new_fp(stderr, BIO_NOCLOSE | BIO_FP_TEXT);++    CRYPTO_malloc_debug_init();+    CRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);+    CRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);++    /*+     * For each test set up an SSL_CTX and SSL and see what ClientHello gets+     * produced when we try to connect+     */+    for (; currtest < TOTAL_NUM_TESTS; currtest++) {+        testresult = 0;+        if (currtest == TEST_SET_SESSION_TICK_DATA_TLS_1_2) {+            ctx = SSL_CTX_new(TLSv1_2_method());+        } else {+            ctx = SSL_CTX_new(TLS_method());+        }+        con = SSL_new(ctx);",
            "commit_date": "2015-07-27 12:04:47+01:00",
            "commit_hash": "3b848c642cdbca17c686c95b8fd655e5b1f5df2a",
            "message": "Add test for SSL_set_session_ticket_ext\nThe function SSL_set_session_ticket_ext sets the ticket data to be sent in\nthe ClientHello. This is useful for EAP-FAST. This commit adds a test to\nensure that when this function is called the expected ticket data actually\nappears in the ClientHello.\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>"
        }
    ],
    "git log -L347,357:test/bftest.c": [
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/bftest.c b/test/bftest.c--- a/test/bftest.c+++ b/test/bftest.c@@ -362,14 +354,11 @@-    /* Set key */-    for (n = 1; n < KEY_TEST_NUM; n++) {-        BF_set_key(&key, n, key_test);-        BF_ecb_encrypt(key_data, out, &key, BF_ENCRYPT);-        /* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */-        if (!TEST_mem_eq(out, 8, &(key_out[i = n - 1][0]), 8))-            ret = 0;-    }+static int test_bf_cbc(void)+{+    unsigned char cbc_in[40], cbc_out[40], iv[8];+    int ret = 1;+    BF_KEY key;+    BF_LONG len;-    /* CBC Mode */",
            "commit_date": "2017-04-12 11:03:29+10:00",
            "commit_hash": "56bf5c55cd7d751390e92aad2b2bd9cc031b1e43",
            "message": "Code review. Split tests up\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3177)\nlen = strlen(cbc_data) + 1;\nBF_set_key(&key, 16, cbc_key);"
        },
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/bftest.c b/test/bftest.c--- a/test/bftest.c+++ b/test/bftest.c@@ -395,16 +362,14 @@-    printf(\"testing blowfish set_key\\n\");+    /* Set key */-        if (memcmp(out, &(key_out[i = n - 1][0]), 8) != 0) {-            printf(\"blowfish setkey error\\n\");-            err = 1;-        }+        if (!TEST_mem_eq(out, 8, &(key_out[i = n - 1][0]), 8))+            ret = 0;-    printf(\"testing blowfish in cbc mode\\n\");+    /* CBC Mode */",
            "commit_date": "2017-04-11 14:31:28+10:00",
            "commit_hash": "70e1acd786511724e3680790f358d1fc4756a49b",
            "message": "Convert blowfish tests to new framework\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3177)\nfor (n = 1; n < KEY_TEST_NUM; n++) {\nBF_set_key(&key, n, key_test);\nBF_ecb_encrypt(key_data, out, &key, BF_ENCRYPT);\n/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */\n}\nlen = strlen(cbc_data) + 1;\nBF_set_key(&key, 16, cbc_key);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -356,184 +449,16 @@-\t{-\tunsigned char cbc_in[40],cbc_out[40],iv[8];-\tint i,n,err=0;-\tBF_KEY key;-\tBF_LONG data[2]; -\tunsigned char out[8]; -\tBF_LONG len;--#ifdef CHARSET_EBCDIC-\tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data));-#endif--\tprintf(\"testing blowfish in raw ecb mode\\n\");-\tfor (n=0; n<2; n++)-\t\t{-#ifdef CHARSET_EBCDIC-\t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n]));-#endif-\t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]);--\t\tdata[0]=bf_plain[n][0];-\t\tdata[1]=bf_plain[n][1];-\t\tBF_encrypt(data,&key);-\t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_encrypt error encrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]);-\t\t\terr=1;-\t\t\tprintf(\"\\n\");-\t\t\t}--\t\tBF_decrypt(&(data[0]),&key);-\t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_encrypt error decrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]);-\t\t\tprintf(\"\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish in ecb mode\\n\");--\tfor (n=0; n<NUM_TESTS; n++)-\t\t{-\t\tBF_set_key(&key,8,ecb_data[n]);--\t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT);-\t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",out[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",cipher_data[n][i]);-\t\t\terr=1;-\t\t\tprintf(\"\\n\");-\t\t\t}--\t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT);-\t\tif (memcmp(&(plain_data[n][0]),out,8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",out[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",plain_data[n][i]);-\t\t\tprintf(\"\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish set_key\\n\");-\tfor (n=1; n<KEY_TEST_NUM; n++)-\t\t{-\t\tBF_set_key(&key,n,key_test);-\t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);-\t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */-\t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"blowfish setkey error\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish in cbc mode\\n\");-\tlen=strlen(cbc_data)+1;--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,sizeof cbc_in);-\tmemset(cbc_out,0,sizeof cbc_out);-\tmemcpy(iv,cbc_iv,sizeof iv);-\tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len,-\t\t&key,iv,BF_ENCRYPT);-\tif (memcmp(cbc_out,cbc_ok,32) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_cbc_encrypt encrypt error\\n\");-\t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tmemcpy(iv,cbc_iv,8);-\tBF_cbc_encrypt(cbc_out,cbc_in,len,-\t\t&key,iv,BF_DECRYPT);-\tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)-\t\t{-\t\tprintf(\"BF_cbc_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\tprintf(\"testing blowfish in cfb64 mode\\n\");--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);-\tn=0;-\tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,-\t\t&key,iv,&n,BF_ENCRYPT);-\tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13,-\t\t&key,iv,&n,BF_ENCRYPT);-\tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\");-\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tn=0;-\tmemcpy(iv,cbc_iv,8);-\tBF_cfb64_encrypt(cbc_out,cbc_in,17,-\t\t&key,iv,&n,BF_DECRYPT);-\tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,-\t\t&key,iv,&n,BF_DECRYPT);-\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)-\t\t{-\t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\tprintf(\"testing blowfish in ofb64\\n\");--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);-\tn=0;-\tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n);-\tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]),-\t\t&(cbc_out[13]),len-13,&key,iv,&n);-\tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\");-\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tn=0;-\tmemcpy(iv,cbc_iv,8);-\tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n);-\tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n);-\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)-\t\t{-\t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\treturn(err);-\t}++    printf(\"testing blowfish set_key\\n\");+    for (n = 1; n < KEY_TEST_NUM; n++) {+        BF_set_key(&key, n, key_test);+        BF_ecb_encrypt(key_data, out, &key, BF_ENCRYPT);+        /* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */+        if (memcmp(out, &(key_out[i = n - 1][0]), 8) != 0) {+            printf(\"blowfish setkey error\\n\");+            err = 1;+        }+    }++    printf(\"testing blowfish in cbc mode\\n\");+    len = strlen(cbc_data) + 1;++    BF_set_key(&key, 16, cbc_key);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -350,184 +350,184 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; #ifdef CHARSET_EBCDIC \tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data)); #endif \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ #ifdef CHARSET_EBCDIC \t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n])); #endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */ \t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);+\tmemset(cbc_in,0,sizeof cbc_in);+\tmemset(cbc_out,0,sizeof cbc_out);+\tmemcpy(iv,cbc_iv,sizeof iv); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "2002-11-13 15:43:43+00:00",
            "commit_hash": "54a656ef081f72a740c550ebd8099b40b8b5cde0",
            "message": "Security fixes brought forward from 0.9.7."
        },
        {
            "author": {
                "email": "appro@openssl.org",
                "name": "Andy Polyakov"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -350,183 +350,184 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; #ifdef CHARSET_EBCDIC \tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data)); #endif \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ #ifdef CHARSET_EBCDIC \t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n])); #endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);-\t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0)+\t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */+\t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "2000-06-05 14:39:47+00:00",
            "commit_hash": "e6441154fc8365f0be481d9f619caedc019283d6",
            "message": "GCC 2.95.2 from IRIX 6.5 -mabi=64 compiler bug workaround:-(\nSubmitted by:\nReviewed by:\nPR:"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -346,176 +350,183 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len;+#ifdef CHARSET_EBCDIC+\tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data));+#endif+ \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{+#ifdef CHARSET_EBCDIC+\t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n]));+#endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1999-06-04 21:35:58+00:00",
            "commit_hash": "a53955d8abd68c604de02cc1e101c66169207fb7",
            "message": "Support the EBCDIC character set and BS2000/OSD-POSIX (work in progress).\nSubmitted by: Martin Kraemer <Martin.Kraemer@MchP.Siemens.De>"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -344,176 +344,176 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",bf_plain[n][i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1999-04-20 22:48:55+00:00",
            "commit_hash": "f36cd05b22a587e552c97797b54fd07bc0762446",
            "message": "Fix some warnings."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -346,176 +346,176 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1];-\t\tBF_encrypt(data,&key,BF_ENCRYPT);+\t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t}-\t\tBF_encrypt(&(data[0]),&key,BF_DECRYPT);+\t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1998-12-21 10:56:39+00:00",
            "commit_hash": "58964a492275ca9a59a0cd9c8155cb2491b4b909",
            "message": "Import of old SSLeay release: SSLeay 0.9.0b"
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- /dev/null+++ b/crypto/bf/bftest.c@@ -0,0 +346,176 @@+\t{+\tunsigned char cbc_in[40],cbc_out[40],iv[8];+\tint i,n,err=0;+\tBF_KEY key;+\tBF_LONG data[2]; +\tunsigned char out[8]; +\tBF_LONG len;++\tprintf(\"testing blowfish in raw ecb mode\\n\");+\tfor (n=0; n<2; n++)+\t\t{+\t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]);++\t\tdata[0]=bf_plain[n][0];+\t\tdata[1]=bf_plain[n][1];+\t\tBF_encrypt(data,&key,BF_ENCRYPT);+\t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_encrypt error encrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]);+\t\t\terr=1;+\t\t\tprintf(\"\\n\");+\t\t\t}++\t\tBF_encrypt(&(data[0]),&key,BF_DECRYPT);+\t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_encrypt error decrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",bf_plain[n][i]);+\t\t\tprintf(\"\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish in ecb mode\\n\");++\tfor (n=0; n<NUM_TESTS; n++)+\t\t{+\t\tBF_set_key(&key,8,ecb_data[n]);++\t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT);+\t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",out[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",cipher_data[n][i]);+\t\t\terr=1;+\t\t\tprintf(\"\\n\");+\t\t\t}++\t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT);+\t\tif (memcmp(&(plain_data[n][0]),out,8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",out[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",plain_data[n][i]);+\t\t\tprintf(\"\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish set_key\\n\");+\tfor (n=1; n<KEY_TEST_NUM; n++)+\t\t{+\t\tBF_set_key(&key,n,key_test);+\t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);+\t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"blowfish setkey error\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish in cbc mode\\n\");+\tlen=strlen(cbc_data)+1;++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len,+\t\t&key,iv,BF_ENCRYPT);+\tif (memcmp(cbc_out,cbc_ok,32) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_cbc_encrypt encrypt error\\n\");+\t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tmemcpy(iv,cbc_iv,8);+\tBF_cbc_encrypt(cbc_out,cbc_in,len,+\t\t&key,iv,BF_DECRYPT);+\tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)+\t\t{+\t\tprintf(\"BF_cbc_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\tprintf(\"testing blowfish in cfb64 mode\\n\");++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tn=0;+\tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,+\t\t&key,iv,&n,BF_ENCRYPT);+\tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13,+\t\t&key,iv,&n,BF_ENCRYPT);+\tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\");+\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tn=0;+\tmemcpy(iv,cbc_iv,8);+\tBF_cfb64_encrypt(cbc_out,cbc_in,17,+\t\t&key,iv,&n,BF_DECRYPT);+\tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,+\t\t&key,iv,&n,BF_DECRYPT);+\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)+\t\t{+\t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\tprintf(\"testing blowfish in ofb64\\n\");++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tn=0;+\tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n);+\tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]),+\t\t&(cbc_out[13]),len-13,&key,iv,&n);+\tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\");+\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tn=0;+\tmemcpy(iv,cbc_iv,8);+\tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n);+\tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n);+\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)+\t\t{+\t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\treturn(err);+\t}",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L373,383:test/bftest.c": [
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/bftest.c b/test/bftest.c--- a/test/bftest.c+++ b/test/bftest.c@@ -389,2 +380,11 @@-    /* CFB64 Mode */++static int test_bf_cfb64(void)+{+    unsigned char cbc_in[40], cbc_out[40], iv[8];+    int n, ret = 1;+    BF_KEY key;+    BF_LONG len;++    len = strlen(cbc_data) + 1;+",
            "commit_date": "2017-04-12 11:03:29+10:00",
            "commit_hash": "56bf5c55cd7d751390e92aad2b2bd9cc031b1e43",
            "message": "Code review. Split tests up\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3177)\nBF_set_key(&key, 16, cbc_key);"
        },
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/bftest.c b/test/bftest.c--- a/test/bftest.c+++ b/test/bftest.c@@ -431,1 +389,2 @@+    /* CFB64 Mode */",
            "commit_date": "2017-04-11 14:31:28+10:00",
            "commit_hash": "70e1acd786511724e3680790f358d1fc4756a49b",
            "message": "Convert blowfish tests to new framework\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3177)\nBF_set_key(&key, 16, cbc_key);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -356,184 +485,1 @@-\t{-\tunsigned char cbc_in[40],cbc_out[40],iv[8];-\tint i,n,err=0;-\tBF_KEY key;-\tBF_LONG data[2]; -\tunsigned char out[8]; -\tBF_LONG len;--#ifdef CHARSET_EBCDIC-\tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data));-#endif--\tprintf(\"testing blowfish in raw ecb mode\\n\");-\tfor (n=0; n<2; n++)-\t\t{-#ifdef CHARSET_EBCDIC-\t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n]));-#endif-\t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]);--\t\tdata[0]=bf_plain[n][0];-\t\tdata[1]=bf_plain[n][1];-\t\tBF_encrypt(data,&key);-\t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_encrypt error encrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]);-\t\t\terr=1;-\t\t\tprintf(\"\\n\");-\t\t\t}--\t\tBF_decrypt(&(data[0]),&key);-\t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_encrypt error decrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]);-\t\t\tprintf(\"\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish in ecb mode\\n\");--\tfor (n=0; n<NUM_TESTS; n++)-\t\t{-\t\tBF_set_key(&key,8,ecb_data[n]);--\t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT);-\t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",out[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",cipher_data[n][i]);-\t\t\terr=1;-\t\t\tprintf(\"\\n\");-\t\t\t}--\t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT);-\t\tif (memcmp(&(plain_data[n][0]),out,8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",out[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",plain_data[n][i]);-\t\t\tprintf(\"\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish set_key\\n\");-\tfor (n=1; n<KEY_TEST_NUM; n++)-\t\t{-\t\tBF_set_key(&key,n,key_test);-\t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);-\t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */-\t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"blowfish setkey error\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish in cbc mode\\n\");-\tlen=strlen(cbc_data)+1;--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,sizeof cbc_in);-\tmemset(cbc_out,0,sizeof cbc_out);-\tmemcpy(iv,cbc_iv,sizeof iv);-\tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len,-\t\t&key,iv,BF_ENCRYPT);-\tif (memcmp(cbc_out,cbc_ok,32) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_cbc_encrypt encrypt error\\n\");-\t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tmemcpy(iv,cbc_iv,8);-\tBF_cbc_encrypt(cbc_out,cbc_in,len,-\t\t&key,iv,BF_DECRYPT);-\tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)-\t\t{-\t\tprintf(\"BF_cbc_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\tprintf(\"testing blowfish in cfb64 mode\\n\");--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);-\tn=0;-\tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,-\t\t&key,iv,&n,BF_ENCRYPT);-\tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13,-\t\t&key,iv,&n,BF_ENCRYPT);-\tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\");-\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tn=0;-\tmemcpy(iv,cbc_iv,8);-\tBF_cfb64_encrypt(cbc_out,cbc_in,17,-\t\t&key,iv,&n,BF_DECRYPT);-\tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,-\t\t&key,iv,&n,BF_DECRYPT);-\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)-\t\t{-\t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\tprintf(\"testing blowfish in ofb64\\n\");--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);-\tn=0;-\tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n);-\tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]),-\t\t&(cbc_out[13]),len-13,&key,iv,&n);-\tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\");-\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tn=0;-\tmemcpy(iv,cbc_iv,8);-\tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n);-\tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n);-\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)-\t\t{-\t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\treturn(err);-\t}+    BF_set_key(&key, 16, cbc_key);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -350,184 +350,184 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; #ifdef CHARSET_EBCDIC \tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data)); #endif \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ #ifdef CHARSET_EBCDIC \t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n])); #endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */ \t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);+\tmemset(cbc_in,0,sizeof cbc_in);+\tmemset(cbc_out,0,sizeof cbc_out);+\tmemcpy(iv,cbc_iv,sizeof iv); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "2002-11-13 15:43:43+00:00",
            "commit_hash": "54a656ef081f72a740c550ebd8099b40b8b5cde0",
            "message": "Security fixes brought forward from 0.9.7."
        },
        {
            "author": {
                "email": "appro@openssl.org",
                "name": "Andy Polyakov"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -350,183 +350,184 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; #ifdef CHARSET_EBCDIC \tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data)); #endif \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ #ifdef CHARSET_EBCDIC \t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n])); #endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);-\t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0)+\t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */+\t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "2000-06-05 14:39:47+00:00",
            "commit_hash": "e6441154fc8365f0be481d9f619caedc019283d6",
            "message": "GCC 2.95.2 from IRIX 6.5 -mabi=64 compiler bug workaround:-(\nSubmitted by:\nReviewed by:\nPR:"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -346,176 +350,183 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len;+#ifdef CHARSET_EBCDIC+\tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data));+#endif+ \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{+#ifdef CHARSET_EBCDIC+\t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n]));+#endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1999-06-04 21:35:58+00:00",
            "commit_hash": "a53955d8abd68c604de02cc1e101c66169207fb7",
            "message": "Support the EBCDIC character set and BS2000/OSD-POSIX (work in progress).\nSubmitted by: Martin Kraemer <Martin.Kraemer@MchP.Siemens.De>"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -344,176 +344,176 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",bf_plain[n][i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1999-04-20 22:48:55+00:00",
            "commit_hash": "f36cd05b22a587e552c97797b54fd07bc0762446",
            "message": "Fix some warnings."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -346,176 +346,176 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1];-\t\tBF_encrypt(data,&key,BF_ENCRYPT);+\t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t}-\t\tBF_encrypt(&(data[0]),&key,BF_DECRYPT);+\t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1998-12-21 10:56:39+00:00",
            "commit_hash": "58964a492275ca9a59a0cd9c8155cb2491b4b909",
            "message": "Import of old SSLeay release: SSLeay 0.9.0b"
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- /dev/null+++ b/crypto/bf/bftest.c@@ -0,0 +346,176 @@+\t{+\tunsigned char cbc_in[40],cbc_out[40],iv[8];+\tint i,n,err=0;+\tBF_KEY key;+\tBF_LONG data[2]; +\tunsigned char out[8]; +\tBF_LONG len;++\tprintf(\"testing blowfish in raw ecb mode\\n\");+\tfor (n=0; n<2; n++)+\t\t{+\t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]);++\t\tdata[0]=bf_plain[n][0];+\t\tdata[1]=bf_plain[n][1];+\t\tBF_encrypt(data,&key,BF_ENCRYPT);+\t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_encrypt error encrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]);+\t\t\terr=1;+\t\t\tprintf(\"\\n\");+\t\t\t}++\t\tBF_encrypt(&(data[0]),&key,BF_DECRYPT);+\t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_encrypt error decrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",bf_plain[n][i]);+\t\t\tprintf(\"\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish in ecb mode\\n\");++\tfor (n=0; n<NUM_TESTS; n++)+\t\t{+\t\tBF_set_key(&key,8,ecb_data[n]);++\t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT);+\t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",out[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",cipher_data[n][i]);+\t\t\terr=1;+\t\t\tprintf(\"\\n\");+\t\t\t}++\t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT);+\t\tif (memcmp(&(plain_data[n][0]),out,8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",out[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",plain_data[n][i]);+\t\t\tprintf(\"\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish set_key\\n\");+\tfor (n=1; n<KEY_TEST_NUM; n++)+\t\t{+\t\tBF_set_key(&key,n,key_test);+\t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);+\t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"blowfish setkey error\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish in cbc mode\\n\");+\tlen=strlen(cbc_data)+1;++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len,+\t\t&key,iv,BF_ENCRYPT);+\tif (memcmp(cbc_out,cbc_ok,32) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_cbc_encrypt encrypt error\\n\");+\t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tmemcpy(iv,cbc_iv,8);+\tBF_cbc_encrypt(cbc_out,cbc_in,len,+\t\t&key,iv,BF_DECRYPT);+\tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)+\t\t{+\t\tprintf(\"BF_cbc_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\tprintf(\"testing blowfish in cfb64 mode\\n\");++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tn=0;+\tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,+\t\t&key,iv,&n,BF_ENCRYPT);+\tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13,+\t\t&key,iv,&n,BF_ENCRYPT);+\tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\");+\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tn=0;+\tmemcpy(iv,cbc_iv,8);+\tBF_cfb64_encrypt(cbc_out,cbc_in,17,+\t\t&key,iv,&n,BF_DECRYPT);+\tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,+\t\t&key,iv,&n,BF_DECRYPT);+\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)+\t\t{+\t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\tprintf(\"testing blowfish in ofb64\\n\");++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tn=0;+\tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n);+\tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]),+\t\t&(cbc_out[13]),len-13,&key,iv,&n);+\tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\");+\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tn=0;+\tmemcpy(iv,cbc_iv,8);+\tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n);+\tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n);+\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)+\t\t{+\t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\treturn(err);+\t}",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L95,125:crypto/idea/i_cbc.c": [
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/idea/i_cbc.c b/crypto/idea/i_cbc.c--- a/crypto/idea/i_cbc.c+++ b/crypto/idea/i_cbc.c@@ -136,31 +136,31 @@-void idea_encrypt(unsigned long *d, IDEA_KEY_SCHEDULE *key)+void IDEA_encrypt(unsigned long *d, IDEA_KEY_SCHEDULE *key) {",
            "commit_date": "2016-04-18 07:43:54-04:00",
            "commit_hash": "9021a5dfb37fd3a6f7726f07ef0f27dcb71048e2",
            "message": "Rename some lowercase API's\nMake OBJ_name_cmp internal\nRename idea_xxx to IDEA_xxx\nRename get_rfc_xxx to BN_get_rfc_xxx\nRename v3_addr and v3_asid functions to X509v3_...\nReviewed-by: Richard Levitte <levitte@openssl.org>\nregister IDEA_INT *p;\nregister unsigned long x1, x2, x3, x4, t0, t1, ul;\nx2 = d[0];\nx1 = (x2 >> 16);\nx4 = d[1];\nx3 = (x4 >> 16);\np = &(key->data[0][0]);\nE_IDEA(0);\nE_IDEA(1);\nE_IDEA(2);\nE_IDEA(3);\nE_IDEA(4);\nE_IDEA(5);\nE_IDEA(6);\nE_IDEA(7);\nx1 &= 0xffff;\nidea_mul(x1, x1, *p, ul);\np++;\nt0 = x3 + *(p++);\nt1 = x2 + *(p++);\nx4 &= 0xffff;\nidea_mul(x4, x4, *p, ul);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/idea/i_cbc.c b/crypto/idea/i_cbc.c--- a/crypto/idea/i_cbc.c+++ b/crypto/idea/i_cbc.c@@ -135,30 +137,31 @@ void idea_encrypt(unsigned long *d, IDEA_KEY_SCHEDULE *key)-\t{-\tregister IDEA_INT *p;-\tregister unsigned long x1,x2,x3,x4,t0,t1,ul;+{+    register IDEA_INT *p;+    register unsigned long x1, x2, x3, x4, t0, t1, ul;-\tx2=d[0];-\tx1=(x2>>16);-\tx4=d[1];-\tx3=(x4>>16);+    x2 = d[0];+    x1 = (x2 >> 16);+    x4 = d[1];+    x3 = (x4 >> 16);-\tp= &(key->data[0][0]);+    p = &(key->data[0][0]);-\tE_IDEA(0);-\tE_IDEA(1);-\tE_IDEA(2);-\tE_IDEA(3);-\tE_IDEA(4);-\tE_IDEA(5);-\tE_IDEA(6);-\tE_IDEA(7);+    E_IDEA(0);+    E_IDEA(1);+    E_IDEA(2);+    E_IDEA(3);+    E_IDEA(4);+    E_IDEA(5);+    E_IDEA(6);+    E_IDEA(7);-\tx1&=0xffff;-\tidea_mul(x1,x1,*p,ul); p++;+    x1 &= 0xffff;+    idea_mul(x1, x1, *p, ul);+    p++;-\tt0= x3+ *(p++);-\tt1= x2+ *(p++);+    t0 = x3 + *(p++);+    t1 = x2 + *(p++);-\tx4&=0xffff;-\tidea_mul(x4,x4,*p,ul);+    x4 &= 0xffff;+    idea_mul(x4, x4, *p, ul);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/idea/i_cbc.c b/crypto/idea/i_cbc.c--- a/crypto/idea/i_cbc.c+++ b/crypto/idea/i_cbc.c@@ -140,32 +135,30 @@-void idea_encrypt(d,key)-unsigned long *d;-IDEA_KEY_SCHEDULE *key;+void idea_encrypt(unsigned long *d, IDEA_KEY_SCHEDULE *key) \t{ \tregister IDEA_INT *p; \tregister unsigned long x1,x2,x3,x4,t0,t1,ul; \tx2=d[0]; \tx1=(x2>>16); \tx4=d[1]; \tx3=(x4>>16); \tp= &(key->data[0][0]); \tE_IDEA(0); \tE_IDEA(1); \tE_IDEA(2); \tE_IDEA(3); \tE_IDEA(4); \tE_IDEA(5); \tE_IDEA(6); \tE_IDEA(7); \tx1&=0xffff; \tidea_mul(x1,x1,*p,ul); p++; \tt0= x3+ *(p++); \tt1= x2+ *(p++); \tx4&=0xffff; \tidea_mul(x4,x4,*p,ul);",
            "commit_date": "1999-04-19 21:31:43+00:00",
            "commit_hash": "6b691a5c85ddc4e407e32781841fee5c029506cd",
            "message": "Change functions to ANSI C."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/idea/i_cbc.c b/crypto/idea/i_cbc.c--- a/crypto/idea/i_cbc.c+++ b/crypto/idea/i_cbc.c@@ -140,1 +140,32 @@+void idea_encrypt(d,key)+unsigned long *d;+IDEA_KEY_SCHEDULE *key;+\t{+\tregister IDEA_INT *p;+\tregister unsigned long x1,x2,x3,x4,t0,t1,ul;++\tx2=d[0];+\tx1=(x2>>16);+\tx4=d[1];+\tx3=(x4>>16);++\tp= &(key->data[0][0]);++\tE_IDEA(0);+\tE_IDEA(1);+\tE_IDEA(2);+\tE_IDEA(3);+\tE_IDEA(4);+\tE_IDEA(5);+\tE_IDEA(6);+\tE_IDEA(7);++\tx1&=0xffff;+\tidea_mul(x1,x1,*p,ul); p++;++\tt0= x3+ *(p++);+\tt1= x2+ *(p++);++\tx4&=0xffff;+\tidea_mul(x4,x4,*p,ul);",
            "commit_date": "1998-12-21 10:56:39+00:00",
            "commit_hash": "58964a492275ca9a59a0cd9c8155cb2491b4b909",
            "message": "Import of old SSLeay release: SSLeay 0.9.0b"
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/idea/i_cbc.c b/crypto/idea/i_cbc.c--- /dev/null+++ b/crypto/idea/i_cbc.c@@ -0,0 +140,1 @@+",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L60,86:crypto/idea/i_skey.c": [
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -101,27 +101,27 @@-void idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk)+void IDEA_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk) {",
            "commit_date": "2016-04-18 07:43:54-04:00",
            "commit_hash": "9021a5dfb37fd3a6f7726f07ef0f27dcb71048e2",
            "message": "Rename some lowercase API's\nMake OBJ_name_cmp internal\nRename idea_xxx to IDEA_xxx\nRename get_rfc_xxx to BN_get_rfc_xxx\nRename v3_addr and v3_asid functions to X509v3_...\nReviewed-by: Richard Levitte <levitte@openssl.org>\nint r;\nregister IDEA_INT *fp, *tp, t;\ntp = &(dk->data[0][0]);\nfp = &(ek->data[8][0]);\nfor (r = 0; r < 9; r++) {\n*(tp++) = inverse(fp[0]);\n*(tp++) = ((int)(0x10000L - fp[2]) & 0xffff);\n*(tp++) = ((int)(0x10000L - fp[1]) & 0xffff);\n*(tp++) = inverse(fp[3]);\nif (r == 8)\nbreak;\nfp -= 6;\n*(tp++) = fp[4];\n*(tp++) = fp[5];\n}\ntp = &(dk->data[0][0]);\nt = tp[1];\ntp[1] = tp[2];\ntp[2] = t;\nt = tp[49];\ntp[49] = tp[50];"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -96,29 +102,27 @@ void idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk)-\t{-\tint r;-\tregister IDEA_INT *fp,*tp,t;+{+    int r;+    register IDEA_INT *fp, *tp, t;-\ttp= &(dk->data[0][0]);-\tfp= &(ek->data[8][0]);-\tfor (r=0; r<9; r++)-\t\t{-\t\t*(tp++)=inverse(fp[0]);-\t\t*(tp++)=((int)(0x10000L-fp[2])&0xffff);-\t\t*(tp++)=((int)(0x10000L-fp[1])&0xffff);-\t\t*(tp++)=inverse(fp[3]);-\t\tif (r == 8) break;-\t\tfp-=6;-\t\t*(tp++)=fp[4];-\t\t*(tp++)=fp[5];-\t\t}+    tp = &(dk->data[0][0]);+    fp = &(ek->data[8][0]);+    for (r = 0; r < 9; r++) {+        *(tp++) = inverse(fp[0]);+        *(tp++) = ((int)(0x10000L - fp[2]) & 0xffff);+        *(tp++) = ((int)(0x10000L - fp[1]) & 0xffff);+        *(tp++) = inverse(fp[3]);+        if (r == 8)+            break;+        fp -= 6;+        *(tp++) = fp[4];+        *(tp++) = fp[5];+    }-\ttp= &(dk->data[0][0]);-\tt=tp[1];-\ttp[1]=tp[2];-\ttp[2]=t;+    tp = &(dk->data[0][0]);+    t = tp[1];+    tp[1] = tp[2];+    tp[2] = t;-\tt=tp[49];-\ttp[49]=tp[50];-\ttp[50]=t;-\t}+    t = tp[49];+    tp[49] = tp[50];",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- a/crypto/idea/i_skey.c+++ b/crypto/idea/i_skey.c@@ -103,31 +101,29 @@-void idea_set_decrypt_key(ek, dk)-IDEA_KEY_SCHEDULE *ek;-IDEA_KEY_SCHEDULE *dk;+void idea_set_decrypt_key(IDEA_KEY_SCHEDULE *ek, IDEA_KEY_SCHEDULE *dk) \t{ \tint r; \tregister IDEA_INT *fp,*tp,t; \ttp= &(dk->data[0][0]); \tfp= &(ek->data[8][0]); \tfor (r=0; r<9; r++) \t\t{ \t\t*(tp++)=inverse(fp[0]); \t\t*(tp++)=((int)(0x10000L-fp[2])&0xffff); \t\t*(tp++)=((int)(0x10000L-fp[1])&0xffff); \t\t*(tp++)=inverse(fp[3]); \t\tif (r == 8) break; \t\tfp-=6; \t\t*(tp++)=fp[4]; \t\t*(tp++)=fp[5]; \t\t} \ttp= &(dk->data[0][0]); \tt=tp[1]; \ttp[1]=tp[2]; \ttp[2]=t; \tt=tp[49]; \ttp[49]=tp[50]; \ttp[50]=t; \t}",
            "commit_date": "1999-04-19 21:31:43+00:00",
            "commit_hash": "6b691a5c85ddc4e407e32781841fee5c029506cd",
            "message": "Change functions to ANSI C."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/idea/i_skey.c b/crypto/idea/i_skey.c--- /dev/null+++ b/crypto/idea/i_skey.c@@ -0,0 +103,31 @@++void idea_set_decrypt_key(ek, dk)+IDEA_KEY_SCHEDULE *ek;+IDEA_KEY_SCHEDULE *dk;+\t{+\tint r;+\tregister IDEA_INT *fp,*tp,t;++\ttp= &(dk->data[0][0]);+\tfp= &(ek->data[8][0]);+\tfor (r=0; r<9; r++)+\t\t{+\t\t*(tp++)=inverse(fp[0]);+\t\t*(tp++)=((int)(0x10000L-fp[2])&0xffff);+\t\t*(tp++)=((int)(0x10000L-fp[1])&0xffff);+\t\t*(tp++)=inverse(fp[3]);+\t\tif (r == 8) break;+\t\tfp-=6;+\t\t*(tp++)=fp[4];+\t\t*(tp++)=fp[5];+\t\t}++\ttp= &(dk->data[0][0]);+\tt=tp[1];+\ttp[1]=tp[2];+\ttp[2]=t;++\tt=tp[49];+\ttp[49]=tp[50];+\ttp[50]=t;+\t}",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L146,165:test/dtls_mtu_test.c": [
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/dtls_mtu_test.c b/test/dtls_mtu_test.c--- a/test/dtls_mtu_test.c+++ b/test/dtls_mtu_test.c@@ -143,18 +143,20 @@-int main(void)+static int run_mtu_tests(void) {-    SSL_CTX *ctx = SSL_CTX_new(DTLS_method());+    SSL_CTX *ctx = NULL;-    int i, rv = 0;+    int i, ret = 0;++    if (!TEST_ptr(ctx = SSL_CTX_new(DTLS_method())))+        goto end;-    /* We only care about iterating over each enc/mac; we don't-     * want to repeat the test for each auth/kx variant.-     * So keep life simple and only do (non-DH) PSK. */-    if (!SSL_CTX_set_cipher_list(ctx, \"PSK\")) {-        fprintf(stderr, \"Failed to set PSK cipher list\\n\");-        goto out;-    }+    /*+     * We only care about iterating over each enc/mac; we don't want to+     * repeat the test for each auth/kx variant. So keep life simple and+     * only do (non-DH) PSK.+     */+    if (!TEST_true(SSL_CTX_set_cipher_list(ctx, \"PSK\")))",
            "commit_date": "2017-04-26 12:20:44-04:00",
            "commit_hash": "8ed9a26616a7101ea698c189fbbb663186676075",
            "message": "Convert dtls_mtu_test, dtlsv1listentest\nAlso converted most of ssltestlib but left the packet_dump output\nas-is (for now).\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3257)\nSTACK_OF(SSL_CIPHER) *ciphers;\nSSL_CTX_set_psk_server_callback(ctx, srvr_psk_callback);\nSSL_CTX_set_psk_client_callback(ctx, clnt_psk_callback);\nSSL_CTX_set_security_level(ctx, 0);"
        },
        {
            "author": {
                "email": "David.Woodhouse@intel.com",
                "name": "David Woodhouse"
            },
            "changes": "diff --git a/test/dtls_mtu_test.c b/test/dtls_mtu_test.c--- /dev/null+++ b/test/dtls_mtu_test.c@@ -0,0 +143,18 @@++int main(void)+{+    SSL_CTX *ctx = SSL_CTX_new(DTLS_method());+    STACK_OF(SSL_CIPHER) *ciphers;+    int i, rv = 0;++    SSL_CTX_set_psk_server_callback(ctx, srvr_psk_callback);+    SSL_CTX_set_psk_client_callback(ctx, clnt_psk_callback);+    SSL_CTX_set_security_level(ctx, 0);++    /* We only care about iterating over each enc/mac; we don't+     * want to repeat the test for each auth/kx variant.+     * So keep life simple and only do (non-DH) PSK. */+    if (!SSL_CTX_set_cipher_list(ctx, \"PSK\")) {+        fprintf(stderr, \"Failed to set PSK cipher list\\n\");+        goto out;+    }",
            "commit_date": "2016-10-12 16:13:31+01:00",
            "commit_hash": "02e22dd444c46728008a7c17e0758327f1c31e67",
            "message": "Add test cases for DTLS_get_data_mtu()\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>"
        }
    ],
    "git log -L140,150:test/evp_pkey_provided_test.c": [
        {
            "author": {
                "email": "raisinten@gmail.com",
                "name": "Darshan Sen"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -131,10 +140,11 @@+ static int test_print_key_using_pem(const char *alg, const EVP_PKEY *pk) {",
            "commit_date": "2022-01-14 16:22:41+05:30",
            "commit_hash": "59ccb72cd5cec3b4e312853621e12a68dacdbc7e",
            "message": "Fix invalid malloc failures in PEM_write_bio_PKCS8PrivateKey()\nWhen `PEM_write_bio_PKCS8PrivateKey()` was passed an empty passphrase\nstring, `OPENSSL_memdup()` was incorrectly getting used for 0 bytes size\nallocation, which resulted in malloc failures.\nFixes: https://github.com/openssl/openssl/issues/17506\nSigned-off-by: Darshan Sen <raisinten@gmail.com>\nReviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/17507)\nBIO *membio = BIO_new(BIO_s_mem());\nint ret = 0;\nif (!TEST_ptr(membio))\ngoto err;\nif (/* Output Encrypted private key in PEM form */\n!TEST_true(PEM_write_bio_PrivateKey(bio_out, pk, EVP_aes_256_cbc(),"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -125,9 +125,10 @@ static int test_print_key_using_pem(const char *alg, const EVP_PKEY *pk) {-    if (!TEST_true(EVP_PKEY_print_private(membio, pk, 0, NULL))+    if (/* Output Encrypted private key in PEM form */+        !TEST_true(PEM_write_bio_PrivateKey(bio_out, pk, EVP_aes_256_cbc(),",
            "commit_date": "2020-05-07 09:56:52+02:00",
            "commit_hash": "d59b7a54a5332303c42c3d097db5764dc809ecc9",
            "message": "test/evp_pkey_provided_test.c: Display first, compare after\nTo make it easier to check the generated key manually, display it\nbefore comparing diverse other serializations.\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/11710)\nBIO *membio = BIO_new(BIO_s_mem());\nint ret = 0;\nif (!TEST_ptr(membio))\ngoto err;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -20,3 +123,9 @@-static int test_print_key_using_pem(const EVP_PKEY *pk)+static int test_print_key_using_pem(const char *alg, const EVP_PKEY *pk) {-    if (!TEST_true(EVP_PKEY_print_private(bio_out, pk, 0, NULL))+    BIO *membio = BIO_new(BIO_s_mem());+    int ret = 0;++    if (!TEST_ptr(membio))+        goto err;++    if (!TEST_true(EVP_PKEY_print_private(membio, pk, 0, NULL))",
            "commit_date": "2020-02-28 08:08:59+10:00",
            "commit_hash": "8efc4a9c656b8b3eabeac64c54efdeb07dd42f8e",
            "message": "Implement the ECX Serializers\nProvide serializers for X25519 and X448 for text, pem and der. There are\nno parameter serializers because there are no parameters for these\nalgorithms.\nAdd some documentation about the various import/export types available\nAdd additional testing for the serializers\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/11095)"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- /dev/null+++ b/test/evp_pkey_provided_test.c@@ -0,0 +20,3 @@+static int test_print_key_using_pem(const EVP_PKEY *pk)+{+    if (!TEST_true(EVP_PKEY_print_private(bio_out, pk, 0, NULL))",
            "commit_date": "2019-11-18 02:30:50+01:00",
            "commit_hash": "6ae5543c5f8476f4cae9c00209ef062746bbfd3c",
            "message": "TEST: add tests of text and PEM printout of a provider made key\nThis renames test/evp_fromdata_test.c to test/evp_pkey_provided_test.c,\nto encourage additional testing of provider made keys.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/10394)"
        }
    ],
    "git log -L303,304:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -158,1 +188,2 @@-    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);+{+    return test_http_url_path_query_ok(\"http://usr@host:1/p?q=x#frag\", \"/p?q=x\")",
            "commit_date": "2021-01-28 22:10:47+01:00",
            "commit_hash": "7932982b88f5095f60397fe727d27ddf7234f4d6",
            "message": "OSSL_HTTP_parse_url(): Handle any userinfo, query, and fragment components\nNow handle [http[s]://][userinfo@]host[:port][/path][?query][#frag]\nby optionally providing any userinfo, query, and frag components.\nAll usages of this function, which are client-only,\nsilently ignore userinfo and frag components,\nwhile the query component is taken as part of the path.\nUpdate and extend the unit tests and all affected documentation.\nDocument and deprecat OCSP_parse_url().\nFixes an issue that came up when discussing FR #14001.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14009)"
        },
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +174,1 @@+    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L347,350:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +209,4 @@++static int test_http_url_invalid_port(void)+{+    return test_http_url_invalid(\"https://1.2.3.4:65536/pkix\");",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L305,306:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -158,1 +190,2 @@-    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);+        && test_http_url_path_query_ok(\"http://host?query#frag\", \"/?query\")+        && test_http_url_path_query_ok(\"http://host:9999#frag\", \"/\");",
            "commit_date": "2021-01-28 22:10:47+01:00",
            "commit_hash": "7932982b88f5095f60397fe727d27ddf7234f4d6",
            "message": "OSSL_HTTP_parse_url(): Handle any userinfo, query, and fragment components\nNow handle [http[s]://][userinfo@]host[:port][/path][?query][#frag]\nby optionally providing any userinfo, query, and frag components.\nAll usages of this function, which are client-only,\nsilently ignore userinfo and frag components,\nwhile the query component is taken as part of the path.\nUpdate and extend the unit tests and all affected documentation.\nDocument and deprecat OCSP_parse_url().\nFixes an issue that came up when discussing FR #14001.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14009)"
        },
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +174,1 @@+    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L308,311:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -158,1 +193,4 @@-    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);++static int test_http_url_userinfo_query_fragment(void)+{+    return test_http_url_ok(\"user:pass@host/p?q#fr\", 0, \"host\", \"80\", \"/p\");",
            "commit_date": "2021-01-28 22:10:47+01:00",
            "commit_hash": "7932982b88f5095f60397fe727d27ddf7234f4d6",
            "message": "OSSL_HTTP_parse_url(): Handle any userinfo, query, and fragment components\nNow handle [http[s]://][userinfo@]host[:port][/path][?query][#frag]\nby optionally providing any userinfo, query, and frag components.\nAll usages of this function, which are client-only,\nsilently ignore userinfo and frag components,\nwhile the query component is taken as part of the path.\nUpdate and extend the unit tests and all affected documentation.\nDocument and deprecat OCSP_parse_url().\nFixes an issue that came up when discussing FR #14001.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14009)"
        },
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +174,1 @@+    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L342,345:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +204,4 @@++static int test_http_url_invalid_prefix(void)+{+    return test_http_url_invalid(\"htttps://1.2.3.4:65535/pkix\");",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L304,305:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -158,1 +189,2 @@-    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);+    return test_http_url_path_query_ok(\"http://usr@host:1/p?q=x#frag\", \"/p?q=x\")+        && test_http_url_path_query_ok(\"http://host?query#frag\", \"/?query\")",
            "commit_date": "2021-01-28 22:10:47+01:00",
            "commit_hash": "7932982b88f5095f60397fe727d27ddf7234f4d6",
            "message": "OSSL_HTTP_parse_url(): Handle any userinfo, query, and fragment components\nNow handle [http[s]://][userinfo@]host[:port][/path][?query][#frag]\nby optionally providing any userinfo, query, and frag components.\nAll usages of this function, which are client-only,\nsilently ignore userinfo and frag components,\nwhile the query component is taken as part of the path.\nUpdate and extend the unit tests and all affected documentation.\nDocument and deprecat OCSP_parse_url().\nFixes an issue that came up when discussing FR #14001.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14009)"
        },
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +174,1 @@+    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L352,355:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +214,4 @@++static int test_http_url_invalid_path(void)+{+    return test_http_url_invalid(\"https://[FF01::101]pkix\");",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L296,299:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -155,4 +181,4 @@ static int test_http_url_dns(void) {-    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);+    return test_http_url_ok(\"host:65535/path\", 0, \"host\", \"65535\", \"/path\");",
            "commit_date": "2021-01-28 22:10:47+01:00",
            "commit_hash": "7932982b88f5095f60397fe727d27ddf7234f4d6",
            "message": "OSSL_HTTP_parse_url(): Handle any userinfo, query, and fragment components\nNow handle [http[s]://][userinfo@]host[:port][/path][?query][#frag]\nby optionally providing any userinfo, query, and frag components.\nAll usages of this function, which are client-only,\nsilently ignore userinfo and frag components,\nwhile the query component is taken as part of the path.\nUpdate and extend the unit tests and all affected documentation.\nDocument and deprecat OCSP_parse_url().\nFixes an issue that came up when discussing FR #14001.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14009)"
        },
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +171,4 @@++static int test_http_url_dns(void)+{+    return test_http_url_ok(\"server:65535/pkix\", \"server\", 0);",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L313,316:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -160,4 +198,4 @@ static int test_http_url_ipv4(void) {-    return test_http_url_ok(\"https://1.2.3.4:65535/pkix\", \"1.2.3.4\", 1);+    return test_http_url_ok(\"https://1.2.3.4/p/q\", 1, \"1.2.3.4\", \"443\", \"/p/q\");",
            "commit_date": "2021-01-28 22:10:47+01:00",
            "commit_hash": "7932982b88f5095f60397fe727d27ddf7234f4d6",
            "message": "OSSL_HTTP_parse_url(): Handle any userinfo, query, and fragment components\nNow handle [http[s]://][userinfo@]host[:port][/path][?query][#frag]\nby optionally providing any userinfo, query, and frag components.\nAll usages of this function, which are client-only,\nsilently ignore userinfo and frag components,\nwhile the query component is taken as part of the path.\nUpdate and extend the unit tests and all affected documentation.\nDocument and deprecat OCSP_parse_url().\nFixes an issue that came up when discussing FR #14001.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14009)"
        },
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +176,4 @@++static int test_http_url_ipv4(void)+{+    return test_http_url_ok(\"https://1.2.3.4:65535/pkix\", \"1.2.3.4\", 1);",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L318,321:test/http_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -204,4 +204,4 @@ static int test_http_url_ipv6(void) {-    return test_http_url_ok(\"http://[FF01::101]:6\", 0, \"FF01::101\", \"6\", \"/\");+    return test_http_url_ok(\"http://[FF01::101]:6\", 0, \"[FF01::101]\", \"6\", \"/\");",
            "commit_date": "2021-03-08 09:59:35+01:00",
            "commit_hash": "231837911980ff55a661e2509642442435082c90",
            "message": "OSSL_parse_url(): Improve handling of IPv6 addresses\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14630)"
        },
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -165,4 +203,4 @@ static int test_http_url_ipv6(void) {-    return test_http_url_ok(\"http://[FF01::101]:65535/pkix\", \"FF01::101\", 0);+    return test_http_url_ok(\"http://[FF01::101]:6\", 0, \"FF01::101\", \"6\", \"/\");",
            "commit_date": "2021-01-28 22:10:47+01:00",
            "commit_hash": "7932982b88f5095f60397fe727d27ddf7234f4d6",
            "message": "OSSL_HTTP_parse_url(): Handle any userinfo, query, and fragment components\nNow handle [http[s]://][userinfo@]host[:port][/path][?query][#frag]\nby optionally providing any userinfo, query, and frag components.\nAll usages of this function, which are client-only,\nsilently ignore userinfo and frag components,\nwhile the query component is taken as part of the path.\nUpdate and extend the unit tests and all affected documentation.\nDocument and deprecat OCSP_parse_url().\nFixes an issue that came up when discussing FR #14001.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14009)"
        },
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/http_test.c b/test/http_test.c--- a/test/http_test.c+++ b/test/http_test.c@@ -154,0 +181,4 @@++static int test_http_url_ipv6(void)+{+    return test_http_url_ok(\"http://[FF01::101]:65535/pkix\", \"FF01::101\", 0);",
            "commit_date": "2020-09-03 13:32:56+02:00",
            "commit_hash": "d7fcee3b3b5fae674f107c736f8d53610212ce4e",
            "message": "OSSL_HTTP_parse_url(): add optional port number return parameter and strengthen documentation\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/12786)"
        }
    ],
    "git log -L132,154:crypto/srp/srp_vfy.c": [
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/srp/srp_vfy.c b/crypto/srp/srp_vfy.c--- a/crypto/srp/srp_vfy.c+++ b/crypto/srp/srp_vfy.c@@ -59,11 +123,23 @@  */ static int t_tob64(char *dst, const unsigned char *src, int size) {+    unsigned char pad[2] = {0, 0};+    size_t leadz = 0;-    evp_encode_ctx_set_flags(ctx, EVP_ENCODE_CTX_NO_NEWLINES);+    evp_encode_ctx_set_flags(ctx, EVP_ENCODE_CTX_NO_NEWLINES+                                  | EVP_ENCODE_CTX_USE_SRP_ALPHABET);++    /*+     * We pad at the front with zero bytes until the length is a multiple of 3+     * so that EVP_EncodeUpdate/EVP_EncodeFinal does not add any of its own \"=\"+     * padding+     */+    leadz = 3 - (size % 3);+    if (leadz != 3+            && !EVP_EncodeUpdate(ctx, (unsigned char *)dst, &outl, pad,",
            "commit_date": "2018-04-09 15:50:20+01:00",
            "commit_hash": "3fd59700357072c567785a1fb1430a55ef7bd45b",
            "message": "Add support for the SRP base64 alphabet\nHistorically we used to implement standalone base64 code for SRP. This\nwas replaced by commit 3d3f21aa with the standard base64 processing code.\nHowever, the SRP base64 code was designed to be compatible with other SRP\nlibraries (notably libsrp, but also others) that use a variant of standard\nbase64. Specifically a different alphabet is used and no padding '='\ncharacters are used. Instead 0 padding is added to the front of the string.\nBy changing to standard base64 we change the behaviour of the API which may\nimpact interoperability. It also means that SRP verifier files created prior\nto 1.1.1 would not be readable in 1.1.1 and vice versa.\nInstead we expand our standard base64 processing with the capability to be\nable to read and generate the SRP base64 variant.\nReviewed-by: Andy Polyakov <appro@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5925)\nEVP_ENCODE_CTX *ctx = EVP_ENCODE_CTX_new();\nint outl = 0, outl2 = 0;\nif (ctx == NULL)\nreturn 0;\nEVP_EncodeInit(ctx);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/srp/srp_vfy.c b/crypto/srp/srp_vfy.c--- a/crypto/srp/srp_vfy.c+++ b/crypto/srp/srp_vfy.c@@ -43,4 +59,11 @@  */-static void t_tob64(char *dst, const unsigned char *src, int size)+static int t_tob64(char *dst, const unsigned char *src, int size) {-    EVP_EncodeBlock((unsigned char *)dst, src, size);+    EVP_ENCODE_CTX *ctx = EVP_ENCODE_CTX_new();+    int outl = 0, outl2 = 0;++    if (ctx == NULL)+        return 0;++    EVP_EncodeInit(ctx);+    evp_encode_ctx_set_flags(ctx, EVP_ENCODE_CTX_NO_NEWLINES);",
            "commit_date": "2018-04-09 15:06:50+01:00",
            "commit_hash": "c080461448815dab809661080ee5e21417478fb4",
            "message": "Change SRP functions to use EVP_EncodeUpdate/EVP_DecodeUpdate functions\nPreviously they were using EVP_EncodeBlock/EVP_DecodeBlock. These are low\nlevel functions that do not handle padding characters. This was causing\nthe SRP code to fail. One side effect of using EVP_EncodeUpdate is that\nit inserts newlines which is not what we need in SRP so we add a flag to\navoid that.\nReviewed-by: Andy Polyakov <appro@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5925)"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/srp/srp_vfy.c b/crypto/srp/srp_vfy.c--- a/crypto/srp/srp_vfy.c+++ b/crypto/srp/srp_vfy.c@@ -93,49 +38,4 @@  */-static char *t_tob64(char *dst, const unsigned char *src, int size)+static void t_tob64(char *dst, const unsigned char *src, int size) {-    int c, pos = size % 3;-    unsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;-    char *olddst = dst;--    switch (pos) {-    case 1:-        b2 = src[0];-        break;-    case 2:-        b1 = src[0];-        b2 = src[1];-        break;-    }--    while (1) {-        c = (b0 & 0xfc) >> 2;-        if (notleading || c != 0) {-            *dst++ = b64table[c];-            notleading = 1;-        }-        c = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);-        if (notleading || c != 0) {-            *dst++ = b64table[c];-            notleading = 1;-        }-        c = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);-        if (notleading || c != 0) {-            *dst++ = b64table[c];-            notleading = 1;-        }-        c = b2 & 0x3f;-        if (notleading || c != 0) {-            *dst++ = b64table[c];-            notleading = 1;-        }-        if (pos >= size)-            break;-        else {-            b0 = src[pos++];-            b1 = src[pos++];-            b2 = src[pos++];-        }-    }--    *dst++ = '\\0';-    return olddst;+    EVP_EncodeBlock((unsigned char *)dst, src, size);",
            "commit_date": "2017-08-21 12:51:36-04:00",
            "commit_hash": "3d3f21aa976bd0b29fd1d92d96118b8e6a3209bb",
            "message": "Remove custom base64 code.\nUse EVP_EncodeBlock/EVP_DecodeBlock\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4207)"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/srp/srp_vfy.c b/crypto/srp/srp_vfy.c--- a/crypto/srp/srp_vfy.c+++ b/crypto/srp/srp_vfy.c@@ -128,56 +137,49 @@  */ static char *t_tob64(char *dst, const unsigned char *src, int size)-\t{-\tint c, pos = size % 3;-\tunsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;-\tchar *olddst = dst;--\tswitch(pos)-\t\t{-\tcase 1:-\t\tb2 = src[0];-\t\tbreak;-\tcase 2:-\t\tb1 = src[0];-\t\tb2 = src[1];-\t\tbreak;-\t\t}--\twhile(1)-\t\t{-\t\tc = (b0 & 0xfc) >> 2;-\t\tif(notleading || c != 0)-\t\t\t{-\t\t\t*dst++ = b64table[c];-\t\t\tnotleading = 1;-\t\t\t}-\t\tc = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);-\t\tif(notleading || c != 0)-\t\t\t{-\t\t\t*dst++ = b64table[c];-\t\t\tnotleading = 1;-\t\t\t}-\t\tc = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);-\t\tif(notleading || c != 0)-\t\t\t{-\t\t\t*dst++ = b64table[c];-\t\t\tnotleading = 1;-\t\t\t}-\t\tc = b2 & 0x3f;-\t\tif(notleading || c != 0)-\t\t\t{-\t\t\t*dst++ = b64table[c];-\t\t\tnotleading = 1;-\t\t\t}-\t\tif(pos >= size) break;-\t\telse-\t\t\t{-\t\t\tb0 = src[pos++];-\t\t\tb1 = src[pos++];-\t\t\tb2 = src[pos++];-\t\t\t}-\t\t}--\t*dst++ = '\\0';-\treturn olddst;-\t}+{+    int c, pos = size % 3;+    unsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;+    char *olddst = dst;++    switch (pos) {+    case 1:+        b2 = src[0];+        break;+    case 2:+        b1 = src[0];+        b2 = src[1];+        break;+    }++    while (1) {+        c = (b0 & 0xfc) >> 2;+        if (notleading || c != 0) {+            *dst++ = b64table[c];+            notleading = 1;+        }+        c = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);+        if (notleading || c != 0) {+            *dst++ = b64table[c];+            notleading = 1;+        }+        c = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);+        if (notleading || c != 0) {+            *dst++ = b64table[c];+            notleading = 1;+        }+        c = b2 & 0x3f;+        if (notleading || c != 0) {+            *dst++ = b64table[c];+            notleading = 1;+        }+        if (pos >= size)+            break;+        else {+            b0 = src[pos++];+            b1 = src[pos++];+            b2 = src[pos++];+        }+    }++    *dst++ = '\\0';+    return olddst;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/srp/srp_vfy.c b/crypto/srp/srp_vfy.c--- /dev/null+++ b/crypto/srp/srp_vfy.c@@ -0,0 +125,56 @@+ */+static char *t_tob64(char *dst, const unsigned char *src, int size)+\t{+\tint c, pos = size % 3;+\tunsigned char b0 = 0, b1 = 0, b2 = 0, notleading = 0;+\tchar *olddst = dst;++\tswitch(pos)+\t\t{+\tcase 1:+\t\tb2 = src[0];+\t\tbreak;+\tcase 2:+\t\tb1 = src[0];+\t\tb2 = src[1];+\t\tbreak;+\t\t}++\twhile(1)+\t\t{+\t\tc = (b0 & 0xfc) >> 2;+\t\tif(notleading || c != 0)+\t\t\t{+\t\t\t*dst++ = b64table[c];+\t\t\tnotleading = 1;+\t\t\t}+\t\tc = ((b0 & 3) << 4) | ((b1 & 0xf0) >> 4);+\t\tif(notleading || c != 0)+\t\t\t{+\t\t\t*dst++ = b64table[c];+\t\t\tnotleading = 1;+\t\t\t}+\t\tc = ((b1 & 0xf) << 2) | ((b2 & 0xc0) >> 6);+\t\tif(notleading || c != 0)+\t\t\t{+\t\t\t*dst++ = b64table[c];+\t\t\tnotleading = 1;+\t\t\t}+\t\tc = b2 & 0x3f;+\t\tif(notleading || c != 0)+\t\t\t{+\t\t\t*dst++ = b64table[c];+\t\t\tnotleading = 1;+\t\t\t}+\t\tif(pos >= size) break;+\t\telse+\t\t\t{+\t\t\tb0 = src[pos++];+\t\t\tb1 = src[pos++];+\t\t\tb2 = src[pos++];+\t\t\t}+\t\t}++\t*dst++ = '\\0';+\treturn olddst;+\t}",
            "commit_date": "2011-03-12 17:01:19+00:00",
            "commit_hash": "edc032b5e3f3ebb1006a9c89e0ae00504f47966f",
            "message": "Add SRP support."
        }
    ],
    "git log -L27,87:test/afalgtest.c": [
        {
            "author": {
                "email": "bernd.edlinger@hotmail.de",
                "name": "Bernd Edlinger"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -29,78 +27,61 @@-#ifndef OPENSSL_NO_AFALGENG-# include <linux/version.h>-# define K_MAJ   4-# define K_MIN1  1-# define K_MIN2  0-# if LINUX_VERSION_CODE < KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2)-/*- * If we get here then it looks like there is a mismatch between the linux- * headers and the actual kernel version, so we have tried to compile with- * afalg support, but then skipped it in e_afalg.c. As far as this test is- * concerned we behave as if we had been configured without support- */-#  define OPENSSL_NO_AFALGENG-# endif-#endif--#ifndef OPENSSL_NO_AFALGENG static int test_afalg_aes_cbc(int keysize_idx) { #ifdef OSSL_SANITIZE_MEMORY #endif",
            "commit_date": "2021-10-04 19:45:19+02:00",
            "commit_hash": "6f6a5e0c7c41b6b3639e51f435cd98bb3ae061bc",
            "message": "Fix a memory leak in the afalg engine\nFixes: #16743\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16744)\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher;\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nconst unsigned char *enc_result = NULL;\nint encl, encf, decl, decf;\nint ret = 0;\nstatic const unsigned char key[] =\n\"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\"\n\"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\";\nstatic const unsigned char iv[] =\n\"\\x3d\\xaf\\xba\\x42\\x9d\\x9e\\xb4\\x30\\xb4\\x22\\xda\\x80\\x2c\\x9f\\xac\\x41\";\n/* input = \"Single block msg\\n\" 17 Bytes*/\nstatic const unsigned char in[BUFFER_SIZE] =\n\"\\x53\\x69\\x6e\\x67\\x6c\\x65\\x20\\x62\\x6c\\x6f\\x63\\x6b\\x20\\x6d\\x73\\x67\"\n\"\\x0a\";\nstatic const unsigned char encresult_128[BUFFER_SIZE] =\n\"\\xe3\\x53\\x77\\x9c\\x10\\x79\\xae\\xb8\\x27\\x08\\x94\\x2d\\xbe\\x77\\x18\\x1a\"\n\"\\x2d\";\nstatic const unsigned char encresult_192[BUFFER_SIZE] =\n\"\\xf7\\xe4\\x26\\xd1\\xd5\\x4f\\x8f\\x39\\xb1\\x9e\\xe0\\xdf\\x61\\xb9\\xc2\\x55\"\n\"\\xeb\";\nstatic const unsigned char encresult_256[BUFFER_SIZE] =\n\"\\xa0\\x76\\x85\\xfd\\xc1\\x65\\x71\\x9d\\xc7\\xe9\\x13\\x6e\\xae\\x55\\x49\\xb4\"\n\"\\x13\";\n/*\n* Initialise the encryption & decryption buffers to pacify the memory\n* sanitiser.  The sanitiser doesn't know that this memory is modified\n* by the engine, this tells it that all is good.\n*/\nOPENSSL_cleanse(ebuf, sizeof(ebuf));\nOPENSSL_cleanse(dbuf, sizeof(dbuf));\nswitch (keysize_idx) {\ncase 0:\ncipher = EVP_aes_128_cbc();\nenc_result = &encresult_128[0];\nbreak;\ncase 1:\ncipher = EVP_aes_192_cbc();\nenc_result = &encresult_192[0];\nbreak;\ncase 2:\ncipher = EVP_aes_256_cbc();\nenc_result = &encresult_256[0];\nbreak;\ndefault:\ncipher = NULL;\n}\nif (!TEST_ptr(ctx = EVP_CIPHER_CTX_new()))\nreturn 0;\nif (!TEST_true(EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1))\n|| !TEST_true(EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE))\n|| !TEST_true(EVP_CipherFinal_ex(ctx, ebuf + encl, &encf)))"
        },
        {
            "author": {
                "email": "pauli@openssl.org",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -29,66 +29,78 @@ #ifndef OPENSSL_NO_AFALGENG # include <linux/version.h> # define K_MAJ   4 # define K_MIN1  1 # define K_MIN2  0 # if LINUX_VERSION_CODE < KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2) /*  * If we get here then it looks like there is a mismatch between the linux  * headers and the actual kernel version, so we have tried to compile with  * afalg support, but then skipped it in e_afalg.c. As far as this test is  * concerned we behave as if we had been configured without support  */ #  define OPENSSL_NO_AFALGENG # endif #endif #ifndef OPENSSL_NO_AFALGENG static int test_afalg_aes_cbc(int keysize_idx) {-    unsigned char key[] = \"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\"-                          \"\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\"-                          \"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\"-                          \"\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\";-    unsigned char iv[] = \"\\x3d\\xaf\\xba\\x42\\x9d\\x9e\\xb4\\x30\"-                         \"\\xb4\\x22\\xda\\x80\\x2c\\x9f\\xac\\x41\";-    /* input = \"Single block msg\\n\"  17Bytes*/-    unsigned char in[BUFFER_SIZE] = \"\\x53\\x69\\x6e\\x67\\x6c\\x65\\x20\\x62\"-                                    \"\\x6c\\x6f\\x63\\x6b\\x20\\x6d\\x73\\x67\\x0a\";-    unsigned char encresult_128[] = \"\\xe3\\x53\\x77\\x9c\\x10\\x79\\xae\\xb8\"-                                    \"\\x27\\x08\\x94\\x2d\\xbe\\x77\\x18\\x1a\\x2d\";-    unsigned char encresult_192[] = \"\\xf7\\xe4\\x26\\xd1\\xd5\\x4f\\x8f\\x39\"-                                    \"\\xb1\\x9e\\xe0\\xdf\\x61\\xb9\\xc2\\x55\\xeb\";-    unsigned char encresult_256[] = \"\\xa0\\x76\\x85\\xfd\\xc1\\x65\\x71\\x9d\"-                                    \"\\xc7\\xe9\\x13\\x6e\\xae\\x55\\x49\\xb4\\x13\";-    unsigned char *enc_result = NULL;-+    const unsigned char *enc_result = NULL;+    static const unsigned char key[] =+        \"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\"+        \"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\";+    static const unsigned char iv[] =+        \"\\x3d\\xaf\\xba\\x42\\x9d\\x9e\\xb4\\x30\\xb4\\x22\\xda\\x80\\x2c\\x9f\\xac\\x41\";+    /* input = \"Single block msg\\n\" 17 Bytes*/+    static const unsigned char in[BUFFER_SIZE] =+        \"\\x53\\x69\\x6e\\x67\\x6c\\x65\\x20\\x62\\x6c\\x6f\\x63\\x6b\\x20\\x6d\\x73\\x67\"+        \"\\x0a\";+    static const unsigned char encresult_128[BUFFER_SIZE] =+        \"\\xe3\\x53\\x77\\x9c\\x10\\x79\\xae\\xb8\\x27\\x08\\x94\\x2d\\xbe\\x77\\x18\\x1a\"+        \"\\x2d\";+    static const unsigned char encresult_192[BUFFER_SIZE] =+        \"\\xf7\\xe4\\x26\\xd1\\xd5\\x4f\\x8f\\x39\\xb1\\x9e\\xe0\\xdf\\x61\\xb9\\xc2\\x55\"+        \"\\xeb\";+    static const unsigned char encresult_256[BUFFER_SIZE] =+        \"\\xa0\\x76\\x85\\xfd\\xc1\\x65\\x71\\x9d\\xc7\\xe9\\x13\\x6e\\xae\\x55\\x49\\xb4\"+        \"\\x13\";++#ifdef OSSL_SANITIZE_MEMORY+    /*+     * Initialise the encryption & decryption buffers to pacify the memory+     * sanitiser.  The sanitiser doesn't know that this memory is modified+     * by the engine, this tells it that all is good.+     */+    OPENSSL_cleanse(ebuf, sizeof(ebuf));+    OPENSSL_cleanse(dbuf, sizeof(dbuf));+#endif-            || !TEST_true(EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)))+            || !TEST_true(EVP_CipherFinal_ex(ctx, ebuf + encl, &encf)))",
            "commit_date": "2021-06-30 10:21:17+10:00",
            "commit_hash": "514b76917c36836ae4243392e71785f01d8233c9",
            "message": "afalg: add some memory initialisation calls to pacify memory sanitisation.\nThe engine is modifying memory without the sanitiser realising.  By pre-\ninitialising this memory, the sanitiser now thinks that read accesses are okay.\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/15952)\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher;\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nint encl, encf, decl, decf;\nint ret = 0;\nswitch (keysize_idx) {\ncase 0:\ncipher = EVP_aes_128_cbc();\nenc_result = &encresult_128[0];\nbreak;\ncase 1:\ncipher = EVP_aes_192_cbc();\nenc_result = &encresult_192[0];\nbreak;\ncase 2:\ncipher = EVP_aes_256_cbc();\nenc_result = &encresult_256[0];\nbreak;\ndefault:\ncipher = NULL;\n}\nif (!TEST_ptr(ctx = EVP_CIPHER_CTX_new()))\nreturn 0;\nif (!TEST_true(EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1))\n|| !TEST_true(EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE))"
        },
        {
            "author": {
                "email": "lullajd@yahoo.com",
                "name": "JitendraLulla"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -26,66 +26,66 @@ #ifndef OPENSSL_NO_AFALGENG # include <linux/version.h> # define K_MAJ   4 # define K_MIN1  1 # define K_MIN2  0 # if LINUX_VERSION_CODE < KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2) /*  * If we get here then it looks like there is a mismatch between the linux  * headers and the actual kernel version, so we have tried to compile with  * afalg support, but then skipped it in e_afalg.c. As far as this test is  * concerned we behave as if we had been configured without support  */ #  define OPENSSL_NO_AFALGENG # endif #endif #ifndef OPENSSL_NO_AFALGENG static int test_afalg_aes_cbc(int keysize_idx) {-    unsigned char *enc_result;+    unsigned char *enc_result = NULL;",
            "commit_date": "2017-11-15 06:03:07+05:30",
            "commit_hash": "a3d7fd2837ab7341e58862df95af8532f23d4d51",
            "message": "fix  --strict-warnings\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4717)\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher;\nunsigned char key[] = \"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\"\n\"\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\"\n\"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\"\n\"\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\";\nunsigned char iv[] = \"\\x3d\\xaf\\xba\\x42\\x9d\\x9e\\xb4\\x30\"\n\"\\xb4\\x22\\xda\\x80\\x2c\\x9f\\xac\\x41\";\n/* input = \"Single block msg\\n\"  17Bytes*/\nunsigned char in[BUFFER_SIZE] = \"\\x53\\x69\\x6e\\x67\\x6c\\x65\\x20\\x62\"\n\"\\x6c\\x6f\\x63\\x6b\\x20\\x6d\\x73\\x67\\x0a\";\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nunsigned char encresult_128[] = \"\\xe3\\x53\\x77\\x9c\\x10\\x79\\xae\\xb8\"\n\"\\x27\\x08\\x94\\x2d\\xbe\\x77\\x18\\x1a\\x2d\";\nunsigned char encresult_192[] = \"\\xf7\\xe4\\x26\\xd1\\xd5\\x4f\\x8f\\x39\"\n\"\\xb1\\x9e\\xe0\\xdf\\x61\\xb9\\xc2\\x55\\xeb\";\nunsigned char encresult_256[] = \"\\xa0\\x76\\x85\\xfd\\xc1\\x65\\x71\\x9d\"\n\"\\xc7\\xe9\\x13\\x6e\\xae\\x55\\x49\\xb4\\x13\";\nint encl, encf, decl, decf;\nint ret = 0;\nswitch (keysize_idx) {\ncase 0:\ncipher = EVP_aes_128_cbc();\nenc_result = &encresult_128[0];\nbreak;\ncase 1:\ncipher = EVP_aes_192_cbc();\nenc_result = &encresult_192[0];\nbreak;\ncase 2:\ncipher = EVP_aes_256_cbc();\nenc_result = &encresult_256[0];\nbreak;\ndefault:\ncipher = NULL;\n}\nif (!TEST_ptr(ctx = EVP_CIPHER_CTX_new()))\nreturn 0;\nif (!TEST_true(EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1))\n|| !TEST_true(EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE))\n|| !TEST_true(EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)))"
        },
        {
            "author": {
                "email": "lullajd@yahoo.com",
                "name": "JitendraLulla"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -26,40 +26,66 @@ #ifndef OPENSSL_NO_AFALGENG # include <linux/version.h> # define K_MAJ   4 # define K_MIN1  1 # define K_MIN2  0 # if LINUX_VERSION_CODE < KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2) /*  * If we get here then it looks like there is a mismatch between the linux  * headers and the actual kernel version, so we have tried to compile with  * afalg support, but then skipped it in e_afalg.c. As far as this test is  * concerned we behave as if we had been configured without support  */ #  define OPENSSL_NO_AFALGENG # endif #endif #ifndef OPENSSL_NO_AFALGENG-static int test_afalg_aes_128_cbc(void)+static int test_afalg_aes_cbc(int keysize_idx) {-    const EVP_CIPHER *cipher = EVP_aes_128_cbc();-    unsigned char key[] = \"\\x5F\\x4D\\xCC\\x3B\\x5A\\xA7\\x65\\xD6\\-                           \\x1D\\x83\\x27\\xDE\\xB8\\x82\\xCF\\x99\";-    unsigned char iv[] = \"\\x2B\\x95\\x99\\x0A\\x91\\x51\\x37\\x4A\\-                          \\xBD\\x8F\\xF8\\xC5\\xA7\\xA0\\xFE\\x08\";--    unsigned char in[BUFFER_SIZE];+    const EVP_CIPHER *cipher;+    unsigned char key[] = \"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\"+                          \"\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\"+                          \"\\x06\\xa9\\x21\\x40\\x36\\xb8\\xa1\\x5b\"+                          \"\\x51\\x2e\\x03\\xd5\\x34\\x12\\x00\\x06\";+    unsigned char iv[] = \"\\x3d\\xaf\\xba\\x42\\x9d\\x9e\\xb4\\x30\"+                         \"\\xb4\\x22\\xda\\x80\\x2c\\x9f\\xac\\x41\";+    /* input = \"Single block msg\\n\"  17Bytes*/+    unsigned char in[BUFFER_SIZE] = \"\\x53\\x69\\x6e\\x67\\x6c\\x65\\x20\\x62\"+                                    \"\\x6c\\x6f\\x63\\x6b\\x20\\x6d\\x73\\x67\\x0a\";+    unsigned char encresult_128[] = \"\\xe3\\x53\\x77\\x9c\\x10\\x79\\xae\\xb8\"+                                    \"\\x27\\x08\\x94\\x2d\\xbe\\x77\\x18\\x1a\\x2d\";+    unsigned char encresult_192[] = \"\\xf7\\xe4\\x26\\xd1\\xd5\\x4f\\x8f\\x39\"+                                    \"\\xb1\\x9e\\xe0\\xdf\\x61\\xb9\\xc2\\x55\\xeb\";+    unsigned char encresult_256[] = \"\\xa0\\x76\\x85\\xfd\\xc1\\x65\\x71\\x9d\"+                                    \"\\xc7\\xe9\\x13\\x6e\\xae\\x55\\x49\\xb4\\x13\";+    unsigned char *enc_result;++    switch (keysize_idx) {+        case 0:+            cipher = EVP_aes_128_cbc();+            enc_result = &encresult_128[0];+            break;+        case 1:+            cipher = EVP_aes_192_cbc();+            enc_result = &encresult_192[0];+            break;+        case 2:+            cipher = EVP_aes_256_cbc();+            enc_result = &encresult_256[0];+            break;+        default:+            cipher = NULL;+    }-    RAND_bytes(in, BUFFER_SIZE);",
            "commit_date": "2017-11-11 12:01:58+05:30",
            "commit_hash": "49ea0f09833fb526a12f9402fa2fcf0f4b735d5e",
            "message": "extending afalg with aes-cbc-192/256, afalgtest.c also updated accordingly. comments from matt, Stephen considered\nfix  indentation, remove printf from afalgtest.c\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4717)\nEVP_CIPHER_CTX *ctx;\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nint encl, encf, decl, decf;\nint ret = 0;\nif (!TEST_ptr(ctx = EVP_CIPHER_CTX_new()))\nreturn 0;\nif (!TEST_true(EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1))\n|| !TEST_true(EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE))\n|| !TEST_true(EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)))"
        },
        {
            "author": {
                "email": "git@bitsofnetworks.org",
                "name": "Baptiste Jonglez"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -26,40 +26,40 @@ #ifndef OPENSSL_NO_AFALGENG # include <linux/version.h> # define K_MAJ   4 # define K_MIN1  1 # define K_MIN2  0-# if LINUX_VERSION_CODE <= KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2)+# if LINUX_VERSION_CODE < KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2) /*  * If we get here then it looks like there is a mismatch between the linux  * headers and the actual kernel version, so we have tried to compile with  * afalg support, but then skipped it in e_afalg.c. As far as this test is  * concerned we behave as if we had been configured without support  */ #  define OPENSSL_NO_AFALGENG # endif #endif #ifndef OPENSSL_NO_AFALGENG static int test_afalg_aes_128_cbc(void) {",
            "commit_date": "2017-10-30 11:38:09+01:00",
            "commit_hash": "3ba70235be29cc39df7d859df2894c9de2961019",
            "message": "afalg: Fix kernel version check\nThe check should reject kernel versions < 4.1.0, not <= 4.1.0.\nThe issue was spotted on OpenSUSE 42.1 Leap, since its linux/version.h\nheader advertises 4.1.0.\nCLA: trivial\nFixes: 7f458a48 (\"ALG: Add AFALG engine\")\nSigned-off-by: Baptiste Jonglez <git@bitsofnetworks.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4617)\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher = EVP_aes_128_cbc();\nunsigned char key[] = \"\\x5F\\x4D\\xCC\\x3B\\x5A\\xA7\\x65\\xD6\\\n\\x1D\\x83\\x27\\xDE\\xB8\\x82\\xCF\\x99\";\nunsigned char iv[] = \"\\x2B\\x95\\x99\\x0A\\x91\\x51\\x37\\x4A\\\n\\xBD\\x8F\\xF8\\xC5\\xA7\\xA0\\xFE\\x08\";\nunsigned char in[BUFFER_SIZE];\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nint encl, encf, decl, decf;\nint ret = 0;\nif (!TEST_ptr(ctx = EVP_CIPHER_CTX_new()))\nreturn 0;\nRAND_bytes(in, BUFFER_SIZE);\nif (!TEST_true(EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1))\n|| !TEST_true(EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE))\n|| !TEST_true(EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)))"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -13,51 +26,40 @@+ #ifndef OPENSSL_NO_AFALGENG # include <linux/version.h> # define K_MAJ   4 # define K_MIN1  1 # define K_MIN2  0 # if LINUX_VERSION_CODE <= KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2) /*  * If we get here then it looks like there is a mismatch between the linux  * headers and the actual kernel version, so we have tried to compile with  * afalg support, but then skipped it in e_afalg.c. As far as this test is  * concerned we behave as if we had been configured without support  */ #  define OPENSSL_NO_AFALGENG # endif #endif #ifndef OPENSSL_NO_AFALGENG-/* #if 1 */-#include <string.h>-#include <openssl/engine.h>-#include <openssl/evp.h>-#include <openssl/rand.h>-#include \"testutil.h\"--/* Use a buffer size which is not aligned to block size */-#define BUFFER_SIZE     (8 * 1024) - 13--static ENGINE *e;- static int test_afalg_aes_128_cbc(void) {",
            "commit_date": "2017-04-16 09:17:39-04:00",
            "commit_hash": "5c8e9d531ba54d26e4bcbe66710c7c75bf0fc4e9",
            "message": "[squash]Build works with/out NO_ENGINE and NO_AFALG\nReviewed-by: Andy Polyakov <appro@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3229)\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher = EVP_aes_128_cbc();\nunsigned char key[] = \"\\x5F\\x4D\\xCC\\x3B\\x5A\\xA7\\x65\\xD6\\\n\\x1D\\x83\\x27\\xDE\\xB8\\x82\\xCF\\x99\";\nunsigned char iv[] = \"\\x2B\\x95\\x99\\x0A\\x91\\x51\\x37\\x4A\\\n\\xBD\\x8F\\xF8\\xC5\\xA7\\xA0\\xFE\\x08\";\nunsigned char in[BUFFER_SIZE];\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nint encl, encf, decl, decf;\nint ret = 0;\nif (!TEST_ptr(ctx = EVP_CIPHER_CTX_new()))\nreturn 0;\nRAND_bytes(in, BUFFER_SIZE);\nif (!TEST_true(EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1))\n|| !TEST_true(EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE))\n|| !TEST_true(EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)))"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -13,51 +13,51 @@ #ifndef OPENSSL_NO_AFALGENG # include <linux/version.h> # define K_MAJ   4 # define K_MIN1  1 # define K_MIN2  0 # if LINUX_VERSION_CODE <= KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2) /*  * If we get here then it looks like there is a mismatch between the linux  * headers and the actual kernel version, so we have tried to compile with  * afalg support, but then skipped it in e_afalg.c. As far as this test is  * concerned we behave as if we had been configured without support  */ #  define OPENSSL_NO_AFALGENG # endif #endif #ifndef OPENSSL_NO_AFALGENG+/* #if 1 */ #include <string.h> #include <openssl/engine.h> #include <openssl/evp.h> #include <openssl/rand.h>+#include \"testutil.h\" /* Use a buffer size which is not aligned to block size */ #define BUFFER_SIZE     (8 * 1024) - 13-static int test_afalg_aes_128_cbc(ENGINE *e)+static ENGINE *e;++static int test_afalg_aes_128_cbc(void) {-    unsigned int status = 0;+    int ret = 0;-    ctx = EVP_CIPHER_CTX_new();-    if (ctx == NULL) {-        fprintf(stderr, \"%s() failed to allocate ctx\\n\", __func__);-        return 0;-    }+    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new()))+            return 0;-    if (       !EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1)-            || !EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE)-            || !EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)) {-        fprintf(stderr, \"%s() failed encryption\\n\", __func__);+    if (!TEST_true(EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1))+            || !TEST_true(EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE))+            || !TEST_true(EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)))",
            "commit_date": "2017-04-14 20:32:20-04:00",
            "commit_hash": "529243992bcfbb9ac9aade69451eb2c663739c04",
            "message": "Convert afalgtest\nReviewed-by: Andy Polyakov <appro@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3229)\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher = EVP_aes_128_cbc();\nunsigned char key[] = \"\\x5F\\x4D\\xCC\\x3B\\x5A\\xA7\\x65\\xD6\\\n\\x1D\\x83\\x27\\xDE\\xB8\\x82\\xCF\\x99\";\nunsigned char iv[] = \"\\x2B\\x95\\x99\\x0A\\x91\\x51\\x37\\x4A\\\n\\xBD\\x8F\\xF8\\xC5\\xA7\\xA0\\xFE\\x08\";\nunsigned char in[BUFFER_SIZE];\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nint encl, encf, decl, decf;\nRAND_bytes(in, BUFFER_SIZE);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -57,35 +57,51 @@ #ifndef OPENSSL_NO_AFALGENG+# include <linux/version.h>+# define K_MAJ   4+# define K_MIN1  1+# define K_MIN2  0+# if LINUX_VERSION_CODE <= KERNEL_VERSION(K_MAJ, K_MIN1, K_MIN2)+/*+ * If we get here then it looks like there is a mismatch between the linux+ * headers and the actual kernel version, so we have tried to compile with+ * afalg support, but then skipped it in e_afalg.c. As far as this test is+ * concerned we behave as if we had been configured without support+ */+#  define OPENSSL_NO_AFALGENG+# endif+#endif++#ifndef OPENSSL_NO_AFALGENG #include <string.h> #include <openssl/engine.h> #include <openssl/evp.h> #include <openssl/rand.h> /* Use a buffer size which is not aligned to block size */ #define BUFFER_SIZE     (8 * 1024) - 13 static int test_afalg_aes_128_cbc(ENGINE *e) {",
            "commit_date": "2016-04-13 23:26:56+01:00",
            "commit_hash": "627537ddf3792249df22fc0e33487ca62c6b7be1",
            "message": "Fix AFALG kernel and headers mismatch problem\nDuring Configure we attempt to check the kernel version of this platform\nto see whether we can compile the AFALG engine. If the kernel version\nlooks recent enough then we enable AFALG. However when we compile\ne_afalg.c we check the version of the linux headers. If there is a\nmismatch between the linux headers and the currently running kernel then\nwe don't compile the AFLAG engine and continue. This was causing a link\nerror.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher = EVP_aes_128_cbc();\nunsigned char key[] = \"\\x5F\\x4D\\xCC\\x3B\\x5A\\xA7\\x65\\xD6\\\n\\x1D\\x83\\x27\\xDE\\xB8\\x82\\xCF\\x99\";\nunsigned char iv[] = \"\\x2B\\x95\\x99\\x0A\\x91\\x51\\x37\\x4A\\\n\\xBD\\x8F\\xF8\\xC5\\xA7\\xA0\\xFE\\x08\";\nunsigned char in[BUFFER_SIZE];\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nint encl, encf, decl, decf;\nunsigned int status = 0;\nctx = EVP_CIPHER_CTX_new();\nif (ctx == NULL) {\nfprintf(stderr, \"%s() failed to allocate ctx\\n\", __func__);\nreturn 0;\n}\nRAND_bytes(in, BUFFER_SIZE);\nif (       !EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1)\n|| !EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE)\n|| !EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)) {\nfprintf(stderr, \"%s() failed encryption\\n\", __func__);"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -55,36 +57,35 @@+#ifndef OPENSSL_NO_AFALGENG+#include <string.h> #include <openssl/engine.h> #include <openssl/evp.h> #include <openssl/rand.h>-#include <string.h>--#ifndef OPENSSL_NO_AFALGENG /* Use a buffer size which is not aligned to block size */ #define BUFFER_SIZE     (8 * 1024) - 13 static int test_afalg_aes_128_cbc(ENGINE *e) {",
            "commit_date": "2016-03-14 12:21:44+01:00",
            "commit_hash": "c91a0a8343a22b5e4dff45ecfdee2eae8ab8a504",
            "message": "Disable afalg when engine is disabled.\nAlso make it possible to disable afalg separately.\nwe still need to update config again\nReviewed-by: Richard Levitte <levitte@openssl.org>\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher = EVP_aes_128_cbc();\nunsigned char key[] = \"\\x5F\\x4D\\xCC\\x3B\\x5A\\xA7\\x65\\xD6\\\n\\x1D\\x83\\x27\\xDE\\xB8\\x82\\xCF\\x99\";\nunsigned char iv[] = \"\\x2B\\x95\\x99\\x0A\\x91\\x51\\x37\\x4A\\\n\\xBD\\x8F\\xF8\\xC5\\xA7\\xA0\\xFE\\x08\";\nunsigned char in[BUFFER_SIZE];\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nint encl, encf, decl, decf;\nunsigned int status = 0;\nctx = EVP_CIPHER_CTX_new();\nif (ctx == NULL) {\nfprintf(stderr, \"%s() failed to allocate ctx\\n\", __func__);\nreturn 0;\n}\nRAND_bytes(in, BUFFER_SIZE);\nif (       !EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1)\n|| !EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE)\n|| !EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)) {\nfprintf(stderr, \"%s() failed encryption\\n\", __func__);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -55,37 +55,36 @@ #include <openssl/engine.h> #include <openssl/evp.h> #include <openssl/rand.h> #include <string.h> #ifndef OPENSSL_NO_AFALGENG /* Use a buffer size which is not aligned to block size */ #define BUFFER_SIZE     (8 * 1024) - 13 static int test_afalg_aes_128_cbc(ENGINE *e) {-    EVP_CIPHER_CTX_init(ctx);",
            "commit_date": "2016-03-10 09:18:50+00:00",
            "commit_hash": "0f1d814c2313e2b844d611625e9676d00aa404fb",
            "message": "No need to call EVP_CIPHER_CTX_init after EVP_CIPHER_CTX_new\nThe afalgtest was unnecessarily initing an EVP_CIPHER_CTX. It is not\nneeded and is deprecated.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher = EVP_aes_128_cbc();\nunsigned char key[] = \"\\x5F\\x4D\\xCC\\x3B\\x5A\\xA7\\x65\\xD6\\\n\\x1D\\x83\\x27\\xDE\\xB8\\x82\\xCF\\x99\";\nunsigned char iv[] = \"\\x2B\\x95\\x99\\x0A\\x91\\x51\\x37\\x4A\\\n\\xBD\\x8F\\xF8\\xC5\\xA7\\xA0\\xFE\\x08\";\nunsigned char in[BUFFER_SIZE];\nunsigned char ebuf[BUFFER_SIZE + 32];\nunsigned char dbuf[BUFFER_SIZE + 32];\nint encl, encf, decl, decf;\nunsigned int status = 0;\nctx = EVP_CIPHER_CTX_new();\nif (ctx == NULL) {\nfprintf(stderr, \"%s() failed to allocate ctx\\n\", __func__);\nreturn 0;\n}\nRAND_bytes(in, BUFFER_SIZE);\nif (       !EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1)\n|| !EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE)\n|| !EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)) {\nfprintf(stderr, \"%s() failed encryption\\n\", __func__);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- a/test/afalgtest.c+++ b/test/afalgtest.c@@ -55,34 +55,37 @@ #include <openssl/engine.h> #include <openssl/evp.h> #include <openssl/rand.h> #include <string.h> #ifndef OPENSSL_NO_AFALGENG++/* Use a buffer size which is not aligned to block size */+#define BUFFER_SIZE     (8 * 1024) - 13+ static int test_afalg_aes_128_cbc(ENGINE *e) {-    /* Use a buffer which is not aligned to block size */-    const int bufsz = (8 * 1024) - 13;-    unsigned char in[bufsz];-    unsigned char ebuf[bufsz + 32];-    unsigned char dbuf[bufsz + 32];++    unsigned char in[BUFFER_SIZE];+    unsigned char ebuf[BUFFER_SIZE + 32];+    unsigned char dbuf[BUFFER_SIZE + 32];-    RAND_bytes(in, bufsz);+    RAND_bytes(in, BUFFER_SIZE);-            || !EVP_CipherUpdate(ctx, ebuf, &encl, in, bufsz)+            || !EVP_CipherUpdate(ctx, ebuf, &encl, in, BUFFER_SIZE)",
            "commit_date": "2016-03-07 12:36:20+00:00",
            "commit_hash": "a193388811db7e842ed7d1966bbe2552095b26cc",
            "message": "Fix some clang warnings\nThe af_alg engine and associated test were creating warnings when compiled\nwith clang. This fixes it.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nEVP_CIPHER_CTX *ctx;\nconst EVP_CIPHER *cipher = EVP_aes_128_cbc();\nunsigned char key[] = \"\\x5F\\x4D\\xCC\\x3B\\x5A\\xA7\\x65\\xD6\\\n\\x1D\\x83\\x27\\xDE\\xB8\\x82\\xCF\\x99\";\nunsigned char iv[] = \"\\x2B\\x95\\x99\\x0A\\x91\\x51\\x37\\x4A\\\n\\xBD\\x8F\\xF8\\xC5\\xA7\\xA0\\xFE\\x08\";\nint encl, encf, decl, decf;\nunsigned int status = 0;\nctx = EVP_CIPHER_CTX_new();\nif (ctx == NULL) {\nfprintf(stderr, \"%s() failed to allocate ctx\\n\", __func__);\nreturn 0;\n}\nEVP_CIPHER_CTX_init(ctx);\nif (       !EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1)\n|| !EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)) {\nfprintf(stderr, \"%s() failed encryption\\n\", __func__);"
        },
        {
            "author": {
                "email": "catriona.lucey@intel.com",
                "name": "clucey"
            },
            "changes": "diff --git a/test/afalgtest.c b/test/afalgtest.c--- /dev/null+++ b/test/afalgtest.c@@ -0,0 +55,34 @@+#include <openssl/engine.h>+#include <openssl/evp.h>+#include <openssl/rand.h>+#include <string.h>++#ifndef OPENSSL_NO_AFALGENG+static int test_afalg_aes_128_cbc(ENGINE *e)+{+    EVP_CIPHER_CTX *ctx;+    const EVP_CIPHER *cipher = EVP_aes_128_cbc();+    unsigned char key[] = \"\\x5F\\x4D\\xCC\\x3B\\x5A\\xA7\\x65\\xD6\\+                           \\x1D\\x83\\x27\\xDE\\xB8\\x82\\xCF\\x99\";+    unsigned char iv[] = \"\\x2B\\x95\\x99\\x0A\\x91\\x51\\x37\\x4A\\+                          \\xBD\\x8F\\xF8\\xC5\\xA7\\xA0\\xFE\\x08\";+    /* Use a buffer which is not aligned to block size */+    const int bufsz = (8 * 1024) - 13;+    unsigned char in[bufsz];+    unsigned char ebuf[bufsz + 32];+    unsigned char dbuf[bufsz + 32];+    int encl, encf, decl, decf;+    unsigned int status = 0;++    ctx = EVP_CIPHER_CTX_new();+    if (ctx == NULL) {+        fprintf(stderr, \"%s() failed to allocate ctx\\n\", __func__);+        return 0;+    }+    EVP_CIPHER_CTX_init(ctx);+    RAND_bytes(in, bufsz);++    if (       !EVP_CipherInit_ex(ctx, cipher, e, key, iv, 1)+            || !EVP_CipherUpdate(ctx, ebuf, &encl, in, bufsz)+            || !EVP_CipherFinal_ex(ctx, ebuf+encl, &encf)) {+        fprintf(stderr, \"%s() failed encryption\\n\", __func__);",
            "commit_date": "2016-03-03 05:56:10+00:00",
            "commit_hash": "d245844010bb4ae9867d43edd39782280cc671f8",
            "message": "Adding afalg test\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>"
        }
    ],
    "git log -L35,71:test/provider_test.c": [
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- a/test/provider_test.c+++ b/test/provider_test.c@@ -29,36 +35,37 @@+ static int test_provider(OSSL_LIB_CTX **libctx, const char *name, {",
            "commit_date": "2021-05-11 16:50:27+01:00",
            "commit_hash": "b1c053acdaaee5e653949932f9999370edfc64db",
            "message": "Ensure mirroring of properties works for subsequent updates\nIf the global properties are updated after a provider with a child libctx\nhas already started we need to make sure those updates are mirrored in\nthat child.\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15242)\nOSSL_PROVIDER *legacy)\nOSSL_PROVIDER *prov = NULL;\nconst char *greeting = NULL;\nchar expected_greeting[256];\nint ok = 0;\nlong err;\nint dolegacycheck = (legacy != NULL);\nOSSL_PROVIDER *deflt = NULL, *base = NULL;\nBIO_snprintf(expected_greeting, sizeof(expected_greeting),\n\"Hello OpenSSL %.20s, greetings from %s!\",\nOPENSSL_VERSION_STR, name);\n/*\n* We set properties that we know the providers we are using don't have.\n* This should mean that the p_test provider will fail any fetches - which\n* is something we test inside the provider.\n*/\nEVP_set_default_properties(*libctx, \"fips=yes\");\n/*\n* Check that it is possible to have a built-in provider mirrored in\n* a child lib ctx.\n*/\nif (!TEST_ptr(base = OSSL_PROVIDER_load(*libctx, \"base\")))\ngoto err;\nif (!TEST_ptr(prov = OSSL_PROVIDER_load(*libctx, name)))\ngoto err;\n/*\n* Once the provider is loaded we clear the default properties and fetches\n* should start working again.\n*/\nEVP_set_default_properties(*libctx, \"\");"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- a/test/provider_test.c+++ b/test/provider_test.c@@ -29,23 +29,36 @@ static int test_provider(OSSL_LIB_CTX **libctx, const char *name, {++    /*+     * We set properties that we know the providers we are using don't have.+     * This should mean that the p_test provider will fail any fetches - which+     * is something we test inside the provider.+     */+    EVP_set_default_properties(*libctx, \"fips=yes\");-        * Check that it is possible to have a built-in provider mirrored in-        * a child lib ctx.-        */+     * Check that it is possible to have a built-in provider mirrored in+     * a child lib ctx.+     */++    /*+     * Once the provider is loaded we clear the default properties and fetches+     * should start working again.+     */+    EVP_set_default_properties(*libctx, \"\");",
            "commit_date": "2021-05-11 11:44:43+01:00",
            "commit_hash": "18cb5c31e16ace483e09a3d72d47d675feb898b2",
            "message": "Test that properties are mirrored as we expect\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15242)\nOSSL_PROVIDER *legacy)\nOSSL_PROVIDER *prov = NULL;\nconst char *greeting = NULL;\nchar expected_greeting[256];\nint ok = 0;\nlong err;\nint dolegacycheck = (legacy != NULL);\nOSSL_PROVIDER *deflt = NULL, *base = NULL;\nBIO_snprintf(expected_greeting, sizeof(expected_greeting),\n\"Hello OpenSSL %.20s, greetings from %s!\",\nOPENSSL_VERSION_STR, name);\n/*\nif (!TEST_ptr(base = OSSL_PROVIDER_load(*libctx, \"base\")))\ngoto err;\nif (!TEST_ptr(prov = OSSL_PROVIDER_load(*libctx, name)))\ngoto err;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- a/test/provider_test.c+++ b/test/provider_test.c@@ -29,16 +29,23 @@ static int test_provider(OSSL_LIB_CTX **libctx, const char *name, {+    OSSL_PROVIDER *deflt = NULL, *base = NULL;+    /*+        * Check that it is possible to have a built-in provider mirrored in+        * a child lib ctx.+        */+    if (!TEST_ptr(base = OSSL_PROVIDER_load(*libctx, \"base\")))+        goto err;",
            "commit_date": "2021-05-04 17:38:10+01:00",
            "commit_hash": "fb9b3a7bce236c96d8db37e52db83997b4cb18db",
            "message": "Add additional testing of child libctx/providers\nAdd a case where a provider explicitly loads a provider into a child\nlibctx where it does not already exist.\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14991)\nOSSL_PROVIDER *legacy)\nOSSL_PROVIDER *prov = NULL;\nconst char *greeting = NULL;\nchar expected_greeting[256];\nint ok = 0;\nlong err;\nint dolegacycheck = (legacy != NULL);\nBIO_snprintf(expected_greeting, sizeof(expected_greeting),\n\"Hello OpenSSL %.20s, greetings from %s!\",\nOPENSSL_VERSION_STR, name);\nif (!TEST_ptr(prov = OSSL_PROVIDER_load(*libctx, name)))\ngoto err;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- a/test/provider_test.c+++ b/test/provider_test.c@@ -29,15 +29,16 @@ static int test_provider(OSSL_LIB_CTX **libctx, const char *name, {+    int dolegacycheck = (legacy != NULL);",
            "commit_date": "2021-04-26 16:00:04+01:00",
            "commit_hash": "3b85bcfa14988cb383d94e5dee16645ce1ad39ed",
            "message": "Add a test to check that child provider callbacks are working\nWrite a test to confirm that if a provider is unloaded/loaded into a\nlibctx then it is similarly unloaded/loaded from any child libctxs.\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14991)\nOSSL_PROVIDER *legacy)\nOSSL_PROVIDER *prov = NULL;\nconst char *greeting = NULL;\nchar expected_greeting[256];\nint ok = 0;\nlong err;\nBIO_snprintf(expected_greeting, sizeof(expected_greeting),\n\"Hello OpenSSL %.20s, greetings from %s!\",\nOPENSSL_VERSION_STR, name);\nif (!TEST_ptr(prov = OSSL_PROVIDER_load(*libctx, name)))\ngoto err;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- a/test/provider_test.c+++ b/test/provider_test.c@@ -22,14 +29,15 @@-static int test_provider(OSSL_LIB_CTX **libctx, const char *name)+static int test_provider(OSSL_LIB_CTX **libctx, const char *name,+                         OSSL_PROVIDER *legacy) {-    if (!TEST_ptr(prov = OSSL_PROVIDER_load(*libctx, name))-            || !TEST_true(OSSL_PROVIDER_get_params(prov, greeting_request))+    if (!TEST_ptr(prov = OSSL_PROVIDER_load(*libctx, name)))+        goto err;",
            "commit_date": "2021-04-22 15:58:50+01:00",
            "commit_hash": "5442611dffed2c345ef83d494f2ef7ffb9cf3883",
            "message": "Add a test for OSSL_LIB_CTX_new_child()\nCheck that we can create such a libctx and usable providers are loaded\ninto it.\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14991)\nOSSL_PROVIDER *prov = NULL;\nconst char *greeting = NULL;\nchar expected_greeting[256];\nint ok = 0;\nlong err;\nBIO_snprintf(expected_greeting, sizeof(expected_greeting),\n\"Hello OpenSSL %.20s, greetings from %s!\",\nOPENSSL_VERSION_STR, name);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- a/test/provider_test.c+++ b/test/provider_test.c@@ -22,17 +22,14 @@-static int test_provider(const char *name)+static int test_provider(OSSL_LIB_CTX **libctx, const char *name) {+    int ok = 0;+    long err;-    return-        TEST_ptr(prov = OSSL_PROVIDER_load(NULL, name))-        && TEST_true(OSSL_PROVIDER_get_params(prov, greeting_request))-        && TEST_ptr(greeting = greeting_request[0].data)-        && TEST_size_t_gt(greeting_request[0].data_size, 0)-        && TEST_str_eq(greeting, expected_greeting)-        && TEST_true(OSSL_PROVIDER_unload(prov));+    if (!TEST_ptr(prov = OSSL_PROVIDER_load(*libctx, name))+            || !TEST_true(OSSL_PROVIDER_get_params(prov, greeting_request))",
            "commit_date": "2021-02-16 10:10:26+00:00",
            "commit_hash": "81c15ed00bbe5cb4b864ad9b1fab12a26fa91201",
            "message": "Test errors from a provider can still be accessed after unload\nProviders can create errors that may refer to const strings within the\nprovider module itself. If the provider gets unloaded we need to be sure\nthat we can still access the errors in the error stack.\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14213)\nOSSL_PROVIDER *prov = NULL;\nconst char *greeting = NULL;\nchar expected_greeting[256];\nBIO_snprintf(expected_greeting, sizeof(expected_greeting),\n\"Hello OpenSSL %.20s, greetings from %s!\",\nOPENSSL_VERSION_STR, name);"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- a/test/provider_test.c+++ b/test/provider_test.c@@ -29,17 +29,17 @@ static int test_provider(const char *name) {-             \"Hello OpenSSL %.20s, greetings from %s!\",-             OPENSSL_VERSION_STR, name);+                 \"Hello OpenSSL %.20s, greetings from %s!\",+                 OPENSSL_VERSION_STR, name);",
            "commit_date": "2019-03-26 15:20:22+10:00",
            "commit_hash": "866cc2334c95c8602eb4d018bfc224357c47b511",
            "message": "style nit fix\nReviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8580)\nOSSL_PROVIDER *prov = NULL;\nconst char *greeting = NULL;\nchar expected_greeting[256];\nBIO_snprintf(expected_greeting, sizeof(expected_greeting),\nreturn\nTEST_ptr(prov = OSSL_PROVIDER_load(NULL, name))\n&& TEST_true(OSSL_PROVIDER_get_params(prov, greeting_request))\n&& TEST_ptr(greeting = greeting_request[0].data)\n&& TEST_size_t_gt(greeting_request[0].data_size, 0)\n&& TEST_str_eq(greeting, expected_greeting)\n&& TEST_true(OSSL_PROVIDER_unload(prov));"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- a/test/provider_test.c+++ b/test/provider_test.c@@ -29,17 +29,17 @@ static int test_provider(const char *name) {-    snprintf(expected_greeting, sizeof(expected_greeting),+    BIO_snprintf(expected_greeting, sizeof(expected_greeting),",
            "commit_date": "2019-03-25 11:37:24+10:00",
            "commit_hash": "f4b4574f4bc8b3099c34162332e317bd314e35a1",
            "message": "replaced snprintf with BIO version (for windows builds)\nReviewed-by: Tim Hudson <tjh@openssl.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8571)\nOSSL_PROVIDER *prov = NULL;\nconst char *greeting = NULL;\nchar expected_greeting[256];\n\"Hello OpenSSL %.20s, greetings from %s!\",\nOPENSSL_VERSION_STR, name);\nreturn\nTEST_ptr(prov = OSSL_PROVIDER_load(NULL, name))\n&& TEST_true(OSSL_PROVIDER_get_params(prov, greeting_request))\n&& TEST_ptr(greeting = greeting_request[0].data)\n&& TEST_size_t_gt(greeting_request[0].data_size, 0)\n&& TEST_str_eq(greeting, expected_greeting)\n&& TEST_true(OSSL_PROVIDER_unload(prov));"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- a/test/provider_test.c+++ b/test/provider_test.c@@ -23,17 +23,17 @@ static int test_provider(const char *name) {-        && TEST_ptr(greeting = greeting_request[0].buffer)-        && TEST_size_t_gt(greeting_request[0].buffer_size, 0)+        && TEST_ptr(greeting = greeting_request[0].data)+        && TEST_size_t_gt(greeting_request[0].data_size, 0)",
            "commit_date": "2019-03-11 21:51:01+01:00",
            "commit_hash": "8c4412ed8fe80a8b92549d7e2db1359012074d65",
            "message": "Rename 'buffer' to 'data' in OSSL_PARAM\nThe OSSL_PARAM attribute names |buffer| and |buffer_size| may lead to\nconfusion, as they may make some think that the memory pointed at is\nan intermediate memory are.  This is not generally the case, so we\nrename |buffer| and |buffer_size| to |data| and |data_size|\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/8451)\nOSSL_PROVIDER *prov = NULL;\nconst char *greeting = NULL;\nchar expected_greeting[256];\nsnprintf(expected_greeting, sizeof(expected_greeting),\n\"Hello OpenSSL %.20s, greetings from %s!\",\nOPENSSL_VERSION_STR, name);\nreturn\nTEST_ptr(prov = OSSL_PROVIDER_load(NULL, name))\n&& TEST_true(OSSL_PROVIDER_get_params(prov, greeting_request))\n&& TEST_str_eq(greeting, expected_greeting)\n&& TEST_true(OSSL_PROVIDER_unload(prov));"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/provider_test.c b/test/provider_test.c--- /dev/null+++ b/test/provider_test.c@@ -0,0 +23,17 @@+static int test_provider(const char *name)+{+    OSSL_PROVIDER *prov = NULL;+    const char *greeting = NULL;+    char expected_greeting[256];++    snprintf(expected_greeting, sizeof(expected_greeting),+             \"Hello OpenSSL %.20s, greetings from %s!\",+             OPENSSL_VERSION_STR, name);++    return+        TEST_ptr(prov = OSSL_PROVIDER_load(NULL, name))+        && TEST_true(OSSL_PROVIDER_get_params(prov, greeting_request))+        && TEST_ptr(greeting = greeting_request[0].buffer)+        && TEST_size_t_gt(greeting_request[0].buffer_size, 0)+        && TEST_str_eq(greeting, expected_greeting)+        && TEST_true(OSSL_PROVIDER_unload(prov));",
            "commit_date": "2019-02-20 22:55:43+01:00",
            "commit_hash": "021a65527735af2ddc063d9300138660e3782a15",
            "message": "Add provider tests\nTwo tests are added, one that tests the internal API, the other tests\nthe public API.  Those two tests both test the same provider, which\nacts both as a built-in provider and as a loadable provider module.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/8287)"
        }
    ],
    "git log -L2755,2790:test/evp_extra_test.c": [
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2061,34 +2105,36 @@ #if !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305) static int test_decrypt_null_chunks(void) {+    EVP_CIPHER *cipher = NULL;-    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())-            || !TEST_true(EVP_EncryptInit_ex(ctx, EVP_chacha20_poly1305(), NULL,+    if (!TEST_ptr(cipher = EVP_CIPHER_fetch(testctx, \"ChaCha20-Poly1305\", testpropq))+            || !TEST_ptr(ctx = EVP_CIPHER_CTX_new())+            || !TEST_true(EVP_EncryptInit_ex(ctx, cipher, NULL,",
            "commit_date": "2021-03-09 20:42:57+10:00",
            "commit_hash": "062490dbd05a205824a239336f6a60bf00a7ca1d",
            "message": "Add testing for non-default library context into evp_extra_test\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14478)\nEVP_CIPHER_CTX* ctx = NULL;\nconst unsigned char key[32] = {\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1\n};\nunsigned char iv[12] = {\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b\n};\nunsigned char msg[] = \"It was the best of times, it was the worst of times\";\nunsigned char ciphertext[80];\nunsigned char plaintext[80];\n/* We initialise tmp to a non zero value on purpose */\nint ctlen, ptlen, tmp = 99;\nint ret = 0;\nconst int enc_offset = 10, dec_offset = 20;\nkey, iv))\n|| !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &ctlen, msg,\nenc_offset))\n/* Deliberate add a zero length update */\n|| !TEST_true(EVP_EncryptUpdate(ctx, ciphertext + ctlen, &tmp, NULL,\n0))\n|| !TEST_int_eq(tmp, 0)\n|| !TEST_true(EVP_EncryptUpdate(ctx, ciphertext + ctlen, &tmp,\nmsg + enc_offset,\nsizeof(msg) - enc_offset))\n|| !TEST_int_eq(ctlen += tmp, sizeof(msg))\n|| !TEST_true(EVP_EncryptFinal(ctx, ciphertext + ctlen, &tmp))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -1349,0 +1349,34 @@+#if !defined(OPENSSL_NO_CHACHA) && !defined(OPENSSL_NO_POLY1305)+static int test_decrypt_null_chunks(void)+{+    EVP_CIPHER_CTX* ctx = NULL;+    const unsigned char key[32] = {+        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,+        0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,+        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1+    };+    unsigned char iv[12] = {+        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b+    };+    unsigned char msg[] = \"It was the best of times, it was the worst of times\";+    unsigned char ciphertext[80];+    unsigned char plaintext[80];+    /* We initialise tmp to a non zero value on purpose */+    int ctlen, ptlen, tmp = 99;+    int ret = 0;+    const int enc_offset = 10, dec_offset = 20;++    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())+            || !TEST_true(EVP_EncryptInit_ex(ctx, EVP_chacha20_poly1305(), NULL,+                                             key, iv))+            || !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &ctlen, msg,+                                            enc_offset))+            /* Deliberate add a zero length update */+            || !TEST_true(EVP_EncryptUpdate(ctx, ciphertext + ctlen, &tmp, NULL,+                                            0))+            || !TEST_int_eq(tmp, 0)+            || !TEST_true(EVP_EncryptUpdate(ctx, ciphertext + ctlen, &tmp,+                                            msg + enc_offset,+                                            sizeof(msg) - enc_offset))+            || !TEST_int_eq(ctlen += tmp, sizeof(msg))+            || !TEST_true(EVP_EncryptFinal(ctx, ciphertext + ctlen, &tmp))",
            "commit_date": "2019-05-31 14:32:55+01:00",
            "commit_hash": "b4be6937f2a80aa48afd1e3de50749874e4ad9b5",
            "message": "Add a test for NULL chunks in encrypt/decrypt\nIssue #8675 describes a problem where calling EVP_DecryptUpdate() with an\nempty chunk causes the result to be different compared to if you do not\nuse an empty chunk. This adds a test for that case.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/10530)"
        }
    ],
    "git log -L3790,3836:test/evp_extra_test.c": [
        {
            "author": {
                "email": "ifranzki@linux.ibm.com",
                "name": "Ingo Franzki"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -3337,0 +3383,47 @@+ */+static int test_evp_updated_iv(int idx)+{+    const EVP_UPDATED_IV_TEST_st *t = &evp_updated_iv_tests[idx];+    int outlen1, outlen2;+    int testresult = 0;+    unsigned char outbuf[1024];+    EVP_CIPHER_CTX *ctx = NULL;+    EVP_CIPHER *type = NULL;+    unsigned char updated_iv[EVP_MAX_IV_LENGTH];+    int iv_len;+    char *errmsg = NULL;++    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())) {+        errmsg = \"CTX_ALLOC\";+        goto err;+    }+    if ((type = EVP_CIPHER_fetch(testctx, t->cipher, testpropq)) == NULL) {+        TEST_info(\"cipher %s not supported, skipping\", t->cipher);+        goto ok;+    }++    if (!TEST_true(EVP_CipherInit_ex(ctx, type, NULL, kCFBDefaultKey, iCFBIV, t->enc))) {+        errmsg = \"CIPHER_INIT\";+        goto err;+    }+    if (!TEST_true(EVP_CIPHER_CTX_set_padding(ctx, 0))) {+        errmsg = \"PADDING\";+        goto err;+    }+    if (!TEST_true(EVP_CipherUpdate(ctx, outbuf, &outlen1, cfbPlaintext, sizeof(cfbPlaintext)))) {+        errmsg = \"CIPHER_UPDATE\";+        goto err;+    }+    if (!TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, updated_iv, sizeof(updated_iv)))) {+        errmsg = \"CIPHER_CTX_GET_UPDATED_IV\";+        goto err;+    }+    if (!TEST_true(iv_len = EVP_CIPHER_CTX_get_iv_length(ctx))) {+        errmsg = \"CIPHER_CTX_GET_IV_LEN\";+        goto err;+    }+    if (!TEST_mem_ne(iCFBIV, sizeof(iCFBIV), updated_iv, iv_len)) {+        errmsg = \"IV_NOT_UPDATED\";+        goto err;+    }+    if (!TEST_true(EVP_CipherFinal_ex(ctx, outbuf + outlen1, &outlen2))) {",
            "commit_date": "2021-08-11 13:04:52+02:00",
            "commit_hash": "f17e52778f1f7b2703de73e488e7f9229c11dce4",
            "message": "Test EVP Cipher updating the context's IV\nEnsure that an EVP_CipherUpdate operation updates the context's\nIV for AES CBC, CFB, OFB, and CTR. An application can get the\nupdated IV via EVP_CIPHER_CTX_iv().\nThe s390x implementation of the CFB and OFB ciphers in e_aes.c did not\nupdate the IV in the context, but only within its s390x specific\ncontext data.\nSigned-off-by: Ingo Franzki <ifranzki@linux.ibm.com>\nReviewed-by: Patrick Steuer <patrick.steuer@de.ibm.com>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16291)"
        }
    ],
    "git log -L3189,3273:test/evp_extra_test.c": [
        {
            "author": {
                "email": "xkernel.wang@foxmail.com",
                "name": "x2018"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2987,85 +2987,85 @@ #ifndef OPENSSL_NO_DES static int test_evp_iv_des(int idx) {-    switch(idx) {+    switch (idx) {",
            "commit_date": "2021-10-26 15:16:18+08:00",
            "commit_hash": "1287dabd0b23326be491125698dd982e4ae28887",
            "message": "fix some code with obvious wrong coding style\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16918)\nint ret = 0;\nEVP_CIPHER_CTX *ctx = NULL;\nstatic const unsigned char key[24] = {\n0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,\n0xf1, 0xe0, 0xd3, 0xc2, 0xb5, 0xa4, 0x97, 0x86,\n0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10\n};\nstatic const unsigned char init_iv[8] = {\n0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10\n};\nstatic const unsigned char msg[] = { 1, 2, 3, 4, 5, 6, 7, 8,\n9, 10, 11, 12, 13, 14, 15, 16 };\nunsigned char ciphertext[32], oiv[8], iv[8];\nunsigned const char *ref_iv;\nstatic const unsigned char cbc_state_des[8] = {\n0x4f, 0xa3, 0x85, 0xcd, 0x8b, 0xf3, 0x06, 0x2a\n};\nstatic const unsigned char cbc_state_3des[8] = {\n0x35, 0x27, 0x7d, 0x65, 0x6c, 0xfb, 0x50, 0xd9\n};\nstatic const unsigned char ofb_state_des[8] = {\n0xa7, 0x0d, 0x1d, 0x45, 0xf9, 0x96, 0x3f, 0x2c\n};\nstatic const unsigned char ofb_state_3des[8] = {\n0xab, 0x16, 0x24, 0xbb, 0x5b, 0xac, 0xed, 0x5e\n};\nstatic const unsigned char cfb_state_des[8] = {\n0x91, 0xeb, 0x6d, 0x29, 0x4b, 0x08, 0xbd, 0x73\n};\nstatic const unsigned char cfb_state_3des[8] = {\n0x34, 0xdd, 0xfb, 0x47, 0x33, 0x1c, 0x61, 0xf7\n};\nint len = sizeof(ciphertext);\nsize_t ivlen, ref_len;\nEVP_CIPHER *type = NULL;\nif (lgcyprov == NULL && idx < 3)\nreturn TEST_skip(\"Test requires legacy provider to be loaded\");\ncase 0:\ntype = EVP_CIPHER_fetch(testctx, \"des-cbc\", testpropq);\nref_iv = cbc_state_des;\nref_len = sizeof(cbc_state_des);\nbreak;\ncase 1:\ntype = EVP_CIPHER_fetch(testctx, \"des-ofb\", testpropq);\nref_iv = ofb_state_des;\nref_len = sizeof(ofb_state_des);\nbreak;\ncase 2:\ntype = EVP_CIPHER_fetch(testctx, \"des-cfb\", testpropq);\nref_iv = cfb_state_des;\nref_len = sizeof(cfb_state_des);\nbreak;\ncase 3:\ntype = EVP_CIPHER_fetch(testctx, \"des-ede3-cbc\", testpropq);\nref_iv = cbc_state_3des;\nref_len = sizeof(cbc_state_3des);\nbreak;\ncase 4:\ntype = EVP_CIPHER_fetch(testctx, \"des-ede3-ofb\", testpropq);\nref_iv = ofb_state_3des;\nref_len = sizeof(ofb_state_3des);\nbreak;\ncase 5:\ntype = EVP_CIPHER_fetch(testctx, \"des-ede3-cfb\", testpropq);\nref_iv = cfb_state_3des;\nref_len = sizeof(cfb_state_3des);\nbreak;\ndefault:\nreturn 0;\n}\nif (!TEST_ptr(type)\n|| !TEST_ptr((ctx = EVP_CIPHER_CTX_new()))\n|| !TEST_true(EVP_EncryptInit_ex(ctx, type, NULL, key, init_iv))\n|| !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &len, msg,\n(int)sizeof(msg)))\n|| !TEST_true(EVP_CIPHER_CTX_get_original_iv(ctx, oiv, sizeof(oiv)))\n|| !TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))\n|| !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &len)))"
        },
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2587,0 +2587,85 @@+#ifndef OPENSSL_NO_DES+static int test_evp_iv_des(int idx)+{+    int ret = 0;+    EVP_CIPHER_CTX *ctx = NULL;+    static const unsigned char key[24] = {+        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,+        0xf1, 0xe0, 0xd3, 0xc2, 0xb5, 0xa4, 0x97, 0x86,+        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10+    };+    static const unsigned char init_iv[8] = {+        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10+    };+    static const unsigned char msg[] = { 1, 2, 3, 4, 5, 6, 7, 8,+                                         9, 10, 11, 12, 13, 14, 15, 16 };+    unsigned char ciphertext[32], oiv[8], iv[8];+    unsigned const char *ref_iv;+    static const unsigned char cbc_state_des[8] = {+        0x4f, 0xa3, 0x85, 0xcd, 0x8b, 0xf3, 0x06, 0x2a+    };+    static const unsigned char cbc_state_3des[8] = {+        0x35, 0x27, 0x7d, 0x65, 0x6c, 0xfb, 0x50, 0xd9+    };+    static const unsigned char ofb_state_des[8] = {+        0xa7, 0x0d, 0x1d, 0x45, 0xf9, 0x96, 0x3f, 0x2c+    };+    static const unsigned char ofb_state_3des[8] = {+        0xab, 0x16, 0x24, 0xbb, 0x5b, 0xac, 0xed, 0x5e+    };+    static const unsigned char cfb_state_des[8] = {+        0x91, 0xeb, 0x6d, 0x29, 0x4b, 0x08, 0xbd, 0x73+    };+    static const unsigned char cfb_state_3des[8] = {+        0x34, 0xdd, 0xfb, 0x47, 0x33, 0x1c, 0x61, 0xf7+    };+    int len = sizeof(ciphertext);+    size_t ivlen, ref_len;+    EVP_CIPHER *type = NULL;++    if (lgcyprov == NULL && idx < 3)+        return TEST_skip(\"Test requires legacy provider to be loaded\");++    switch(idx) {+    case 0:+        type = EVP_CIPHER_fetch(testctx, \"des-cbc\", testpropq);+        ref_iv = cbc_state_des;+        ref_len = sizeof(cbc_state_des);+        break;+    case 1:+        type = EVP_CIPHER_fetch(testctx, \"des-ofb\", testpropq);+        ref_iv = ofb_state_des;+        ref_len = sizeof(ofb_state_des);+        break;+    case 2:+        type = EVP_CIPHER_fetch(testctx, \"des-cfb\", testpropq);+        ref_iv = cfb_state_des;+        ref_len = sizeof(cfb_state_des);+        break;+    case 3:+        type = EVP_CIPHER_fetch(testctx, \"des-ede3-cbc\", testpropq);+        ref_iv = cbc_state_3des;+        ref_len = sizeof(cbc_state_3des);+        break;+    case 4:+        type = EVP_CIPHER_fetch(testctx, \"des-ede3-ofb\", testpropq);+        ref_iv = ofb_state_3des;+        ref_len = sizeof(ofb_state_3des);+        break;+    case 5:+        type = EVP_CIPHER_fetch(testctx, \"des-ede3-cfb\", testpropq);+        ref_iv = cfb_state_3des;+        ref_len = sizeof(cfb_state_3des);+        break;+    default:+        return 0;+    }++    if (!TEST_ptr(type)+            || !TEST_ptr((ctx = EVP_CIPHER_CTX_new()))+            || !TEST_true(EVP_EncryptInit_ex(ctx, type, NULL, key, init_iv))+            || !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &len, msg,+                          (int)sizeof(msg)))+            || !TEST_true(EVP_CIPHER_CTX_get_original_iv(ctx, oiv, sizeof(oiv)))+            || !TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))+            || !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &len)))",
            "commit_date": "2021-04-15 11:53:42+02:00",
            "commit_hash": "a4afa6c1d00c027a5afc8974a298e0f54607f1b5",
            "message": "Add test for the IV handling of DES based ciphers\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/14882)"
        }
    ],
    "git log -L360,405:test/threadstest.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/threadstest.c b/test/threadstest.c--- a/test/threadstest.c+++ b/test/threadstest.c@@ -273,47 +273,46 @@ static void thread_general_worker(void) {-    EVP_PKEY_CTX *pctx = NULL;",
            "commit_date": "2021-03-20 13:49:08+01:00",
            "commit_hash": "f925315203f77d0241183ccabfc784d259b0a152",
            "message": "Add convenience functions and macros for asymmetric key generation\nAdd EVP_PKEY_gen(), EVP_PKEY_Q_gen(), EVP_RSA_gen(), and EVP_EC_gen().\nAlso export auxiliary function OSSL_EC_curve_nid2name()\nand improve deprecation info on RSA and EC key generation/management functions.\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/14695)\nEVP_MD_CTX *mdctx = EVP_MD_CTX_new();\nEVP_MD *md = EVP_MD_fetch(multi_libctx, \"SHA2-256\", NULL);\nEVP_CIPHER_CTX *cipherctx = EVP_CIPHER_CTX_new();\nEVP_CIPHER *ciph = EVP_CIPHER_fetch(multi_libctx, \"AES-128-CBC\", NULL);\nconst char *message = \"Hello World\";\nsize_t messlen = strlen(message);\n/* Should be big enough for encryption output too */\nunsigned char out[EVP_MAX_MD_SIZE];\nconst unsigned char key[AES_BLOCK_SIZE] = {\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n0x0c, 0x0d, 0x0e, 0x0f\n};\nconst unsigned char iv[AES_BLOCK_SIZE] = {\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n0x0c, 0x0d, 0x0e, 0x0f\n};\nunsigned int mdoutl;\nint ciphoutl;\nEVP_PKEY *pkey = NULL;\nint testresult = 0;\nint i, isfips;\nisfips = OSSL_PROVIDER_available(multi_libctx, \"fips\");\nif (!TEST_ptr(mdctx)\n|| !TEST_ptr(md)\n|| !TEST_ptr(cipherctx)\n|| !TEST_ptr(ciph))\ngoto err;\n/* Do some work */\nfor (i = 0; i < 5; i++) {\nif (!TEST_true(EVP_DigestInit_ex(mdctx, md, NULL))\n|| !TEST_true(EVP_DigestUpdate(mdctx, message, messlen))\n|| !TEST_true(EVP_DigestFinal(mdctx, out, &mdoutl)))\ngoto err;\n}\nfor (i = 0; i < 5; i++) {\nif (!TEST_true(EVP_EncryptInit_ex(cipherctx, ciph, NULL, key, iv))\n|| !TEST_true(EVP_EncryptUpdate(cipherctx, out, &ciphoutl,\n(unsigned char *)message,\nmesslen))\n|| !TEST_true(EVP_EncryptFinal(cipherctx, out, &ciphoutl)))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/threadstest.c b/test/threadstest.c--- a/test/threadstest.c+++ b/test/threadstest.c@@ -269,47 +269,47 @@-static void thread_multi_worker(void)+static void thread_general_worker(void) {",
            "commit_date": "2021-01-11 17:01:07+00:00",
            "commit_hash": "b457c8f514130d3b92de574620d38c1058eb7b35",
            "message": "Extend the threads test to add simple fetch from multi threads\nIssue #13682 suggests that doing a simple fetch from multi-threads may\nresult in issues so we add a test for that.\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/13660)\nEVP_MD_CTX *mdctx = EVP_MD_CTX_new();\nEVP_MD *md = EVP_MD_fetch(multi_libctx, \"SHA2-256\", NULL);\nEVP_CIPHER_CTX *cipherctx = EVP_CIPHER_CTX_new();\nEVP_CIPHER *ciph = EVP_CIPHER_fetch(multi_libctx, \"AES-128-CBC\", NULL);\nconst char *message = \"Hello World\";\nsize_t messlen = strlen(message);\n/* Should be big enough for encryption output too */\nunsigned char out[EVP_MAX_MD_SIZE];\nconst unsigned char key[AES_BLOCK_SIZE] = {\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n0x0c, 0x0d, 0x0e, 0x0f\n};\nconst unsigned char iv[AES_BLOCK_SIZE] = {\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,\n0x0c, 0x0d, 0x0e, 0x0f\n};\nunsigned int mdoutl;\nint ciphoutl;\nEVP_PKEY_CTX *pctx = NULL;\nEVP_PKEY *pkey = NULL;\nint testresult = 0;\nint i, isfips;\nisfips = OSSL_PROVIDER_available(multi_libctx, \"fips\");\nif (!TEST_ptr(mdctx)\n|| !TEST_ptr(md)\n|| !TEST_ptr(cipherctx)\n|| !TEST_ptr(ciph))\ngoto err;\n/* Do some work */\nfor (i = 0; i < 5; i++) {\nif (!TEST_true(EVP_DigestInit_ex(mdctx, md, NULL))\n|| !TEST_true(EVP_DigestUpdate(mdctx, message, messlen))\n|| !TEST_true(EVP_DigestFinal(mdctx, out, &mdoutl)))\ngoto err;\n}\nfor (i = 0; i < 5; i++) {\nif (!TEST_true(EVP_EncryptInit_ex(cipherctx, ciph, NULL, key, iv))\n|| !TEST_true(EVP_EncryptUpdate(cipherctx, out, &ciphoutl,\n(unsigned char *)message,\nmesslen))\n|| !TEST_true(EVP_EncryptFinal(cipherctx, out, &ciphoutl)))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/threadstest.c b/test/threadstest.c--- a/test/threadstest.c+++ b/test/threadstest.c@@ -262,0 +269,47 @@++static void thread_multi_worker(void)+{+    EVP_MD_CTX *mdctx = EVP_MD_CTX_new();+    EVP_MD *md = EVP_MD_fetch(multi_libctx, \"SHA2-256\", NULL);+    EVP_CIPHER_CTX *cipherctx = EVP_CIPHER_CTX_new();+    EVP_CIPHER *ciph = EVP_CIPHER_fetch(multi_libctx, \"AES-128-CBC\", NULL);+    const char *message = \"Hello World\";+    size_t messlen = strlen(message);+    /* Should be big enough for encryption output too */+    unsigned char out[EVP_MAX_MD_SIZE];+    const unsigned char key[AES_BLOCK_SIZE] = {+        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,+        0x0c, 0x0d, 0x0e, 0x0f+    };+    const unsigned char iv[AES_BLOCK_SIZE] = {+        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,+        0x0c, 0x0d, 0x0e, 0x0f+    };+    unsigned int mdoutl;+    int ciphoutl;+    EVP_PKEY_CTX *pctx = NULL;+    EVP_PKEY *pkey = NULL;+    int testresult = 0;+    int i, isfips;++    isfips = OSSL_PROVIDER_available(multi_libctx, \"fips\");++    if (!TEST_ptr(mdctx)+            || !TEST_ptr(md)+            || !TEST_ptr(cipherctx)+            || !TEST_ptr(ciph))+        goto err;++    /* Do some work */+    for (i = 0; i < 5; i++) {+        if (!TEST_true(EVP_DigestInit_ex(mdctx, md, NULL))+                || !TEST_true(EVP_DigestUpdate(mdctx, message, messlen))+                || !TEST_true(EVP_DigestFinal(mdctx, out, &mdoutl)))+            goto err;+    }+    for (i = 0; i < 5; i++) {+        if (!TEST_true(EVP_EncryptInit_ex(cipherctx, ciph, NULL, key, iv))+                || !TEST_true(EVP_EncryptUpdate(cipherctx, out, &ciphoutl,+                                                (unsigned char *)message,+                                                messlen))+                || !TEST_true(EVP_EncryptFinal(cipherctx, out, &ciphoutl)))",
            "commit_date": "2020-12-10 15:39:58+00:00",
            "commit_hash": "ae95a40e8d453aa9d4f6499568f658ffc88a7d6e",
            "message": "Add a test for performing work in multiple concurrent threads\nWe test both the default provider and the fips provider\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/13660)"
        }
    ],
    "git log -L3875,3918:test/evp_extra_test.c": [
        {
            "author": {
                "email": "jlu.hpw@foxmail.com",
                "name": "Peiwei Hu"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -3851,44 +3851,44 @@ static int test_gcm_reinit(int idx) {-    if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, t->ivlen1, NULL))) {+    if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, t->ivlen1, NULL), 0)) {",
            "commit_date": "2022-05-21 16:17:23+08:00",
            "commit_hash": "d649c51a5388912277dffb56d921eb720db54be1",
            "message": "Fix check of EVP_CIPHER_CTX_ctrl\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/18368)\nint outlen1, outlen2, outlen3;\nint testresult = 0;\nunsigned char outbuf[1024];\nunsigned char tag[16];\nconst TEST_GCM_IV_REINIT_st *t = &gcm_reinit_tests[idx];\nEVP_CIPHER_CTX *ctx = NULL;\nEVP_CIPHER *type = NULL;\nsize_t taglen = sizeof(tag);\nchar *errmsg = NULL;\nif (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())) {\nerrmsg = \"CTX_ALLOC\";\ngoto err;\n}\nif (!TEST_ptr(type = EVP_CIPHER_fetch(testctx, \"aes-256-gcm\", testpropq))) {\nerrmsg = \"CIPHER_FETCH\";\ngoto err;\n}\nif (!TEST_true(EVP_CipherInit_ex(ctx, type, NULL, NULL, NULL, 1))) {\nerrmsg = \"ENC_INIT\";\ngoto err;\n}\nerrmsg = \"SET_IVLEN1\";\ngoto err;\n}\nif (!TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, kGCMResetKey, t->iv1, 1))) {\nerrmsg = \"SET_IV1\";\ngoto err;\n}\nif (!TEST_true(EVP_CipherUpdate(ctx, NULL, &outlen3, gcmAAD, sizeof(gcmAAD)))) {\nerrmsg = \"AAD1\";\ngoto err;\n}\nEVP_CIPHER_CTX_set_padding(ctx, 0);\nif (!TEST_true(EVP_CipherUpdate(ctx, outbuf, &outlen1, gcmResetPlaintext,\nsizeof(gcmResetPlaintext)))) {\nerrmsg = \"CIPHER_UPDATE1\";\ngoto err;\n}\nif (!TEST_true(EVP_CipherFinal_ex(ctx, outbuf + outlen1, &outlen2))) {"
        },
        {
            "author": {
                "email": "jchrist@linux.ibm.com",
                "name": "Juergen Christ"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2898,0 +3265,44 @@++static int test_gcm_reinit(int idx)+{+    int outlen1, outlen2, outlen3;+    int testresult = 0;+    unsigned char outbuf[1024];+    unsigned char tag[16];+    const TEST_GCM_IV_REINIT_st *t = &gcm_reinit_tests[idx];+    EVP_CIPHER_CTX *ctx = NULL;+    EVP_CIPHER *type = NULL;+    size_t taglen = sizeof(tag);+    char *errmsg = NULL;++    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())) {+        errmsg = \"CTX_ALLOC\";+        goto err;+    }+    if (!TEST_ptr(type = EVP_CIPHER_fetch(testctx, \"aes-256-gcm\", testpropq))) {+        errmsg = \"CIPHER_FETCH\";+        goto err;+    }+    if (!TEST_true(EVP_CipherInit_ex(ctx, type, NULL, NULL, NULL, 1))) {+        errmsg = \"ENC_INIT\";+        goto err;+    }+    if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_GCM_SET_IVLEN, t->ivlen1, NULL))) {+        errmsg = \"SET_IVLEN1\";+        goto err;+    }+    if (!TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, kGCMResetKey, t->iv1, 1))) {+        errmsg = \"SET_IV1\";+        goto err;+    }+    if (!TEST_true(EVP_CipherUpdate(ctx, NULL, &outlen3, gcmAAD, sizeof(gcmAAD)))) {+        errmsg = \"AAD1\";+        goto err;+    }+    EVP_CIPHER_CTX_set_padding(ctx, 0);+    if (!TEST_true(EVP_CipherUpdate(ctx, outbuf, &outlen1, gcmResetPlaintext,+                                    sizeof(gcmResetPlaintext)))) {+        errmsg = \"CIPHER_UPDATE1\";+        goto err;+    }+    if (!TEST_true(EVP_CipherFinal_ex(ctx, outbuf + outlen1, &outlen2))) {",
            "commit_date": "2021-06-02 19:33:50+02:00",
            "commit_hash": "063e019738b90fcf0a3ab7b1654ce8976805b0b3",
            "message": "Test EVP_CipherInit sequences and resets\nVarious EVP_CipherInit sequences including partial inits and initializations\nwith different \"enc\" flags caused problems on s390x.  Similarly, cipher\nreinitialization and especially GCM reinitialization with different tag length\nled to wrong results.  Add some unit tests to cover these rather exotic use\ncases.\nSigned-off-by: Juergen Christ <jchrist@linux.ibm.com>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15521)"
        }
    ],
    "git log -L347,374:test/sslapitest.c": [
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -354,28 +364,28 @@-#if !defined(OPENSSL_NO_TLS1_2) || defined(OPENSSL_NO_TLS1_3)+#if !defined(OPENSSL_NO_TLS1_2) || defined(OSSL_NO_USABLE_TLS1_3) static int test_keylog(void) {",
            "commit_date": "2021-01-14 15:50:20+00:00",
            "commit_hash": "a763ca11777ce01a286751f3f3dd9b106ef74f30",
            "message": "Stop disabling TLSv1.3 if ec and dh are disabled\nEven if EC and DH are disabled then we may still be able to use TLSv1.3\nif we have groups that have been plugged in by an external provider.\nFixes #13767\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13916)\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\nstruct sslapitest_log_counts expected;\n/* Clean up logging space */\nmemset(&expected, 0, sizeof(expected));\nmemset(client_log_buffer, 0, sizeof(client_log_buffer));\nmemset(server_log_buffer, 0, sizeof(server_log_buffer));\nclient_log_buffer_index = 0;\nserver_log_buffer_index = 0;\nerror_writing_log = 0;\nif (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),\nTLS_client_method(),\nTLS1_VERSION, 0,\n&sctx, &cctx, cert, privkey)))\nreturn 0;\n/* We cannot log the master secret for TLSv1.3, so we should forbid it. */\nSSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);\nSSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);\n/* We also want to ensure that we use RSA-based key exchange. */\nif (!TEST_true(SSL_CTX_set_cipher_list(cctx, \"RSA\")))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -326,28 +330,28 @@ #if !defined(OPENSSL_NO_TLS1_2) || defined(OPENSSL_NO_TLS1_3) static int test_keylog(void) {-    if (!TEST_true(create_ssl_ctx_pair(TLS_server_method(),+    if (!TEST_true(create_ssl_ctx_pair(libctx, TLS_server_method(),",
            "commit_date": "2020-03-18 17:17:37+00:00",
            "commit_hash": "5e30f2fd58bac0db5c23e33e865fa70bd6eb4349",
            "message": "Use a non-default libctx in sslapitest\nWe also don't load the default provider into the default libctx to make\nsure there is no accidental \"leakage\".\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/11508)\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\nstruct sslapitest_log_counts expected;\n/* Clean up logging space */\nmemset(&expected, 0, sizeof(expected));\nmemset(client_log_buffer, 0, sizeof(client_log_buffer));\nmemset(server_log_buffer, 0, sizeof(server_log_buffer));\nclient_log_buffer_index = 0;\nserver_log_buffer_index = 0;\nerror_writing_log = 0;\nTLS_client_method(),\nTLS1_VERSION, 0,\n&sctx, &cctx, cert, privkey)))\nreturn 0;\n/* We cannot log the master secret for TLSv1.3, so we should forbid it. */\nSSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);\nSSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);\n/* We also want to ensure that we use RSA-based key exchange. */\nif (!TEST_true(SSL_CTX_set_cipher_list(cctx, \"RSA\")))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -303,27 +303,28 @@ #if !defined(OPENSSL_NO_TLS1_2) || defined(OPENSSL_NO_TLS1_3) static int test_keylog(void) {-    struct sslapitest_log_counts expected = {0};+    struct sslapitest_log_counts expected;+    memset(&expected, 0, sizeof(expected));",
            "commit_date": "2019-03-29 18:31:10+10:00",
            "commit_hash": "6fc1e6246f9b29334fd6dcb5b832e75cce7a2ecd",
            "message": "Propery initialise struct sslapitest_log_counts to zero using memset.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/8611)\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\n/* Clean up logging space */\nmemset(client_log_buffer, 0, sizeof(client_log_buffer));\nmemset(server_log_buffer, 0, sizeof(server_log_buffer));\nclient_log_buffer_index = 0;\nserver_log_buffer_index = 0;\nerror_writing_log = 0;\nif (!TEST_true(create_ssl_ctx_pair(TLS_server_method(),\nTLS_client_method(),\nTLS1_VERSION, 0,\n&sctx, &cctx, cert, privkey)))\nreturn 0;\n/* We cannot log the master secret for TLSv1.3, so we should forbid it. */\nSSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);\nSSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);\n/* We also want to ensure that we use RSA-based key exchange. */\nif (!TEST_true(SSL_CTX_set_cipher_list(cctx, \"RSA\")))"
        },
        {
            "author": {
                "email": "kurt@roeckx.be",
                "name": "Kurt Roeckx"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -303,27 +303,27 @@ #if !defined(OPENSSL_NO_TLS1_2) || defined(OPENSSL_NO_TLS1_3) static int test_keylog(void) {-                                       TLS1_VERSION, TLS_MAX_VERSION,+                                       TLS1_VERSION, 0,",
            "commit_date": "2018-12-09 20:53:05+01:00",
            "commit_hash": "5c587fb6b996d47771bcaecd71489e4849103f56",
            "message": "Use (D)TLS_MAX_VERSION_INTERNAL internally\nUse 0 if we don't want to set a minimum or maximum version\nReviewed-by: Matt Caswell <matt@openssl.org>\nGH: #7260\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\nstruct sslapitest_log_counts expected = {0};\n/* Clean up logging space */\nmemset(client_log_buffer, 0, sizeof(client_log_buffer));\nmemset(server_log_buffer, 0, sizeof(server_log_buffer));\nclient_log_buffer_index = 0;\nserver_log_buffer_index = 0;\nerror_writing_log = 0;\nif (!TEST_true(create_ssl_ctx_pair(TLS_server_method(),\nTLS_client_method(),\n&sctx, &cctx, cert, privkey)))\nreturn 0;\n/* We cannot log the master secret for TLSv1.3, so we should forbid it. */\nSSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);\nSSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);\n/* We also want to ensure that we use RSA-based key exchange. */\nif (!TEST_true(SSL_CTX_set_cipher_list(cctx, \"RSA\")))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -258,26 +258,27 @@ #if !defined(OPENSSL_NO_TLS1_2) || defined(OPENSSL_NO_TLS1_3) static int test_keylog(void) {+                                       TLS1_VERSION, TLS_MAX_VERSION,",
            "commit_date": "2018-03-19 09:08:06+01:00",
            "commit_hash": "7d7f6834e542e53f604b46a72d57fad773d4b2bc",
            "message": "Enhance ssltestlib's create_ssl_ctx_pair to take min and max proto version\nHave all test programs using that function specify those versions.\nAdditionally, have the remaining test programs that use SSL_CTX_new\ndirectly specify at least the maximum protocol version.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5663)\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\nstruct sslapitest_log_counts expected = {0};\n/* Clean up logging space */\nmemset(client_log_buffer, 0, sizeof(client_log_buffer));\nmemset(server_log_buffer, 0, sizeof(server_log_buffer));\nclient_log_buffer_index = 0;\nserver_log_buffer_index = 0;\nerror_writing_log = 0;\nif (!TEST_true(create_ssl_ctx_pair(TLS_server_method(),\nTLS_client_method(),\n&sctx, &cctx, cert, privkey)))\nreturn 0;\n/* We cannot log the master secret for TLSv1.3, so we should forbid it. */\nSSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);\nSSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);\n/* We also want to ensure that we use RSA-based key exchange. */\nif (!TEST_true(SSL_CTX_set_cipher_list(cctx, \"RSA\")))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -257,25 +257,26 @@+#if !defined(OPENSSL_NO_TLS1_2) || defined(OPENSSL_NO_TLS1_3) static int test_keylog(void) {",
            "commit_date": "2018-02-09 10:19:14+00:00",
            "commit_hash": "c423ecaa7f6d0cc77c4f121c6de7d585439bca8f",
            "message": "Fixes for no-tls1_2 and no-tls1_2-method\nThe no-tls1_2 option does not work properly in conjunction with TLSv1.3\nbeing enabled (which is now the default). This commit fixes the issues.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/5301)\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\nstruct sslapitest_log_counts expected = {0};\n/* Clean up logging space */\nmemset(client_log_buffer, 0, sizeof(client_log_buffer));\nmemset(server_log_buffer, 0, sizeof(server_log_buffer));\nclient_log_buffer_index = 0;\nserver_log_buffer_index = 0;\nerror_writing_log = 0;\nif (!TEST_true(create_ssl_ctx_pair(TLS_server_method(),\nTLS_client_method(),\n&sctx, &cctx, cert, privkey)))\nreturn 0;\n/* We cannot log the master secret for TLSv1.3, so we should forbid it. */\nSSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);\nSSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);\n/* We also want to ensure that we use RSA-based key exchange. */\nif (!TEST_true(SSL_CTX_set_cipher_list(cctx, \"RSA\")))"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -279,28 +240,25 @@-static int test_keylog(void) {+static int test_keylog(void)+{-    int rc;-    memset(client_log_buffer, 0, LOG_BUFFER_SIZE + 1);-    memset(server_log_buffer, 0, LOG_BUFFER_SIZE + 1);+    memset(client_log_buffer, 0, sizeof(client_log_buffer));+    memset(server_log_buffer, 0, sizeof(server_log_buffer));-    if (!create_ssl_ctx_pair(TLS_server_method(), TLS_client_method(), &sctx,-                             &cctx, cert, privkey)) {-        printf(\"Unable to create SSL_CTX pair\\n\");+    if (!TEST_true(create_ssl_ctx_pair(TLS_server_method(),+                                       TLS_client_method(),+                                       &sctx, &cctx, cert, privkey)))-    }-    rc = SSL_CTX_set_cipher_list(cctx, \"RSA\");-    if (rc == 0) {-        printf(\"Unable to restrict to RSA key exchange.\\n\");+    if (!TEST_true(SSL_CTX_set_cipher_list(cctx, \"RSA\")))",
            "commit_date": "2017-04-26 13:24:37-04:00",
            "commit_hash": "710756a9b384c9e9eaaf42acaf429aebc2a822a1",
            "message": "Convert sslapitest to test framework\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3252)\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\nstruct sslapitest_log_counts expected = {0};\n/* Clean up logging space */\nclient_log_buffer_index = 0;\nserver_log_buffer_index = 0;\nerror_writing_log = 0;\nreturn 0;\n/* We cannot log the master secret for TLSv1.3, so we should forbid it. */\nSSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);\nSSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);\n/* We also want to ensure that we use RSA-based key exchange. */"
        },
        {
            "author": {
                "email": "lukasaoz@gmail.com",
                "name": "Cory Benfield"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -197,27 +280,28 @@ static int test_keylog(void) {+    struct sslapitest_log_counts expected = {0};",
            "commit_date": "2017-01-31 14:56:31+00:00",
            "commit_hash": "f1a5939f177becfaf465f9cf5a834ce6341276c4",
            "message": "Test logging TLSv1.3 secrets.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2287)\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\nint rc;\n/* Clean up logging space */\nmemset(client_log_buffer, 0, LOG_BUFFER_SIZE + 1);\nmemset(server_log_buffer, 0, LOG_BUFFER_SIZE + 1);\nclient_log_buffer_index = 0;\nserver_log_buffer_index = 0;\nerror_writing_log = 0;\nif (!create_ssl_ctx_pair(TLS_server_method(), TLS_client_method(), &sctx,\n&cctx, cert, privkey)) {\nprintf(\"Unable to create SSL_CTX pair\\n\");\nreturn 0;\n}\n/* We cannot log the master secret for TLSv1.3, so we should forbid it. */\nSSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);\nSSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);\n/* We also want to ensure that we use RSA-based key exchange. */\nrc = SSL_CTX_set_cipher_list(cctx, \"RSA\");\nif (rc == 0) {\nprintf(\"Unable to restrict to RSA key exchange.\\n\");"
        },
        {
            "author": {
                "email": "lukasaoz@gmail.com",
                "name": "Cory Benfield"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -197,22 +197,27 @@ static int test_keylog(void) {+    int rc;+    /* We also want to ensure that we use RSA-based key exchange. */+    rc = SSL_CTX_set_cipher_list(cctx, \"RSA\");+    if (rc == 0) {+        printf(\"Unable to restrict to RSA key exchange.\\n\");",
            "commit_date": "2017-01-25 19:42:16+00:00",
            "commit_hash": "f0deb4d352774491919f1b1ba861014659651d66",
            "message": "Limit the length of the encrypted premaster key.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2288)\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\n/* Clean up logging space */\nmemset(client_log_buffer, 0, LOG_BUFFER_SIZE + 1);\nmemset(server_log_buffer, 0, LOG_BUFFER_SIZE + 1);\nclient_log_buffer_index = 0;\nserver_log_buffer_index = 0;\nerror_writing_log = 0;\nif (!create_ssl_ctx_pair(TLS_server_method(), TLS_client_method(), &sctx,\n&cctx, cert, privkey)) {\nprintf(\"Unable to create SSL_CTX pair\\n\");\nreturn 0;\n}\n/* We cannot log the master secret for TLSv1.3, so we should forbid it. */\nSSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);\nSSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);"
        },
        {
            "author": {
                "email": "lukasaoz@gmail.com",
                "name": "Cory Benfield"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -37,0 +197,22 @@+static int test_keylog(void) {+    SSL_CTX *cctx = NULL, *sctx = NULL;+    SSL *clientssl = NULL, *serverssl = NULL;+    int testresult = 0;++    /* Clean up logging space */+    memset(client_log_buffer, 0, LOG_BUFFER_SIZE + 1);+    memset(server_log_buffer, 0, LOG_BUFFER_SIZE + 1);+    client_log_buffer_index = 0;+    server_log_buffer_index = 0;+    error_writing_log = 0;++    if (!create_ssl_ctx_pair(TLS_server_method(), TLS_client_method(), &sctx,+                             &cctx, cert, privkey)) {+        printf(\"Unable to create SSL_CTX pair\\n\");+        return 0;+    }++    /* We cannot log the master secret for TLSv1.3, so we should forbid it. */+    SSL_CTX_set_options(cctx, SSL_OP_NO_TLSv1_3);+    SSL_CTX_set_options(sctx, SSL_OP_NO_TLSv1_3);+",
            "commit_date": "2017-01-20 16:22:39+00:00",
            "commit_hash": "6acdd3e531e52173a0c76490c0aae3ecebe04a89",
            "message": "Add tests for the key logging callbacks.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1646)"
        }
    ],
    "git log -L3572,3630:test/evp_extra_test.c": [
        {
            "author": {
                "email": "jlu.hpw@foxmail.com",
                "name": "Peiwei Hu"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -3548,59 +3548,59 @@  */ static int test_evp_init_seq(int idx) {-        if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,-                                           t->taglen, (void *)t->tag))) {+        if (!TEST_int_gt(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,+                                           t->taglen, (void *)t->tag), 0)) {",
            "commit_date": "2022-05-21 16:17:23+08:00",
            "commit_hash": "d649c51a5388912277dffb56d921eb720db54be1",
            "message": "Fix check of EVP_CIPHER_CTX_ctrl\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/18368)\nint outlen1, outlen2;\nint testresult = 0;\nunsigned char outbuf[1024];\nunsigned char tag[16];\nconst EVP_INIT_TEST_st *t = &evp_init_tests[idx];\nEVP_CIPHER_CTX *ctx = NULL;\nEVP_CIPHER *type = NULL;\nsize_t taglen = sizeof(tag);\nchar *errmsg = NULL;\nctx = EVP_CIPHER_CTX_new();\nif (ctx == NULL) {\nerrmsg = \"CTX_ALLOC\";\ngoto err;\n}\nif (!TEST_ptr(type = EVP_CIPHER_fetch(testctx, t->cipher, testpropq))) {\nerrmsg = \"CIPHER_FETCH\";\ngoto err;\n}\nif (!TEST_true(EVP_CipherInit_ex(ctx, type, NULL, NULL, NULL, t->initenc))) {\nerrmsg = \"EMPTY_ENC_INIT\";\ngoto err;\n}\nif (!TEST_true(EVP_CIPHER_CTX_set_padding(ctx, 0))) {\nerrmsg = \"PADDING\";\ngoto err;\n}\nif (t->keyfirst && !TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, t->key, NULL, -1))) {\nerrmsg = \"KEY_INIT (before iv)\";\ngoto err;\n}\nif (!evp_init_seq_set_iv(ctx, t)) {\nerrmsg = \"IV_INIT\";\ngoto err;\n}\nif (t->keyfirst == 0 &&  !TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, t->key, NULL, -1))) {\nerrmsg = \"KEY_INIT (after iv)\";\ngoto err;\n}\nif (!TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, t->finalenc))) {\nerrmsg = \"FINAL_ENC_INIT\";\ngoto err;\n}\nif (!TEST_true(EVP_CipherUpdate(ctx, outbuf, &outlen1, t->input, t->inlen))) {\nerrmsg = \"CIPHER_UPDATE\";\ngoto err;\n}\nif (t->finalenc == 0 && t->tag != NULL) {\n/* Set expected tag */\nerrmsg = \"SET_TAG\";\ngoto err;\n}\n}\nif (!TEST_true(EVP_CipherFinal_ex(ctx, outbuf + outlen1, &outlen2))) {"
        },
        {
            "author": {
                "email": "jchrist@linux.ibm.com",
                "name": "Juergen Christ"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2898,0 +3069,59 @@+ */+static int test_evp_init_seq(int idx)+{+    int outlen1, outlen2;+    int testresult = 0;+    unsigned char outbuf[1024];+    unsigned char tag[16];+    const EVP_INIT_TEST_st *t = &evp_init_tests[idx];+    EVP_CIPHER_CTX *ctx = NULL;+    EVP_CIPHER *type = NULL;+    size_t taglen = sizeof(tag);+    char *errmsg = NULL;++    ctx = EVP_CIPHER_CTX_new();+    if (ctx == NULL) {+        errmsg = \"CTX_ALLOC\";+        goto err;+    }+    if (!TEST_ptr(type = EVP_CIPHER_fetch(testctx, t->cipher, testpropq))) {+        errmsg = \"CIPHER_FETCH\";+        goto err;+    }+    if (!TEST_true(EVP_CipherInit_ex(ctx, type, NULL, NULL, NULL, t->initenc))) {+        errmsg = \"EMPTY_ENC_INIT\";+        goto err;+    }+    if (!TEST_true(EVP_CIPHER_CTX_set_padding(ctx, 0))) {+        errmsg = \"PADDING\";+        goto err;+    }+    if (t->keyfirst && !TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, t->key, NULL, -1))) {+        errmsg = \"KEY_INIT (before iv)\";+        goto err;+    }+    if (!evp_init_seq_set_iv(ctx, t)) {+        errmsg = \"IV_INIT\";+        goto err;+    }+    if (t->keyfirst == 0 &&  !TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, t->key, NULL, -1))) {+        errmsg = \"KEY_INIT (after iv)\";+        goto err;+    }+    if (!TEST_true(EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, t->finalenc))) {+        errmsg = \"FINAL_ENC_INIT\";+        goto err;+    }+    if (!TEST_true(EVP_CipherUpdate(ctx, outbuf, &outlen1, t->input, t->inlen))) {+        errmsg = \"CIPHER_UPDATE\";+        goto err;+    }+    if (t->finalenc == 0 && t->tag != NULL) {+        /* Set expected tag */+        if (!TEST_true(EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_AEAD_SET_TAG,+                                           t->taglen, (void *)t->tag))) {+            errmsg = \"SET_TAG\";+            goto err;+        }+    }+    if (!TEST_true(EVP_CipherFinal_ex(ctx, outbuf + outlen1, &outlen2))) {",
            "commit_date": "2021-06-02 19:33:50+02:00",
            "commit_hash": "063e019738b90fcf0a3ab7b1654ce8976805b0b3",
            "message": "Test EVP_CipherInit sequences and resets\nVarious EVP_CipherInit sequences including partial inits and initializations\nwith different \"enc\" flags caused problems on s390x.  Similarly, cipher\nreinitialization and especially GCM reinitialization with different tag length\nled to wrong results.  Add some unit tests to cover these rather exotic use\ncases.\nSigned-off-by: Juergen Christ <jchrist@linux.ibm.com>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15521)"
        }
    ],
    "git log -L3051,3162:test/evp_extra_test.c": [
        {
            "author": {
                "email": "xkernel.wang@foxmail.com",
                "name": "x2018"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2849,112 +2849,112 @@  */ static int test_evp_iv_aes(int idx) { #ifndef OPENSSL_NO_OCB #endif-    switch(idx) {+    switch (idx) { #ifdef OPENSSL_NO_OCB #else #endif",
            "commit_date": "2021-10-26 15:16:18+08:00",
            "commit_hash": "1287dabd0b23326be491125698dd982e4ae28887",
            "message": "fix some code with obvious wrong coding style\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16918)\nint ret = 0;\nEVP_CIPHER_CTX *ctx = NULL;\nunsigned char key[16] = {0x4c, 0x43, 0xdb, 0xdd, 0x42, 0x73, 0x47, 0xd1,\n0xe5, 0x62, 0x7d, 0xcd, 0x4d, 0x76, 0x4d, 0x57};\nunsigned char init_iv[EVP_MAX_IV_LENGTH] =\n{0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98, 0x82,\n0x5a, 0x55, 0x91, 0x81, 0x42, 0xa8, 0x89, 0x34};\nstatic const unsigned char msg[] = { 1, 2, 3, 4, 5, 6, 7, 8,\n9, 10, 11, 12, 13, 14, 15, 16 };\nunsigned char ciphertext[32], oiv[16], iv[16];\nunsigned char *ref_iv;\nunsigned char cbc_state[16] = {0x10, 0x2f, 0x05, 0xcc, 0xc2, 0x55, 0x72, 0xb9,\n0x88, 0xe6, 0x4a, 0x17, 0x10, 0x74, 0x22, 0x5e};\nunsigned char ofb_state[16] = {0x76, 0xe6, 0x66, 0x61, 0xd0, 0x8a, 0xe4, 0x64,\n0xdd, 0x66, 0xbf, 0x00, 0xf0, 0xe3, 0x6f, 0xfd};\nunsigned char cfb_state[16] = {0x77, 0xe4, 0x65, 0x65, 0xd5, 0x8c, 0xe3, 0x6c,\n0xd4, 0x6c, 0xb4, 0x0c, 0xfd, 0xed, 0x60, 0xed};\nunsigned char gcm_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nunsigned char ccm_state[7] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98};\nunsigned char ocb_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nint len = sizeof(ciphertext);\nsize_t ivlen, ref_len;\nconst EVP_CIPHER *type = NULL;\nint iv_reset = 0;\nif (nullprov != NULL && idx < 6)\nreturn TEST_skip(\"Test does not support a non-default library context\");\ncase 0:\ntype = EVP_aes_128_cbc();\n/* FALLTHROUGH */\ncase 6:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-cbc\", testpropq);\nref_iv = cbc_state;\nref_len = sizeof(cbc_state);\niv_reset = 1;\nbreak;\ncase 1:\ntype = EVP_aes_128_ofb();\n/* FALLTHROUGH */\ncase 7:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ofb\", testpropq);\nref_iv = ofb_state;\nref_len = sizeof(ofb_state);\niv_reset = 1;\nbreak;\ncase 2:\ntype = EVP_aes_128_cfb();\n/* FALLTHROUGH */\ncase 8:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-cfb\", testpropq);\nref_iv = cfb_state;\nref_len = sizeof(cfb_state);\niv_reset = 1;\nbreak;\ncase 3:\ntype = EVP_aes_128_gcm();\n/* FALLTHROUGH */\ncase 9:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-gcm\", testpropq);\nref_iv = gcm_state;\nref_len = sizeof(gcm_state);\nbreak;\ncase 4:\ntype = EVP_aes_128_ccm();\n/* FALLTHROUGH */\ncase 10:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ccm\", testpropq);\nref_iv = ccm_state;\nref_len = sizeof(ccm_state);\nbreak;\ncase 5:\ncase 11:\nreturn 1;\ncase 5:\ntype = EVP_aes_128_ocb();\n/* FALLTHROUGH */\ncase 11:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ocb\", testpropq);\nref_iv = ocb_state;\nref_len = sizeof(ocb_state);\nbreak;\ndefault:\nreturn 0;\n}\nif (!TEST_ptr(type)\n|| !TEST_ptr((ctx = EVP_CIPHER_CTX_new()))\n|| !TEST_true(EVP_EncryptInit_ex(ctx, type, NULL, key, init_iv))\n|| !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &len, msg,\n(int)sizeof(msg)))\n|| !TEST_true(EVP_CIPHER_CTX_get_original_iv(ctx, oiv, sizeof(oiv)))\n|| !TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))\n|| !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &len)))"
        },
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2449,112 +2449,112 @@  */-static int test_evp_iv(int idx)+static int test_evp_iv_aes(int idx) { #ifndef OPENSSL_NO_OCB #endif #ifdef OPENSSL_NO_OCB #else #endif",
            "commit_date": "2021-04-15 11:53:42+02:00",
            "commit_hash": "a4afa6c1d00c027a5afc8974a298e0f54607f1b5",
            "message": "Add test for the IV handling of DES based ciphers\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/14882)\nint ret = 0;\nEVP_CIPHER_CTX *ctx = NULL;\nunsigned char key[16] = {0x4c, 0x43, 0xdb, 0xdd, 0x42, 0x73, 0x47, 0xd1,\n0xe5, 0x62, 0x7d, 0xcd, 0x4d, 0x76, 0x4d, 0x57};\nunsigned char init_iv[EVP_MAX_IV_LENGTH] =\n{0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98, 0x82,\n0x5a, 0x55, 0x91, 0x81, 0x42, 0xa8, 0x89, 0x34};\nstatic const unsigned char msg[] = { 1, 2, 3, 4, 5, 6, 7, 8,\n9, 10, 11, 12, 13, 14, 15, 16 };\nunsigned char ciphertext[32], oiv[16], iv[16];\nunsigned char *ref_iv;\nunsigned char cbc_state[16] = {0x10, 0x2f, 0x05, 0xcc, 0xc2, 0x55, 0x72, 0xb9,\n0x88, 0xe6, 0x4a, 0x17, 0x10, 0x74, 0x22, 0x5e};\nunsigned char ofb_state[16] = {0x76, 0xe6, 0x66, 0x61, 0xd0, 0x8a, 0xe4, 0x64,\n0xdd, 0x66, 0xbf, 0x00, 0xf0, 0xe3, 0x6f, 0xfd};\nunsigned char cfb_state[16] = {0x77, 0xe4, 0x65, 0x65, 0xd5, 0x8c, 0xe3, 0x6c,\n0xd4, 0x6c, 0xb4, 0x0c, 0xfd, 0xed, 0x60, 0xed};\nunsigned char gcm_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nunsigned char ccm_state[7] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98};\nunsigned char ocb_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nint len = sizeof(ciphertext);\nsize_t ivlen, ref_len;\nconst EVP_CIPHER *type = NULL;\nint iv_reset = 0;\nif (nullprov != NULL && idx < 6)\nreturn TEST_skip(\"Test does not support a non-default library context\");\nswitch(idx) {\ncase 0:\ntype = EVP_aes_128_cbc();\n/* FALLTHROUGH */\ncase 6:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-cbc\", testpropq);\nref_iv = cbc_state;\nref_len = sizeof(cbc_state);\niv_reset = 1;\nbreak;\ncase 1:\ntype = EVP_aes_128_ofb();\n/* FALLTHROUGH */\ncase 7:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ofb\", testpropq);\nref_iv = ofb_state;\nref_len = sizeof(ofb_state);\niv_reset = 1;\nbreak;\ncase 2:\ntype = EVP_aes_128_cfb();\n/* FALLTHROUGH */\ncase 8:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-cfb\", testpropq);\nref_iv = cfb_state;\nref_len = sizeof(cfb_state);\niv_reset = 1;\nbreak;\ncase 3:\ntype = EVP_aes_128_gcm();\n/* FALLTHROUGH */\ncase 9:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-gcm\", testpropq);\nref_iv = gcm_state;\nref_len = sizeof(gcm_state);\nbreak;\ncase 4:\ntype = EVP_aes_128_ccm();\n/* FALLTHROUGH */\ncase 10:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ccm\", testpropq);\nref_iv = ccm_state;\nref_len = sizeof(ccm_state);\nbreak;\ncase 5:\ncase 11:\nreturn 1;\ncase 5:\ntype = EVP_aes_128_ocb();\n/* FALLTHROUGH */\ncase 11:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ocb\", testpropq);\nref_iv = ocb_state;\nref_len = sizeof(ocb_state);\nbreak;\ndefault:\nreturn 0;\n}\nif (!TEST_ptr(type)\n|| !TEST_ptr((ctx = EVP_CIPHER_CTX_new()))\n|| !TEST_true(EVP_EncryptInit_ex(ctx, type, NULL, key, init_iv))\n|| !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &len, msg,\n(int)sizeof(msg)))\n|| !TEST_true(EVP_CIPHER_CTX_get_original_iv(ctx, oiv, sizeof(oiv)))\n|| !TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))\n|| !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &len)))"
        },
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2430,97 +2430,112 @@  */ static int test_evp_iv(int idx) {+    unsigned char cfb_state[16] = {0x77, 0xe4, 0x65, 0x65, 0xd5, 0x8c, 0xe3, 0x6c,+                                   0xd4, 0x6c, 0xb4, 0x0c, 0xfd, 0xed, 0x60, 0xed}; #ifndef OPENSSL_NO_OCB #endif+    int iv_reset = 0;-    if (nullprov != NULL && idx < 5)+    if (nullprov != NULL && idx < 6)-    case 5:+    case 6:+        iv_reset = 1;-    case 6:+    case 7:+        iv_reset = 1;+        type = EVP_aes_128_cfb();+        /* FALLTHROUGH */+    case 8:+        type = (type != NULL) ? type :+                                EVP_CIPHER_fetch(testctx, \"aes-128-cfb\", testpropq);+        ref_iv = cfb_state;+        ref_len = sizeof(cfb_state);+        iv_reset = 1;+        break;+    case 3:-    case 7:+    case 9:-    case 3:+    case 4:-    case 8:+    case 10: #ifdef OPENSSL_NO_OCB-    case 4:-    case 9:+    case 5:+    case 11: #else-    case 4:+    case 5:-    case 9:+    case 11: #endif",
            "commit_date": "2021-04-09 12:01:16+02:00",
            "commit_hash": "4ec4b063e0d4cc3d58c709e309b1ec5a9aea3379",
            "message": "Always reset IV for CBC, OFB, and CFB mode on cipher context reinit\nThis is necessary to keep compatibility with 1.1.1 implementation\nof the CBC, OFB, and CFB mode ciphers.\nFixes #14704\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14811)\nint ret = 0;\nEVP_CIPHER_CTX *ctx = NULL;\nunsigned char key[16] = {0x4c, 0x43, 0xdb, 0xdd, 0x42, 0x73, 0x47, 0xd1,\n0xe5, 0x62, 0x7d, 0xcd, 0x4d, 0x76, 0x4d, 0x57};\nunsigned char init_iv[EVP_MAX_IV_LENGTH] =\n{0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98, 0x82,\n0x5a, 0x55, 0x91, 0x81, 0x42, 0xa8, 0x89, 0x34};\nstatic const unsigned char msg[] = { 1, 2, 3, 4, 5, 6, 7, 8,\n9, 10, 11, 12, 13, 14, 15, 16 };\nunsigned char ciphertext[32], oiv[16], iv[16];\nunsigned char *ref_iv;\nunsigned char cbc_state[16] = {0x10, 0x2f, 0x05, 0xcc, 0xc2, 0x55, 0x72, 0xb9,\n0x88, 0xe6, 0x4a, 0x17, 0x10, 0x74, 0x22, 0x5e};\nunsigned char ofb_state[16] = {0x76, 0xe6, 0x66, 0x61, 0xd0, 0x8a, 0xe4, 0x64,\n0xdd, 0x66, 0xbf, 0x00, 0xf0, 0xe3, 0x6f, 0xfd};\nunsigned char gcm_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nunsigned char ccm_state[7] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98};\nunsigned char ocb_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nint len = sizeof(ciphertext);\nsize_t ivlen, ref_len;\nconst EVP_CIPHER *type = NULL;\nreturn TEST_skip(\"Test does not support a non-default library context\");\nswitch(idx) {\ncase 0:\ntype = EVP_aes_128_cbc();\n/* FALLTHROUGH */\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-cbc\", testpropq);\nref_iv = cbc_state;\nref_len = sizeof(cbc_state);\nbreak;\ncase 1:\ntype = EVP_aes_128_ofb();\n/* FALLTHROUGH */\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ofb\", testpropq);\nref_iv = ofb_state;\nref_len = sizeof(ofb_state);\nbreak;\ncase 2:\ntype = EVP_aes_128_gcm();\n/* FALLTHROUGH */\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-gcm\", testpropq);\nref_iv = gcm_state;\nref_len = sizeof(gcm_state);\nbreak;\ntype = EVP_aes_128_ccm();\n/* FALLTHROUGH */\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ccm\", testpropq);\nref_iv = ccm_state;\nref_len = sizeof(ccm_state);\nbreak;\nreturn 1;\ntype = EVP_aes_128_ocb();\n/* FALLTHROUGH */\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ocb\", testpropq);\nref_iv = ocb_state;\nref_len = sizeof(ocb_state);\nbreak;\ndefault:\nreturn 0;\n}\nif (!TEST_ptr(type)\n|| !TEST_ptr((ctx = EVP_CIPHER_CTX_new()))\n|| !TEST_true(EVP_EncryptInit_ex(ctx, type, NULL, key, init_iv))\n|| !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &len, msg,\n(int)sizeof(msg)))\n|| !TEST_true(EVP_CIPHER_CTX_get_original_iv(ctx, oiv, sizeof(oiv)))\n|| !TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))\n|| !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &len)))"
        },
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2330,94 +2379,97 @@  */ static int test_evp_iv(int idx) { #ifndef OPENSSL_NO_OCB #endif+    if (nullprov != NULL && idx < 5)+        return TEST_skip(\"Test does not support a non-default library context\");+-                                EVP_CIPHER_fetch(testctx, \"aes-128-cbc\", NULL);+                                EVP_CIPHER_fetch(testctx, \"aes-128-cbc\", testpropq);-                                EVP_CIPHER_fetch(testctx, \"aes-128-ofb\", NULL);+                                EVP_CIPHER_fetch(testctx, \"aes-128-ofb\", testpropq);-                                EVP_CIPHER_fetch(testctx, \"aes-128-gcm\", NULL);+                                EVP_CIPHER_fetch(testctx, \"aes-128-gcm\", testpropq);-                                EVP_CIPHER_fetch(testctx, \"aes-128-ccm\", NULL);+                                EVP_CIPHER_fetch(testctx, \"aes-128-ccm\", testpropq); #ifdef OPENSSL_NO_OCB #else-                                EVP_CIPHER_fetch(testctx, \"aes-128-ocb\", NULL);+                                EVP_CIPHER_fetch(testctx, \"aes-128-ocb\", testpropq); #endif",
            "commit_date": "2021-03-09 20:42:57+10:00",
            "commit_hash": "062490dbd05a205824a239336f6a60bf00a7ca1d",
            "message": "Add testing for non-default library context into evp_extra_test\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14478)\nint ret = 0;\nEVP_CIPHER_CTX *ctx = NULL;\nunsigned char key[16] = {0x4c, 0x43, 0xdb, 0xdd, 0x42, 0x73, 0x47, 0xd1,\n0xe5, 0x62, 0x7d, 0xcd, 0x4d, 0x76, 0x4d, 0x57};\nunsigned char init_iv[EVP_MAX_IV_LENGTH] =\n{0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98, 0x82,\n0x5a, 0x55, 0x91, 0x81, 0x42, 0xa8, 0x89, 0x34};\nstatic const unsigned char msg[] = { 1, 2, 3, 4, 5, 6, 7, 8,\n9, 10, 11, 12, 13, 14, 15, 16 };\nunsigned char ciphertext[32], oiv[16], iv[16];\nunsigned char *ref_iv;\nunsigned char cbc_state[16] = {0x10, 0x2f, 0x05, 0xcc, 0xc2, 0x55, 0x72, 0xb9,\n0x88, 0xe6, 0x4a, 0x17, 0x10, 0x74, 0x22, 0x5e};\nunsigned char ofb_state[16] = {0x76, 0xe6, 0x66, 0x61, 0xd0, 0x8a, 0xe4, 0x64,\n0xdd, 0x66, 0xbf, 0x00, 0xf0, 0xe3, 0x6f, 0xfd};\nunsigned char gcm_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nunsigned char ccm_state[7] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98};\nunsigned char ocb_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nint len = sizeof(ciphertext);\nsize_t ivlen, ref_len;\nconst EVP_CIPHER *type = NULL;\nswitch(idx) {\ncase 0:\ntype = EVP_aes_128_cbc();\n/* FALLTHROUGH */\ncase 5:\ntype = (type != NULL) ? type :\nref_iv = cbc_state;\nref_len = sizeof(cbc_state);\nbreak;\ncase 1:\ntype = EVP_aes_128_ofb();\n/* FALLTHROUGH */\ncase 6:\ntype = (type != NULL) ? type :\nref_iv = ofb_state;\nref_len = sizeof(ofb_state);\nbreak;\ncase 2:\ntype = EVP_aes_128_gcm();\n/* FALLTHROUGH */\ncase 7:\ntype = (type != NULL) ? type :\nref_iv = gcm_state;\nref_len = sizeof(gcm_state);\nbreak;\ncase 3:\ntype = EVP_aes_128_ccm();\n/* FALLTHROUGH */\ncase 8:\ntype = (type != NULL) ? type :\nref_iv = ccm_state;\nref_len = sizeof(ccm_state);\nbreak;\ncase 4:\ncase 9:\nreturn 1;\ncase 4:\ntype = EVP_aes_128_ocb();\n/* FALLTHROUGH */\ncase 9:\ntype = (type != NULL) ? type :\nref_iv = ocb_state;\nref_len = sizeof(ocb_state);\nbreak;\ndefault:\nreturn 0;\n}\nif (!TEST_ptr(type)\n|| !TEST_ptr((ctx = EVP_CIPHER_CTX_new()))\n|| !TEST_true(EVP_EncryptInit_ex(ctx, type, NULL, key, init_iv))\n|| !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &len, msg,\n(int)sizeof(msg)))\n|| !TEST_true(EVP_CIPHER_CTX_get_original_iv(ctx, oiv, sizeof(oiv)))\n|| !TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))\n|| !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &len)))"
        },
        {
            "author": {
                "email": "tmraz@fedoraproject.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2178,94 +2178,94 @@  */ static int test_evp_iv(int idx) { #ifndef OPENSSL_NO_OCB #endif #ifdef OPENSSL_NO_OCB #else #endif-            || !TEST_true(EVP_CIPHER_CTX_get_iv(ctx, oiv, sizeof(oiv)))-            || !TEST_true(EVP_CIPHER_CTX_get_iv_state(ctx, iv, sizeof(iv)))+            || !TEST_true(EVP_CIPHER_CTX_get_original_iv(ctx, oiv, sizeof(oiv)))+            || !TEST_true(EVP_CIPHER_CTX_get_updated_iv(ctx, iv, sizeof(iv)))",
            "commit_date": "2021-01-14 15:19:46+01:00",
            "commit_hash": "0d83b7b9036feea680ba45751df028ff5e86cd63",
            "message": "Rename EVP_CIPHER_CTX_get_iv and EVP_CIPHER_CTX_get_iv_state for clarity\nTo clarify the purpose of these two calls rename them to\nEVP_CIPHER_CTX_get_original_iv and EVP_CIPHER_CTX_get_updated_iv.\nAlso rename the OSSL_CIPHER_PARAM_IV_STATE to OSSL_CIPHER_PARAM_UPDATED_IV\nto better align with the function name.\nFixes #13411\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13870)\nint ret = 0;\nEVP_CIPHER_CTX *ctx = NULL;\nunsigned char key[16] = {0x4c, 0x43, 0xdb, 0xdd, 0x42, 0x73, 0x47, 0xd1,\n0xe5, 0x62, 0x7d, 0xcd, 0x4d, 0x76, 0x4d, 0x57};\nunsigned char init_iv[EVP_MAX_IV_LENGTH] =\n{0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98, 0x82,\n0x5a, 0x55, 0x91, 0x81, 0x42, 0xa8, 0x89, 0x34};\nstatic const unsigned char msg[] = { 1, 2, 3, 4, 5, 6, 7, 8,\n9, 10, 11, 12, 13, 14, 15, 16 };\nunsigned char ciphertext[32], oiv[16], iv[16];\nunsigned char *ref_iv;\nunsigned char cbc_state[16] = {0x10, 0x2f, 0x05, 0xcc, 0xc2, 0x55, 0x72, 0xb9,\n0x88, 0xe6, 0x4a, 0x17, 0x10, 0x74, 0x22, 0x5e};\nunsigned char ofb_state[16] = {0x76, 0xe6, 0x66, 0x61, 0xd0, 0x8a, 0xe4, 0x64,\n0xdd, 0x66, 0xbf, 0x00, 0xf0, 0xe3, 0x6f, 0xfd};\nunsigned char gcm_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nunsigned char ccm_state[7] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98};\nunsigned char ocb_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,\n0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};\nint len = sizeof(ciphertext);\nsize_t ivlen, ref_len;\nconst EVP_CIPHER *type = NULL;\nswitch(idx) {\ncase 0:\ntype = EVP_aes_128_cbc();\n/* FALLTHROUGH */\ncase 5:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-cbc\", NULL);\nref_iv = cbc_state;\nref_len = sizeof(cbc_state);\nbreak;\ncase 1:\ntype = EVP_aes_128_ofb();\n/* FALLTHROUGH */\ncase 6:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ofb\", NULL);\nref_iv = ofb_state;\nref_len = sizeof(ofb_state);\nbreak;\ncase 2:\ntype = EVP_aes_128_gcm();\n/* FALLTHROUGH */\ncase 7:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-gcm\", NULL);\nref_iv = gcm_state;\nref_len = sizeof(gcm_state);\nbreak;\ncase 3:\ntype = EVP_aes_128_ccm();\n/* FALLTHROUGH */\ncase 8:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ccm\", NULL);\nref_iv = ccm_state;\nref_len = sizeof(ccm_state);\nbreak;\ncase 4:\ncase 9:\nreturn 1;\ncase 4:\ntype = EVP_aes_128_ocb();\n/* FALLTHROUGH */\ncase 9:\ntype = (type != NULL) ? type :\nEVP_CIPHER_fetch(testctx, \"aes-128-ocb\", NULL);\nref_iv = ocb_state;\nref_len = sizeof(ocb_state);\nbreak;\ndefault:\nreturn 0;\n}\nif (!TEST_ptr(type)\n|| !TEST_ptr((ctx = EVP_CIPHER_CTX_new()))\n|| !TEST_true(EVP_EncryptInit_ex(ctx, type, NULL, key, init_iv))\n|| !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &len, msg,\n(int)sizeof(msg)))\n|| !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &len)))"
        },
        {
            "author": {
                "email": "bkaduk@akamai.com",
                "name": "Benjamin Kaduk"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -1816,0 +1820,94 @@+ */+static int test_evp_iv(int idx)+{+    int ret = 0;+    EVP_CIPHER_CTX *ctx = NULL;+    unsigned char key[16] = {0x4c, 0x43, 0xdb, 0xdd, 0x42, 0x73, 0x47, 0xd1,+                             0xe5, 0x62, 0x7d, 0xcd, 0x4d, 0x76, 0x4d, 0x57};+    unsigned char init_iv[EVP_MAX_IV_LENGTH] =+        {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98, 0x82,+         0x5a, 0x55, 0x91, 0x81, 0x42, 0xa8, 0x89, 0x34};+    static const unsigned char msg[] = { 1, 2, 3, 4, 5, 6, 7, 8,+                                         9, 10, 11, 12, 13, 14, 15, 16 };+    unsigned char ciphertext[32], oiv[16], iv[16];+    unsigned char *ref_iv;+    unsigned char cbc_state[16] = {0x10, 0x2f, 0x05, 0xcc, 0xc2, 0x55, 0x72, 0xb9,+                                   0x88, 0xe6, 0x4a, 0x17, 0x10, 0x74, 0x22, 0x5e};++    unsigned char ofb_state[16] = {0x76, 0xe6, 0x66, 0x61, 0xd0, 0x8a, 0xe4, 0x64,+                                   0xdd, 0x66, 0xbf, 0x00, 0xf0, 0xe3, 0x6f, 0xfd};+    unsigned char gcm_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,+                                   0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};+    unsigned char ccm_state[7] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b, 0x98};+#ifndef OPENSSL_NO_OCB+    unsigned char ocb_state[12] = {0x57, 0x71, 0x7d, 0xad, 0xdb, 0x9b,+                                   0x98, 0x82, 0x5a, 0x55, 0x91, 0x81};+#endif+    int len = sizeof(ciphertext);+    size_t ivlen, ref_len;+    const EVP_CIPHER *type = NULL;++    switch(idx) {+    case 0:+        type = EVP_aes_128_cbc();+        /* FALLTHROUGH */+    case 5:+        type = (type != NULL) ? type :+                                EVP_CIPHER_fetch(testctx, \"aes-128-cbc\", NULL);+        ref_iv = cbc_state;+        ref_len = sizeof(cbc_state);+        break;+    case 1:+        type = EVP_aes_128_ofb();+        /* FALLTHROUGH */+    case 6:+        type = (type != NULL) ? type :+                                EVP_CIPHER_fetch(testctx, \"aes-128-ofb\", NULL);+        ref_iv = ofb_state;+        ref_len = sizeof(ofb_state);+        break;+    case 2:+        type = EVP_aes_128_gcm();+        /* FALLTHROUGH */+    case 7:+        type = (type != NULL) ? type :+                                EVP_CIPHER_fetch(testctx, \"aes-128-gcm\", NULL);+        ref_iv = gcm_state;+        ref_len = sizeof(gcm_state);+        break;+    case 3:+        type = EVP_aes_128_ccm();+        /* FALLTHROUGH */+    case 8:+        type = (type != NULL) ? type :+                                EVP_CIPHER_fetch(testctx, \"aes-128-ccm\", NULL);+        ref_iv = ccm_state;+        ref_len = sizeof(ccm_state);+        break;+#ifdef OPENSSL_NO_OCB+    case 4:+    case 9:+        return 1;+#else+    case 4:+        type = EVP_aes_128_ocb();+        /* FALLTHROUGH */+    case 9:+        type = (type != NULL) ? type :+                                EVP_CIPHER_fetch(testctx, \"aes-128-ocb\", NULL);+        ref_iv = ocb_state;+        ref_len = sizeof(ocb_state);+        break;+#endif+    default:+        return 0;+    }++    if (!TEST_ptr(type)+            || !TEST_ptr((ctx = EVP_CIPHER_CTX_new()))+            || !TEST_true(EVP_EncryptInit_ex(ctx, type, NULL, key, init_iv))+            || !TEST_true(EVP_EncryptUpdate(ctx, ciphertext, &len, msg,+                          (int)sizeof(msg)))+            || !TEST_true(EVP_CIPHER_CTX_get_iv(ctx, oiv, sizeof(oiv)))+            || !TEST_true(EVP_CIPHER_CTX_get_iv_state(ctx, iv, sizeof(iv)))+            || !TEST_true(EVP_EncryptFinal_ex(ctx, ciphertext, &len)))",
            "commit_date": "2020-06-19 20:42:29-07:00",
            "commit_hash": "440b852a0f79ac4a7e101606a7c32d212e06d203",
            "message": "Add tests for new EVP_CIPHER_CTX IV accessors\nTest that EVP_CIPHER_CTX_get_iv() returns the same IV that was\ngiven at initialization time, and that EVP_CIPHER_CTX_get_iv_state()\nreturns the expected value after performing an encryption operation\n(which will differ from the previous value for CBC and OFB modes),\nfor various modes of AES.\nDo this both for the implicit fetch and explicit fetch paths,\nat the cost of a slightly more complicated switch statement.\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/12233)"
        }
    ],
    "git log -L712,750:test/destest.c": [
        {
            "author": {
                "email": "pauli@openssl.org",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/destest.c b/test/destest.c--- a/test/destest.c+++ b/test/destest.c@@ -700,0 +712,39 @@+{+    int in_bytes = test_des_key_wrap_sizes[idx];+    unsigned char in[100], c_txt[200], p_txt[200], key[24];+    int clen, clen_upd, clen_fin, plen, plen_upd, plen_fin, expect, bs, i;+    EVP_CIPHER *cipher = NULL;+    EVP_CIPHER_CTX *ctx = NULL;+    int res = 0;++    /* Some sanity checks and cipher loading */+    if (!TEST_size_t_le(in_bytes, sizeof(in))+            || !TEST_ptr(cipher = EVP_CIPHER_fetch(NULL, \"DES3-WRAP\", NULL))+            || !TEST_int_eq(bs = EVP_CIPHER_get_block_size(cipher), 8)+            || !TEST_size_t_eq(bs * 3u, sizeof(key))+            || !TEST_true(in_bytes % bs == 0)+            || !TEST_ptr(ctx = EVP_CIPHER_CTX_new()))+        goto err;++    /* Create random data to end to end test */+    for (i = 0; i < in_bytes; i++)+        in[i] = test_random();++    /* Build the key */+    memcpy(key, cbc_key, sizeof(cbc_key));+    memcpy(key + sizeof(cbc_key), cbc2_key, sizeof(cbc2_key));+    memcpy(key + sizeof(cbc_key) + sizeof(cbc3_key), cbc_key, sizeof(cbc3_key));++    /* Wrap / encrypt the key */+    clen_upd = sizeof(c_txt);+    if (!TEST_true(EVP_EncryptInit(ctx, cipher, key, NULL))+            || !TEST_true(EVP_EncryptUpdate(ctx, c_txt, &clen_upd,+                                            in, in_bytes)))+        goto err;++    expect = (in_bytes + (bs - 1)) / bs * bs + 2 * bs;+    if (!TEST_int_eq(clen_upd, expect))+        goto err;++    clen_fin = sizeof(c_txt) - clen_upd;+    if (!TEST_true(EVP_EncryptFinal(ctx, c_txt + clen_upd, &clen_fin))",
            "commit_date": "2021-08-18 11:58:11+10:00",
            "commit_hash": "3d491c054ea8f662dc9dc499d3029d126a8726d3",
            "message": "test: add unit tests for TDES key wrap\nThis functionality was completely untested.\nDoesn't fix #16002 since that's a bug against 1.1.1.\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16343)"
        }
    ],
    "git log -L3679,3710:test/evp_extra_test.c": [
        {
            "author": {
                "email": "jchrist@linux.ibm.com",
                "name": "Juergen Christ"
            },
            "changes": "diff --git a/test/evp_extra_test.c b/test/evp_extra_test.c--- a/test/evp_extra_test.c+++ b/test/evp_extra_test.c@@ -2898,0 +3176,32 @@+ */+static int test_evp_reset(int idx)+{+    const EVP_RESET_TEST_st *t = &evp_reset_tests[idx];+    int outlen1, outlen2;+    int testresult = 0;+    unsigned char outbuf[1024];+    EVP_CIPHER_CTX *ctx = NULL;+    EVP_CIPHER *type = NULL;+    char *errmsg = NULL;++    if (!TEST_ptr(ctx = EVP_CIPHER_CTX_new())) {+        errmsg = \"CTX_ALLOC\";+        goto err;+    }+    if (!TEST_ptr(type = EVP_CIPHER_fetch(testctx, \"aes-128-cfb\", testpropq))) {+        errmsg = \"CIPHER_FETCH\";+        goto err;+    }+    if (!TEST_true(EVP_CipherInit_ex(ctx, type, NULL, kCFBDefaultKey, iCFBIV, t->enc))) {+        errmsg = \"CIPHER_INIT\";+        goto err;+    }+    if (!TEST_true(EVP_CIPHER_CTX_set_padding(ctx, 0))) {+        errmsg = \"PADDING\";+        goto err;+    }+    if (!TEST_true(EVP_CipherUpdate(ctx, outbuf, &outlen1, t->input, t->inlen))) {+        errmsg = \"CIPHER_UPDATE\";+        goto err;+    }+    if (!TEST_true(EVP_CipherFinal_ex(ctx, outbuf + outlen1, &outlen2))) {",
            "commit_date": "2021-06-02 19:33:50+02:00",
            "commit_hash": "063e019738b90fcf0a3ab7b1654ce8976805b0b3",
            "message": "Test EVP_CipherInit sequences and resets\nVarious EVP_CipherInit sequences including partial inits and initializations\nwith different \"enc\" flags caused problems on s390x.  Similarly, cipher\nreinitialization and especially GCM reinitialization with different tag length\nled to wrong results.  Add some unit tests to cover these rather exotic use\ncases.\nSigned-off-by: Juergen Christ <jchrist@linux.ibm.com>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15521)"
        }
    ],
    "git log -L1352,1395:crypto/evp/ctrl_params_translate.c": [
        {
            "author": {
                "email": "jchrist@linux.ibm.com",
                "name": "Juergen Christ"
            },
            "changes": "diff --git a/crypto/evp/ctrl_params_translate.c b/crypto/evp/ctrl_params_translate.c--- a/crypto/evp/ctrl_params_translate.c+++ b/crypto/evp/ctrl_params_translate.c@@ -1314,44 +1314,44 @@ /* EVP_PKEY_CTRL_RSA_PSS_SALTLEN, EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN */ static int fix_rsa_pss_saltlen(enum state state, {-            strncpy(ctx->name_buf, str_value_map[i].ptr, sizeof(ctx->name_buf));+            strncpy(ctx->name_buf, str_value_map[i].ptr, sizeof(ctx->name_buf) - 1);",
            "commit_date": "2021-07-05 09:48:53+02:00",
            "commit_hash": "daf4b2437f38bd104400517cf8ff2c8121813b1a",
            "message": "Fix compile warning with GCC 11.\nWhen configured with strict warnings, GCC 11 complains about a possible\nstringop-translation:\nConfig:\n/usr/bin/perl ./Configure enable-asan enable-ubsan enable-zlib-dynamic \\\nenable-unit-test enable-md2 enable-rc5 enable-buildtest-c++ \\\nenable-weak-ssl-ciphers enable-ssl3 enable-ssl3-method enable-fips -w \\\n--strict-warnings\nWarning:\ncrypto/evp/ctrl_params_translate.c: In function 'fix_rsa_pss_saltlen':\ncrypto/evp/ctrl_params_translate.c:1356:13: error: 'strncpy' specified bound 50 equals destination size [-Werror=stringop-truncation]\n1356 |             strncpy(ctx->name_buf, str_value_map[i].ptr, sizeof(ctx->name_buf));\n|             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nFix by copying one byte less than the buffer size.  We anyway overwrite the\nlast byte.\nSigned-off-by: Juergen Christ <jchrist@linux.ibm.com>\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15993)\nconst struct translation_st *translation,\nstruct translation_ctx_st *ctx)\nstatic const OSSL_ITEM str_value_map[] = {\n{ (unsigned int)RSA_PSS_SALTLEN_DIGEST, \"digest\" },\n{ (unsigned int)RSA_PSS_SALTLEN_MAX,    \"max\"    },\n{ (unsigned int)RSA_PSS_SALTLEN_AUTO,   \"auto\"   }\n};\nint ret;\nif ((ret = default_check(state, translation, ctx)) <= 0)\nreturn ret;\nif (state == PRE_CTRL_TO_PARAMS && ctx->action_type == GET) {\n/*\n* EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN returns the saltlen by filling\n* in the int pointed at by p2.  This is potentially as weird as\n* the way EVP_PKEY_CTRL_GET_RSA_PADDING works, except that saltlen\n* might be a negative value, so it wouldn't work as a legitimate\n* return value.\n* In any case, we must therefore remember |ctx->p2|, then make\n* |ctx->p2| point at a buffer to be filled in with the name, and\n* |ctx->p1| with its size.  default_fixup_args() will take care\n* of the rest for us, along with the POST_CTRL_TO_PARAMS && GET\n* code section further down.\n*/\nctx->orig_p2 = ctx->p2;\nctx->p2 = ctx->name_buf;\nctx->p1 = sizeof(ctx->name_buf);\n} else if ((ctx->action_type == SET && state == PRE_CTRL_TO_PARAMS)\n|| (ctx->action_type == GET && state == POST_PARAMS_TO_CTRL)) {\nsize_t i;\nfor (i = 0; i < OSSL_NELEM(str_value_map); i++) {\nif (ctx->p1 == (int)str_value_map[i].id)\nbreak;\n}\nif (i == OSSL_NELEM(str_value_map)) {\nBIO_snprintf(ctx->name_buf, sizeof(ctx->name_buf), \"%d\", ctx->p1);\n} else {\n/* This won't truncate but it will quiet static analysers */"
        },
        {
            "author": {
                "email": "pauli@openssl.org",
                "name": "Pauli"
            },
            "changes": "diff --git a/crypto/evp/ctrl_params_translate.c b/crypto/evp/ctrl_params_translate.c--- a/crypto/evp/ctrl_params_translate.c+++ b/crypto/evp/ctrl_params_translate.c@@ -1314,43 +1314,44 @@ /* EVP_PKEY_CTRL_RSA_PSS_SALTLEN, EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN */ static int fix_rsa_pss_saltlen(enum state state, {-            strcpy(ctx->name_buf, str_value_map[i].ptr);+            strncpy(ctx->name_buf, str_value_map[i].ptr, sizeof(ctx->name_buf));+            /* This won't truncate but it will quiet static analysers */",
            "commit_date": "2021-06-29 08:26:11+10:00",
            "commit_hash": "5e56f4587de2f2e06c079272fa4d6712d56dbcf0",
            "message": "evp: fix coverity 1473380 Copy into fixed size buffer (STRING_OVERFLOW)\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15943)\nconst struct translation_st *translation,\nstruct translation_ctx_st *ctx)\nstatic const OSSL_ITEM str_value_map[] = {\n{ (unsigned int)RSA_PSS_SALTLEN_DIGEST, \"digest\" },\n{ (unsigned int)RSA_PSS_SALTLEN_MAX,    \"max\"    },\n{ (unsigned int)RSA_PSS_SALTLEN_AUTO,   \"auto\"   }\n};\nint ret;\nif ((ret = default_check(state, translation, ctx)) <= 0)\nreturn ret;\nif (state == PRE_CTRL_TO_PARAMS && ctx->action_type == GET) {\n/*\n* EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN returns the saltlen by filling\n* in the int pointed at by p2.  This is potentially as weird as\n* the way EVP_PKEY_CTRL_GET_RSA_PADDING works, except that saltlen\n* might be a negative value, so it wouldn't work as a legitimate\n* return value.\n* In any case, we must therefore remember |ctx->p2|, then make\n* |ctx->p2| point at a buffer to be filled in with the name, and\n* |ctx->p1| with its size.  default_fixup_args() will take care\n* of the rest for us, along with the POST_CTRL_TO_PARAMS && GET\n* code section further down.\n*/\nctx->orig_p2 = ctx->p2;\nctx->p2 = ctx->name_buf;\nctx->p1 = sizeof(ctx->name_buf);\n} else if ((ctx->action_type == SET && state == PRE_CTRL_TO_PARAMS)\n|| (ctx->action_type == GET && state == POST_PARAMS_TO_CTRL)) {\nsize_t i;\nfor (i = 0; i < OSSL_NELEM(str_value_map); i++) {\nif (ctx->p1 == (int)str_value_map[i].id)\nbreak;\n}\nif (i == OSSL_NELEM(str_value_map)) {\nBIO_snprintf(ctx->name_buf, sizeof(ctx->name_buf), \"%d\", ctx->p1);\n} else {"
        },
        {
            "author": {
                "email": "ppzgs1@gmail.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/crypto/evp/ctrl_params_translate.c b/crypto/evp/ctrl_params_translate.c--- a/crypto/evp/ctrl_params_translate.c+++ b/crypto/evp/ctrl_params_translate.c@@ -1307,43 +1307,43 @@ /* EVP_PKEY_CTRL_RSA_PSS_SALTLEN, EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN */ static int fix_rsa_pss_saltlen(enum state state, {-            BIO_snprintf(ctx->name_buf, 5, \"%d\", ctx->p1);+            BIO_snprintf(ctx->name_buf, sizeof(ctx->name_buf), \"%d\", ctx->p1);",
            "commit_date": "2021-03-19 08:22:43+10:00",
            "commit_hash": "abded2ced44b94d96f08ea5cf01df6519b80f5d3",
            "message": "evp: fix coverity 1473380: copy into fixed size buffer\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14614)\nconst struct translation_st *translation,\nstruct translation_ctx_st *ctx)\nstatic const OSSL_ITEM str_value_map[] = {\n{ (unsigned int)RSA_PSS_SALTLEN_DIGEST, \"digest\" },\n{ (unsigned int)RSA_PSS_SALTLEN_MAX,    \"max\"    },\n{ (unsigned int)RSA_PSS_SALTLEN_AUTO,   \"auto\"   }\n};\nint ret;\nif ((ret = default_check(state, translation, ctx)) <= 0)\nreturn ret;\nif (state == PRE_CTRL_TO_PARAMS && ctx->action_type == GET) {\n/*\n* EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN returns the saltlen by filling\n* in the int pointed at by p2.  This is potentially as weird as\n* the way EVP_PKEY_CTRL_GET_RSA_PADDING works, except that saltlen\n* might be a negative value, so it wouldn't work as a legitimate\n* return value.\n* In any case, we must therefore remember |ctx->p2|, then make\n* |ctx->p2| point at a buffer to be filled in with the name, and\n* |ctx->p1| with its size.  default_fixup_args() will take care\n* of the rest for us, along with the POST_CTRL_TO_PARAMS && GET\n* code section further down.\n*/\nctx->orig_p2 = ctx->p2;\nctx->p2 = ctx->name_buf;\nctx->p1 = sizeof(ctx->name_buf);\n} else if ((ctx->action_type == SET && state == PRE_CTRL_TO_PARAMS)\n|| (ctx->action_type == GET && state == POST_PARAMS_TO_CTRL)) {\nsize_t i;\nfor (i = 0; i < OSSL_NELEM(str_value_map); i++) {\nif (ctx->p1 == (int)str_value_map[i].id)\nbreak;\n}\nif (i == OSSL_NELEM(str_value_map)) {\n} else {\nstrcpy(ctx->name_buf, str_value_map[i].ptr);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/evp/ctrl_params_translate.c b/crypto/evp/ctrl_params_translate.c--- /dev/null+++ b/crypto/evp/ctrl_params_translate.c@@ -0,0 +1304,43 @@+/* EVP_PKEY_CTRL_RSA_PSS_SALTLEN, EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN */+static int fix_rsa_pss_saltlen(enum state state,+                               const struct translation_st *translation,+                               struct translation_ctx_st *ctx)+{+    static const OSSL_ITEM str_value_map[] = {+        { (unsigned int)RSA_PSS_SALTLEN_DIGEST, \"digest\" },+        { (unsigned int)RSA_PSS_SALTLEN_MAX,    \"max\"    },+        { (unsigned int)RSA_PSS_SALTLEN_AUTO,   \"auto\"   }+    };+    int ret;++    if ((ret = default_check(state, translation, ctx)) <= 0)+        return ret;++    if (state == PRE_CTRL_TO_PARAMS && ctx->action_type == GET) {+        /*+         * EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN returns the saltlen by filling+         * in the int pointed at by p2.  This is potentially as weird as+         * the way EVP_PKEY_CTRL_GET_RSA_PADDING works, except that saltlen+         * might be a negative value, so it wouldn't work as a legitimate+         * return value.+         * In any case, we must therefore remember |ctx->p2|, then make+         * |ctx->p2| point at a buffer to be filled in with the name, and+         * |ctx->p1| with its size.  default_fixup_args() will take care+         * of the rest for us, along with the POST_CTRL_TO_PARAMS && GET+         * code section further down.+         */+        ctx->orig_p2 = ctx->p2;+        ctx->p2 = ctx->name_buf;+        ctx->p1 = sizeof(ctx->name_buf);+    } else if ((ctx->action_type == SET && state == PRE_CTRL_TO_PARAMS)+        || (ctx->action_type == GET && state == POST_PARAMS_TO_CTRL)) {+        size_t i;++        for (i = 0; i < OSSL_NELEM(str_value_map); i++) {+            if (ctx->p1 == (int)str_value_map[i].id)+                break;+        }+        if (i == OSSL_NELEM(str_value_map)) {+            BIO_snprintf(ctx->name_buf, 5, \"%d\", ctx->p1);+        } else {+            strcpy(ctx->name_buf, str_value_map[i].ptr);",
            "commit_date": "2021-01-20 23:04:53+01:00",
            "commit_hash": "9a1c4e41e8d3fd8fe9d1bd8eeb8b1e1df21da37f",
            "message": "EVP: Implement data-driven translation between known ctrl and OSSL_PARAMs\nThe idea is to make it as transparent as possible to call things like\nEVP_PKEY_CTX_ctrl() with a provider backed EVP_PKEY_CTX, or things\nlike EVP_PKEY_get_bn_param() with a legacy EVP_PKEY.\nAll these sorts of calls demand that we translate between ctrl\ncommands and OSSL_PARAM keys, and treat the arguments appropriately.\nThis implementation has it being as data driven as possible, thereby\ncentralizing everything into one table of translation data, which\nsupports both directions.\nFixes #13528\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13913)"
        }
    ],
    "git log -L8534,8591:test/sslapitest.c": [
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -8440,58 +8440,58 @@ static int test_multiblock_write(int test_index) {-    ciph = EVP_CIPHER_fetch(NULL, fetchable_ciphers[test_index], \"\");+    ciph = EVP_CIPHER_fetch(libctx, fetchable_ciphers[test_index], \"\");",
            "commit_date": "2022-08-11 12:02:44+01:00",
            "commit_hash": "7c82a7a8f3a66f47f727d31691d6298d88ed158b",
            "message": "Don't incorrectly skip the multiblock test\nsslapitest has a test for multiblock writes. Since multiblock writing is\nonly available on some platforms the multiblock test checks whether we are\non such a platform first, and skips the test if we are not. Unfortunately\na bug in the check meant that we always skipped the test regardless of the\nplatform.\nReviewed-by: Dmitry Belyavskiy <beldmit@gmail.com>\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Hugo Landau <hlandau@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/18983)\nstatic const char *fetchable_ciphers[]=\n{\n\"AES-128-CBC-HMAC-SHA1\",\n\"AES-128-CBC-HMAC-SHA256\",\n\"AES-256-CBC-HMAC-SHA1\",\n\"AES-256-CBC-HMAC-SHA256\"\n};\nconst char *cipherlist = multiblock_cipherlist_data[test_index];\nconst SSL_METHOD *smeth = TLS_server_method();\nconst SSL_METHOD *cmeth = TLS_client_method();\nint min_version = TLS1_VERSION;\nint max_version = TLS1_2_VERSION; /* Don't select TLS1_3 */\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\n/*\n* Choose a buffer large enough to perform a multi-block operation\n* i.e: write_len >= 4 * frag_size\n* 9 * is chosen so that multiple multiblocks are used + some leftover.\n*/\nunsigned char msg[MULTIBLOCK_FRAGSIZE * 9];\nunsigned char buf[sizeof(msg)], *p = buf;\nsize_t readbytes, written, len;\nEVP_CIPHER *ciph = NULL;\n/*\n* Check if the cipher exists before attempting to use it since it only has\n* a hardware specific implementation.\n*/\nif (ciph == NULL) {\nTEST_skip(\"Multiblock cipher is not available for %s\", cipherlist);\nreturn 1;\n}\nEVP_CIPHER_free(ciph);\n/* Set up a buffer with some data that will be sent to the client */\nRAND_bytes(msg, sizeof(msg));\nif (!TEST_true(create_ssl_ctx_pair(libctx, smeth, cmeth, min_version,\nmax_version, &sctx, &cctx, cert,\nprivkey)))\ngoto end;\nif (!TEST_true(SSL_CTX_set_max_send_fragment(sctx, MULTIBLOCK_FRAGSIZE)))\ngoto end;\nif (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,\nNULL, NULL)))\ngoto end;\n/* settings to force it to use AES-CBC-HMAC_SHA */\nSSL_set_options(serverssl, SSL_OP_NO_ENCRYPT_THEN_MAC);\nif (!TEST_true(SSL_CTX_set_cipher_list(cctx, cipherlist)))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -6996,57 +7019,58 @@ static int test_multiblock_write(int test_index) {-    if (!TEST_true(create_ssl_ctx_pair(smeth, cmeth, min_version, max_version,-                                       &sctx, &cctx, cert, privkey)))+    if (!TEST_true(create_ssl_ctx_pair(libctx, smeth, cmeth, min_version,+                                       max_version, &sctx, &cctx, cert,+                                       privkey)))",
            "commit_date": "2020-03-18 17:17:37+00:00",
            "commit_hash": "5e30f2fd58bac0db5c23e33e865fa70bd6eb4349",
            "message": "Use a non-default libctx in sslapitest\nWe also don't load the default provider into the default libctx to make\nsure there is no accidental \"leakage\".\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/11508)\nstatic const char *fetchable_ciphers[]=\n{\n\"AES-128-CBC-HMAC-SHA1\",\n\"AES-128-CBC-HMAC-SHA256\",\n\"AES-256-CBC-HMAC-SHA1\",\n\"AES-256-CBC-HMAC-SHA256\"\n};\nconst char *cipherlist = multiblock_cipherlist_data[test_index];\nconst SSL_METHOD *smeth = TLS_server_method();\nconst SSL_METHOD *cmeth = TLS_client_method();\nint min_version = TLS1_VERSION;\nint max_version = TLS1_2_VERSION; /* Don't select TLS1_3 */\nSSL_CTX *cctx = NULL, *sctx = NULL;\nSSL *clientssl = NULL, *serverssl = NULL;\nint testresult = 0;\n/*\n* Choose a buffer large enough to perform a multi-block operation\n* i.e: write_len >= 4 * frag_size\n* 9 * is chosen so that multiple multiblocks are used + some leftover.\n*/\nunsigned char msg[MULTIBLOCK_FRAGSIZE * 9];\nunsigned char buf[sizeof(msg)], *p = buf;\nsize_t readbytes, written, len;\nEVP_CIPHER *ciph = NULL;\n/*\n* Check if the cipher exists before attempting to use it since it only has\n* a hardware specific implementation.\n*/\nciph = EVP_CIPHER_fetch(NULL, fetchable_ciphers[test_index], \"\");\nif (ciph == NULL) {\nTEST_skip(\"Multiblock cipher is not available for %s\", cipherlist);\nreturn 1;\n}\nEVP_CIPHER_free(ciph);\n/* Set up a buffer with some data that will be sent to the client */\nRAND_bytes(msg, sizeof(msg));\ngoto end;\nif (!TEST_true(SSL_CTX_set_max_send_fragment(sctx, MULTIBLOCK_FRAGSIZE)))\ngoto end;\nif (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,\nNULL, NULL)))\ngoto end;\n/* settings to force it to use AES-CBC-HMAC_SHA */\nSSL_set_options(serverssl, SSL_OP_NO_ENCRYPT_THEN_MAC);\nif (!TEST_true(SSL_CTX_set_cipher_list(cctx, cipherlist)))"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/sslapitest.c b/test/sslapitest.c--- a/test/sslapitest.c+++ b/test/sslapitest.c@@ -6823,0 +6834,57 @@++static int test_multiblock_write(int test_index)+{+    static const char *fetchable_ciphers[]=+    {+        \"AES-128-CBC-HMAC-SHA1\",+        \"AES-128-CBC-HMAC-SHA256\",+        \"AES-256-CBC-HMAC-SHA1\",+        \"AES-256-CBC-HMAC-SHA256\"+    };+    const char *cipherlist = multiblock_cipherlist_data[test_index];+    const SSL_METHOD *smeth = TLS_server_method();+    const SSL_METHOD *cmeth = TLS_client_method();+    int min_version = TLS1_VERSION;+    int max_version = TLS1_2_VERSION; /* Don't select TLS1_3 */+    SSL_CTX *cctx = NULL, *sctx = NULL;+    SSL *clientssl = NULL, *serverssl = NULL;+    int testresult = 0;++    /*+     * Choose a buffer large enough to perform a multi-block operation+     * i.e: write_len >= 4 * frag_size+     * 9 * is chosen so that multiple multiblocks are used + some leftover.+     */+    unsigned char msg[MULTIBLOCK_FRAGSIZE * 9];+    unsigned char buf[sizeof(msg)], *p = buf;+    size_t readbytes, written, len;+    EVP_CIPHER *ciph = NULL;++    /*+     * Check if the cipher exists before attempting to use it since it only has+     * a hardware specific implementation.+     */+    ciph = EVP_CIPHER_fetch(NULL, fetchable_ciphers[test_index], \"\");+    if (ciph == NULL) {+        TEST_skip(\"Multiblock cipher is not available for %s\", cipherlist);+        return 1;+    }+    EVP_CIPHER_free(ciph);++    /* Set up a buffer with some data that will be sent to the client */+    RAND_bytes(msg, sizeof(msg));++    if (!TEST_true(create_ssl_ctx_pair(smeth, cmeth, min_version, max_version,+                                       &sctx, &cctx, cert, privkey)))+        goto end;++    if (!TEST_true(SSL_CTX_set_max_send_fragment(sctx, MULTIBLOCK_FRAGSIZE)))+        goto end;++    if (!TEST_true(create_ssl_objects(sctx, cctx, &serverssl, &clientssl,+                                      NULL, NULL)))+            goto end;++    /* settings to force it to use AES-CBC-HMAC_SHA */+    SSL_set_options(serverssl, SSL_OP_NO_ENCRYPT_THEN_MAC);+    if (!TEST_true(SSL_CTX_set_cipher_list(cctx, cipherlist)))",
            "commit_date": "2020-01-06 13:02:16+10:00",
            "commit_hash": "0d2bfe52bb7e839f7bddcdb1160c335f2994df2f",
            "message": "Add AES_CBC_HMAC_SHA ciphers to providers.\nAlso Add ability for providers to dynamically exclude cipher algorithms.\nCipher algorithms are only returned from providers if their capable() method is either NULL,\nor the method returns 1.\nThis is mainly required for ciphers that only have hardware implementations.\nIf there is no hardware support, then the algorithm needs to be not available.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/10146)"
        }
    ],
    "git log -L405,415:test/bftest.c": [
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/bftest.c b/test/bftest.c--- a/test/bftest.c+++ b/test/bftest.c@@ -410,2 +412,11 @@-    /* OFB64 Mode */++static int test_bf_ofb64(void)+{+    unsigned char cbc_in[40], cbc_out[40], iv[8];+    int n, ret = 1;+    BF_KEY key;+    BF_LONG len;++    len = strlen(cbc_data) + 1;+",
            "commit_date": "2017-04-12 11:03:29+10:00",
            "commit_hash": "56bf5c55cd7d751390e92aad2b2bd9cc031b1e43",
            "message": "Code review. Split tests up\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3177)\nBF_set_key(&key, 16, cbc_key);"
        },
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/bftest.c b/test/bftest.c--- a/test/bftest.c+++ b/test/bftest.c@@ -458,1 +410,2 @@+    /* OFB64 Mode */",
            "commit_date": "2017-04-11 14:31:28+10:00",
            "commit_hash": "70e1acd786511724e3680790f358d1fc4756a49b",
            "message": "Convert blowfish tests to new framework\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3177)\nBF_set_key(&key, 16, cbc_key);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -356,184 +512,1 @@-\t{-\tunsigned char cbc_in[40],cbc_out[40],iv[8];-\tint i,n,err=0;-\tBF_KEY key;-\tBF_LONG data[2]; -\tunsigned char out[8]; -\tBF_LONG len;--#ifdef CHARSET_EBCDIC-\tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data));-#endif--\tprintf(\"testing blowfish in raw ecb mode\\n\");-\tfor (n=0; n<2; n++)-\t\t{-#ifdef CHARSET_EBCDIC-\t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n]));-#endif-\t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]);--\t\tdata[0]=bf_plain[n][0];-\t\tdata[1]=bf_plain[n][1];-\t\tBF_encrypt(data,&key);-\t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_encrypt error encrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]);-\t\t\terr=1;-\t\t\tprintf(\"\\n\");-\t\t\t}--\t\tBF_decrypt(&(data[0]),&key);-\t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_encrypt error decrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]);-\t\t\tprintf(\"\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish in ecb mode\\n\");--\tfor (n=0; n<NUM_TESTS; n++)-\t\t{-\t\tBF_set_key(&key,8,ecb_data[n]);--\t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT);-\t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",out[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",cipher_data[n][i]);-\t\t\terr=1;-\t\t\tprintf(\"\\n\");-\t\t\t}--\t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT);-\t\tif (memcmp(&(plain_data[n][0]),out,8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",out[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",plain_data[n][i]);-\t\t\tprintf(\"\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish set_key\\n\");-\tfor (n=1; n<KEY_TEST_NUM; n++)-\t\t{-\t\tBF_set_key(&key,n,key_test);-\t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);-\t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */-\t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"blowfish setkey error\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish in cbc mode\\n\");-\tlen=strlen(cbc_data)+1;--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,sizeof cbc_in);-\tmemset(cbc_out,0,sizeof cbc_out);-\tmemcpy(iv,cbc_iv,sizeof iv);-\tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len,-\t\t&key,iv,BF_ENCRYPT);-\tif (memcmp(cbc_out,cbc_ok,32) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_cbc_encrypt encrypt error\\n\");-\t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tmemcpy(iv,cbc_iv,8);-\tBF_cbc_encrypt(cbc_out,cbc_in,len,-\t\t&key,iv,BF_DECRYPT);-\tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)-\t\t{-\t\tprintf(\"BF_cbc_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\tprintf(\"testing blowfish in cfb64 mode\\n\");--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);-\tn=0;-\tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,-\t\t&key,iv,&n,BF_ENCRYPT);-\tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13,-\t\t&key,iv,&n,BF_ENCRYPT);-\tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\");-\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tn=0;-\tmemcpy(iv,cbc_iv,8);-\tBF_cfb64_encrypt(cbc_out,cbc_in,17,-\t\t&key,iv,&n,BF_DECRYPT);-\tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,-\t\t&key,iv,&n,BF_DECRYPT);-\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)-\t\t{-\t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\tprintf(\"testing blowfish in ofb64\\n\");--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);-\tn=0;-\tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n);-\tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]),-\t\t&(cbc_out[13]),len-13,&key,iv,&n);-\tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\");-\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tn=0;-\tmemcpy(iv,cbc_iv,8);-\tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n);-\tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n);-\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)-\t\t{-\t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\treturn(err);-\t}+    BF_set_key(&key, 16, cbc_key);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -350,184 +350,184 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; #ifdef CHARSET_EBCDIC \tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data)); #endif \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ #ifdef CHARSET_EBCDIC \t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n])); #endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */ \t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);+\tmemset(cbc_in,0,sizeof cbc_in);+\tmemset(cbc_out,0,sizeof cbc_out);+\tmemcpy(iv,cbc_iv,sizeof iv); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "2002-11-13 15:43:43+00:00",
            "commit_hash": "54a656ef081f72a740c550ebd8099b40b8b5cde0",
            "message": "Security fixes brought forward from 0.9.7."
        },
        {
            "author": {
                "email": "appro@openssl.org",
                "name": "Andy Polyakov"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -350,183 +350,184 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; #ifdef CHARSET_EBCDIC \tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data)); #endif \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ #ifdef CHARSET_EBCDIC \t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n])); #endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);-\t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0)+\t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */+\t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "2000-06-05 14:39:47+00:00",
            "commit_hash": "e6441154fc8365f0be481d9f619caedc019283d6",
            "message": "GCC 2.95.2 from IRIX 6.5 -mabi=64 compiler bug workaround:-(\nSubmitted by:\nReviewed by:\nPR:"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -346,176 +350,183 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len;+#ifdef CHARSET_EBCDIC+\tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data));+#endif+ \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{+#ifdef CHARSET_EBCDIC+\t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n]));+#endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1999-06-04 21:35:58+00:00",
            "commit_hash": "a53955d8abd68c604de02cc1e101c66169207fb7",
            "message": "Support the EBCDIC character set and BS2000/OSD-POSIX (work in progress).\nSubmitted by: Martin Kraemer <Martin.Kraemer@MchP.Siemens.De>"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -344,176 +344,176 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",bf_plain[n][i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1999-04-20 22:48:55+00:00",
            "commit_hash": "f36cd05b22a587e552c97797b54fd07bc0762446",
            "message": "Fix some warnings."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -346,176 +346,176 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1];-\t\tBF_encrypt(data,&key,BF_ENCRYPT);+\t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t}-\t\tBF_encrypt(&(data[0]),&key,BF_DECRYPT);+\t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1998-12-21 10:56:39+00:00",
            "commit_hash": "58964a492275ca9a59a0cd9c8155cb2491b4b909",
            "message": "Import of old SSLeay release: SSLeay 0.9.0b"
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- /dev/null+++ b/crypto/bf/bftest.c@@ -0,0 +346,176 @@+\t{+\tunsigned char cbc_in[40],cbc_out[40],iv[8];+\tint i,n,err=0;+\tBF_KEY key;+\tBF_LONG data[2]; +\tunsigned char out[8]; +\tBF_LONG len;++\tprintf(\"testing blowfish in raw ecb mode\\n\");+\tfor (n=0; n<2; n++)+\t\t{+\t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]);++\t\tdata[0]=bf_plain[n][0];+\t\tdata[1]=bf_plain[n][1];+\t\tBF_encrypt(data,&key,BF_ENCRYPT);+\t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_encrypt error encrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]);+\t\t\terr=1;+\t\t\tprintf(\"\\n\");+\t\t\t}++\t\tBF_encrypt(&(data[0]),&key,BF_DECRYPT);+\t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_encrypt error decrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",bf_plain[n][i]);+\t\t\tprintf(\"\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish in ecb mode\\n\");++\tfor (n=0; n<NUM_TESTS; n++)+\t\t{+\t\tBF_set_key(&key,8,ecb_data[n]);++\t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT);+\t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",out[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",cipher_data[n][i]);+\t\t\terr=1;+\t\t\tprintf(\"\\n\");+\t\t\t}++\t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT);+\t\tif (memcmp(&(plain_data[n][0]),out,8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",out[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",plain_data[n][i]);+\t\t\tprintf(\"\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish set_key\\n\");+\tfor (n=1; n<KEY_TEST_NUM; n++)+\t\t{+\t\tBF_set_key(&key,n,key_test);+\t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);+\t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"blowfish setkey error\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish in cbc mode\\n\");+\tlen=strlen(cbc_data)+1;++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len,+\t\t&key,iv,BF_ENCRYPT);+\tif (memcmp(cbc_out,cbc_ok,32) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_cbc_encrypt encrypt error\\n\");+\t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tmemcpy(iv,cbc_iv,8);+\tBF_cbc_encrypt(cbc_out,cbc_in,len,+\t\t&key,iv,BF_DECRYPT);+\tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)+\t\t{+\t\tprintf(\"BF_cbc_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\tprintf(\"testing blowfish in cfb64 mode\\n\");++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tn=0;+\tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,+\t\t&key,iv,&n,BF_ENCRYPT);+\tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13,+\t\t&key,iv,&n,BF_ENCRYPT);+\tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\");+\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tn=0;+\tmemcpy(iv,cbc_iv,8);+\tBF_cfb64_encrypt(cbc_out,cbc_in,17,+\t\t&key,iv,&n,BF_DECRYPT);+\tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,+\t\t&key,iv,&n,BF_DECRYPT);+\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)+\t\t{+\t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\tprintf(\"testing blowfish in ofb64\\n\");++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tn=0;+\tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n);+\tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]),+\t\t&(cbc_out[13]),len-13,&key,iv,&n);+\tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\");+\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tn=0;+\tmemcpy(iv,cbc_iv,8);+\tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n);+\tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n);+\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)+\t\t{+\t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\treturn(err);+\t}",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L311,317:test/test_test.c": [
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/test_test.c b/test/test_test.c--- a/test/test_test.c+++ b/test/test_test.c@@ -289,1 +290,7 @@+static int test_bignum(void)+{+    BIGNUM *a = NULL, *b = NULL, *c = NULL;+    int r = 0;++    if (!TEST(1, TEST_int_eq(BN_dec2bn(&a, \"0\"), 1))",
            "commit_date": "2017-05-09 07:58:55+10:00",
            "commit_hash": "03d8e9cb43da5c524e5890a5a51e2c77f1fbd789",
            "message": "Add test_test tests for bignums.\nAdd relative tests for bignums.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3405)"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/test_test.c b/test/test_test.c--- a/test/test_test.c+++ b/test/test_test.c@@ -254,0 +280,1 @@+",
            "commit_date": "2017-05-01 14:38:49-04:00",
            "commit_hash": "ee6b68ce4c67870f9323d2a380eb949f447c56ee",
            "message": "Fix a stack smash\nIt occurs when memory compares are made that are larger\nthan the on stack temporary buffers (either malloced or supplied).\nRework the test test so it doesn't use a macro with a branch.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3155)"
        }
    ],
    "git log -L208,214:test/sm2_internal_test.c": [
        {
            "author": {
                "email": "yangmingjun@uniontech.com",
                "name": "Mingjun.Yang"
            },
            "changes": "diff --git a/test/sm2_internal_test.c b/test/sm2_internal_test.c--- a/test/sm2_internal_test.c+++ b/test/sm2_internal_test.c@@ -208,6 +208,7 @@ static int sm2_crypt_test(void) {+    EC_GROUP *gm_group = NULL;",
            "commit_date": "2021-09-06 15:30:19+08:00",
            "commit_hash": "8ba65c35ea3af347c3b2adc8e665066b541a1c35",
            "message": "Add sm2 encryption test case from GM/T 0003.5-2012\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16511)\nint testresult = 0;\nEC_GROUP *test_group =\ncreate_EC_group"
        },
        {
            "author": {
                "email": "bernd.edlinger@hotmail.de",
                "name": "Bernd Edlinger"
            },
            "changes": "diff --git a/test/sm2_internal_test.c b/test/sm2_internal_test.c--- a/test/sm2_internal_test.c+++ b/test/sm2_internal_test.c@@ -209,6 +209,6 @@ static int sm2_crypt_test(void) {-    int testresult = 1;+    int testresult = 0;",
            "commit_date": "2018-06-21 08:07:48+02:00",
            "commit_hash": "09fb65d5e413b7b87bf26f01ec441b44a03d4ee2",
            "message": "Fix negative test result in sm2 test\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/6548)\nEC_GROUP *test_group =\ncreate_EC_group"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/sm2_internal_test.c b/test/sm2_internal_test.c--- /dev/null+++ b/test/sm2_internal_test.c@@ -0,0 +203,6 @@++static int sm2_crypt_test(void)+{+    int testresult = 1;+    EC_GROUP *test_group =+        create_EC_group",
            "commit_date": "2018-05-31 13:49:47+01:00",
            "commit_hash": "e14d6cf691c9d8ad49df280b580b6836a67c6a19",
            "message": "Improve use of the test framework in the SM2 internal tests\nAlso general clean up of those tests\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/6386)"
        }
    ],
    "git log -L2996,3007:test/bntest.c": [
        {
            "author": {
                "email": "bernd.edlinger@hotmail.de",
                "name": "Bernd Edlinger"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -2487,0 +2730,12 @@++static int test_mod_exp_consttime(int i)+{+    const MOD_EXP_TEST *test = &ModExpTests[i];+    int res = 0;+    BIGNUM* result = NULL;+    BIGNUM *base = NULL, *exponent = NULL, *modulo = NULL;+    char *s = NULL;++    if (!TEST_ptr(result = BN_new())+            || !TEST_true(BN_dec2bn(&base, test->base))+            || !TEST_true(BN_dec2bn(&exponent, test->exp))",
            "commit_date": "2019-12-04 22:38:19+01:00",
            "commit_hash": "18d42d8d56352b81510d87dd12d1ac93d1d408d3",
            "message": "Add a test case for rsaz_512_sqr overflow handling\n[extended tests]\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/10574)"
        }
    ],
    "git log -L369,376:test/sm2_internal_test.c": [
        {
            "author": {
                "email": "yangmingjun@uniontech.com",
                "name": "Mingjun.Yang"
            },
            "changes": "diff --git a/test/sm2_internal_test.c b/test/sm2_internal_test.c--- a/test/sm2_internal_test.c+++ b/test/sm2_internal_test.c@@ -369,7 +369,8 @@ static int sm2_sig_test(void) {+    EC_GROUP *gm_group = NULL;",
            "commit_date": "2021-10-11 15:51:34+08:00",
            "commit_hash": "f087ebcb2eb516a424245fcb93642e57ba024cc4",
            "message": "feat: Add sm2 signature test case from GM/T 0003.5-2012\nReviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16802)\nint testresult = 0;\n/* From draft-shen-sm2-ecdsa-02 */\nEC_GROUP *test_group =\ncreate_EC_group"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/sm2_internal_test.c b/test/sm2_internal_test.c--- /dev/null+++ b/test/sm2_internal_test.c@@ -0,0 +317,7 @@++static int sm2_sig_test(void)+{+    int testresult = 0;+    /* From draft-shen-sm2-ecdsa-02 */+    EC_GROUP *test_group =+        create_EC_group",
            "commit_date": "2018-05-31 13:49:47+01:00",
            "commit_hash": "e14d6cf691c9d8ad49df280b580b6836a67c6a19",
            "message": "Improve use of the test framework in the SM2 internal tests\nAlso general clean up of those tests\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/6386)"
        }
    ],
    "git log -L216,222:test/cipherlist_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/cipherlist_test.c b/test/cipherlist_test.c--- a/test/cipherlist_test.c+++ b/test/cipherlist_test.c@@ -220,10 +216,7 @@ /* SSL_CTX_set_cipher_list() should fail if it clears all TLSv1.2 ciphers. */ static int test_default_cipherlist_clear(void) {-    SETUP_CIPHERLIST_TEST_FIXTURE();--    if (fixture == NULL)-        return 0;+    SETUP_CIPHERLIST_TEST_FIXTURE();",
            "commit_date": "2020-08-12 20:24:26+02:00",
            "commit_hash": "06cee80a843cae6bcb2dcba7eab26c963e10f825",
            "message": "testutil: Make SETUP_TEST_FIXTURE return 0 on fixture == NULL\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/11808)\nSSL *s = NULL;\nif (!TEST_int_eq(SSL_CTX_set_cipher_list(fixture->server, \"no-such\"), 0))"
        },
        {
            "author": {
                "email": "rsam@ca.ibm.com",
                "name": "Sam Roberts"
            },
            "changes": "diff --git a/test/cipherlist_test.c b/test/cipherlist_test.c--- a/test/cipherlist_test.c+++ b/test/cipherlist_test.c@@ -218,0 +218,10 @@+/* SSL_CTX_set_cipher_list() should fail if it clears all TLSv1.2 ciphers. */+static int test_default_cipherlist_clear(void)+{+    SETUP_CIPHERLIST_TEST_FIXTURE();+    SSL *s = NULL;++    if (fixture == NULL)+        return 0;++    if (!TEST_int_eq(SSL_CTX_set_cipher_list(fixture->server, \"no-such\"), 0))",
            "commit_date": "2018-11-26 13:58:52-08:00",
            "commit_hash": "3c83c5ba4f6502c708b7a5f55c98a10e312668da",
            "message": "Ignore cipher suites when setting cipher list\nset_cipher_list() sets TLSv1.2 (and below) ciphers, and its success or\nfailure should not depend on whether set_ciphersuites() has been used to\nsetup TLSv1.3 ciphers.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nReviewed-by: Ben Kaduk <kaduk@mit.edu>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/7759)"
        }
    ],
    "git log -L554,575:apps/ts.c": [
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/apps/ts.c b/apps/ts.c--- a/apps/ts.c+++ b/apps/ts.c@@ -591,24 +550,22 @@ static ASN1_INTEGER *create_nonce(int bits) {-    /* Generating random byte sequence. */-    /* Allocate at least one byte. */",
            "commit_date": "2015-05-07 23:41:07-04:00",
            "commit_hash": "18cd23df8a8f2edd800182e1ab62111e4b7f1dbe",
            "message": "Remove \"noise\" comments from TS files.\nReviewed-by: Tim Hudson <tjh@openssl.org>\nunsigned char buf[20];\nASN1_INTEGER *nonce = NULL;\nint len = (bits - 1) / 8 + 1;\nint i;\nif (len > (int)sizeof(buf))\ngoto err;\nif (RAND_bytes(buf, len) <= 0)\ngoto err;\n/* Find the first non-zero byte and creating ASN1_INTEGER object. */\nfor (i = 0; i < len && !buf[i]; ++i)\ncontinue;\nif ((nonce = ASN1_INTEGER_new()) == NULL)\ngoto err;\nOPENSSL_free(nonce->data);\nnonce->length = len - i;\nnonce->data = app_malloc(nonce->length + 1, \"nonce buffer\");\nmemcpy(nonce->data, buf + i, nonce->length);"
        },
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/apps/ts.c b/apps/ts.c--- a/apps/ts.c+++ b/apps/ts.c@@ -603,23 +604,24 @@ static ASN1_INTEGER *create_nonce(int bits) {-    for (i = 0; i < len && !buf[i]; ++i) ;-    if (!(nonce = ASN1_INTEGER_new()))+    for (i = 0; i < len && !buf[i]; ++i)+        continue;+    if ((nonce = ASN1_INTEGER_new()) == NULL)",
            "commit_date": "2015-05-06 13:43:59-04:00",
            "commit_hash": "75ebbd9aa411c5b8b19ded6ace2b34181566b56a",
            "message": "Use p==NULL not !p (in if statements, mainly)\nReviewed-by: Tim Hudson <tjh@openssl.org>\nunsigned char buf[20];\nASN1_INTEGER *nonce = NULL;\nint len = (bits - 1) / 8 + 1;\nint i;\n/* Generating random byte sequence. */\nif (len > (int)sizeof(buf))\ngoto err;\nif (RAND_bytes(buf, len) <= 0)\ngoto err;\n/* Find the first non-zero byte and creating ASN1_INTEGER object. */\ngoto err;\nOPENSSL_free(nonce->data);\n/* Allocate at least one byte. */\nnonce->length = len - i;\nnonce->data = app_malloc(nonce->length + 1, \"nonce buffer\");\nmemcpy(nonce->data, buf + i, nonce->length);"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/apps/ts.c b/apps/ts.c--- a/apps/ts.c+++ b/apps/ts.c@@ -606,24 +603,23 @@ static ASN1_INTEGER *create_nonce(int bits) {-    if (!(nonce->data = OPENSSL_malloc(nonce->length + 1)))-        goto err;+    nonce->data = app_malloc(nonce->length + 1, \"nonce buffer\");",
            "commit_date": "2015-04-30 17:48:31-04:00",
            "commit_hash": "68dc682499ea3fe27d909c946d7abd39062d6efd",
            "message": "In apps, malloc or die\nNo point in proceeding if you're out of memory.  So change\n*all* OPENSSL_malloc calls in apps to use the new routine which\nprints a message and exits.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nunsigned char buf[20];\nASN1_INTEGER *nonce = NULL;\nint len = (bits - 1) / 8 + 1;\nint i;\n/* Generating random byte sequence. */\nif (len > (int)sizeof(buf))\ngoto err;\nif (RAND_bytes(buf, len) <= 0)\ngoto err;\n/* Find the first non-zero byte and creating ASN1_INTEGER object. */\nfor (i = 0; i < len && !buf[i]; ++i) ;\nif (!(nonce = ASN1_INTEGER_new()))\ngoto err;\nOPENSSL_free(nonce->data);\n/* Allocate at least one byte. */\nnonce->length = len - i;\nmemcpy(nonce->data, buf + i, nonce->length);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/apps/ts.c b/apps/ts.c--- a/apps/ts.c+++ b/apps/ts.c@@ -643,22 +613,24 @@ static ASN1_INTEGER *create_nonce(int bits)-\t{-\tunsigned char buf[20];-\tASN1_INTEGER *nonce = NULL;-\tint len = (bits - 1) / 8 + 1;-\tint i;--\t/* Generating random byte sequence. */-\tif (len > (int)sizeof(buf)) goto err;-\tif (RAND_bytes(buf, len) <= 0) goto err;--\t/* Find the first non-zero byte and creating ASN1_INTEGER object. */-\tfor (i = 0; i < len && !buf[i]; ++i);-\tif (!(nonce = ASN1_INTEGER_new())) goto err;-\tOPENSSL_free(nonce->data);-\t/* Allocate at least one byte. */-\tnonce->length = len - i;-\tif (!(nonce->data = OPENSSL_malloc(nonce->length + 1))) goto err;-\tmemcpy(nonce->data, buf + i, nonce->length);--\treturn nonce;+{+    unsigned char buf[20];+    ASN1_INTEGER *nonce = NULL;+    int len = (bits - 1) / 8 + 1;+    int i;++    /* Generating random byte sequence. */+    if (len > (int)sizeof(buf))+        goto err;+    if (RAND_bytes(buf, len) <= 0)+        goto err;++    /* Find the first non-zero byte and creating ASN1_INTEGER object. */+    for (i = 0; i < len && !buf[i]; ++i) ;+    if (!(nonce = ASN1_INTEGER_new()))+        goto err;+    OPENSSL_free(nonce->data);+    /* Allocate at least one byte. */+    nonce->length = len - i;+    if (!(nonce->data = OPENSSL_malloc(nonce->length + 1)))+        goto err;+    memcpy(nonce->data, buf + i, nonce->length);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/apps/ts.c b/apps/ts.c--- a/apps/ts.c+++ b/apps/ts.c@@ -642,22 +642,22 @@ static ASN1_INTEGER *create_nonce(int bits) \t{ \tunsigned char buf[20]; \tASN1_INTEGER *nonce = NULL; \tint len = (bits - 1) / 8 + 1; \tint i; \t/* Generating random byte sequence. */ \tif (len > (int)sizeof(buf)) goto err;-\tif (!RAND_bytes(buf, len)) goto err;+\tif (RAND_bytes(buf, len) <= 0) goto err; \t/* Find the first non-zero byte and creating ASN1_INTEGER object. */ \tfor (i = 0; i < len && !buf[i]; ++i); \tif (!(nonce = ASN1_INTEGER_new())) goto err; \tOPENSSL_free(nonce->data); \t/* Allocate at least one byte. */ \tnonce->length = len - i; \tif (!(nonce->data = OPENSSL_malloc(nonce->length + 1))) goto err; \tmemcpy(nonce->data, buf + i, nonce->length); \treturn nonce;",
            "commit_date": "2009-09-13 11:29:29+00:00",
            "commit_hash": "a25f33d28a5b4e81646e42609095ef59a3f08990",
            "message": "Submitted by:  Julia Lawall <julia@diku.dk>\nThe functions ENGINE_ctrl(), OPENSSL_isservice(), EVP_PKEY_sign(),\nCMS_get1_RecipientRequest() and RAND_bytes() can return <=0 on error fix\nso the return code is checked correctly."
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/apps/ts.c b/apps/ts.c--- /dev/null+++ b/apps/ts.c@@ -0,0 +641,22 @@++static ASN1_INTEGER *create_nonce(int bits)+\t{+\tunsigned char buf[20];+\tASN1_INTEGER *nonce = NULL;+\tint len = (bits - 1) / 8 + 1;+\tint i;++\t/* Generating random byte sequence. */+\tif (len > (int)sizeof(buf)) goto err;+\tif (!RAND_bytes(buf, len)) goto err;++\t/* Find the first non-zero byte and creating ASN1_INTEGER object. */+\tfor (i = 0; i < len && !buf[i]; ++i);+\tif (!(nonce = ASN1_INTEGER_new())) goto err;+\tOPENSSL_free(nonce->data);+\t/* Allocate at least one byte. */+\tnonce->length = len - i;+\tif (!(nonce->data = OPENSSL_malloc(nonce->length + 1))) goto err;+\tmemcpy(nonce->data, buf + i, nonce->length);++\treturn nonce;",
            "commit_date": "2006-02-12 23:11:56+00:00",
            "commit_hash": "c7235be6e36c4bef84594aa3b2f0561db84b63d8",
            "message": "RFC 3161 compliant time stamp request creation, response generation\nand response verification.\nSubmitted by: Zoltan Glozik <zglozik@opentsa.org>\nReviewed by: Ulf Moeller"
        }
    ],
    "git log -L2122,2131:test/bntest.c": [
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1640,10 +1640,10 @@-static int test_asc2bn()+static int test_asc2bn(void) {",
            "commit_date": "2017-08-15 23:39:03+02:00",
            "commit_hash": "31a80694d425bf7f3a0ed5cc2ee775d9418a5490",
            "message": "[Win] Fix some test method signatures ...\nto halves MSVC warnings.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4172)\nBIGNUM *bn = NULL;\nint st = 0;\nif (!TEST_ptr(bn = BN_new()))\ngoto err;\nif (!TEST_true(BN_asc2bn(&bn, \"0\"))"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1704,13 +1614,10 @@ static int test_asc2bn() {-    BIGNUM *bn = BN_new();+    BIGNUM *bn = NULL;-    if (!BN_asc2bn(&bn, \"0\") || !BN_is_zero(bn) || BN_is_negative(bn)) {-        fprintf(stderr, \"BN_asc2bn(0) gave a bad result.\\n\");+    if (!TEST_ptr(bn = BN_new()))-    }-    if (!BN_asc2bn(&bn, \"256\") || !BN_is_word(bn, 256) || BN_is_negative(bn)) {-        fprintf(stderr, \"BN_asc2bn(256) gave a bad result.\\n\");+    if (!TEST_true(BN_asc2bn(&bn, \"0\"))",
            "commit_date": "2017-04-26 12:39:46-04:00",
            "commit_hash": "30bea14be6bbf77ed60acb9bd1befeb51d4c4b10",
            "message": "Convert bntest to TEST_ framework\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3265)\nint st = 0;\ngoto err;"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1650,13 +1617,13 @@-    char c = '*';--    if (p == 0)-        c = '.';-    if (p == 1)-        c = '+';-    if (p == 2)-        c = '*';-    if (p == 3)-        c = '\\n';-    putc(c, stderr);-    fflush(stderr);-    return 1;++static int test_asc2bn()+{+    BIGNUM *bn = BN_new();+    int st = 0;++    if (!BN_asc2bn(&bn, \"0\") || !BN_is_zero(bn) || BN_is_negative(bn)) {+        fprintf(stderr, \"BN_asc2bn(0) gave a bad result.\\n\");+        goto err;+    }++    if (!BN_asc2bn(&bn, \"256\") || !BN_is_word(bn, 256) || BN_is_negative(bn)) {+        fprintf(stderr, \"BN_asc2bn(256) gave a bad result.\\n\");",
            "commit_date": "2016-11-28 12:26:05-05:00",
            "commit_hash": "8d1ebff41c75e4eebc7d5cc5a561a1bab6b50e70",
            "message": "Make bntest be (mostly) file-based.\nTest suite used from boring, written by David Benjamin.\nTest driver converted from C++ to C.\nAdded a Perl program to check the testsuite file.\nExtensive review feedback incorporated (thanks folks).\nReviewed-by: Emilia K\u00e4sper <emilia@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -1784,11 +1713,13 @@-\t{-\tchar c='*';--\tif (p == 0) c='.';-\tif (p == 1) c='+';-\tif (p == 2) c='*';-\tif (p == 3) c='\\n';-\tputc(c, stderr);-\tfflush(stderr);-\treturn 1;-\t}+    char c = '*';++    if (p == 0)+        c = '.';+    if (p == 1)+        c = '+';+    if (p == 2)+        c = '*';+    if (p == 3)+        c = '\\n';+    putc(c, stderr);+    fflush(stderr);+    return 1;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -1506,12 +1506,11 @@ \t{ \tchar c='*'; \tif (p == 0) c='.'; \tif (p == 1) c='+'; \tif (p == 2) c='*'; \tif (p == 3) c='\\n'; \tputc(c, stderr); \tfflush(stderr);-\t(void)n;-\t(void)arg;+\treturn 1; \t}",
            "commit_date": "2003-10-29 04:14:08+00:00",
            "commit_hash": "2aaec9cced89edfdc8375b38a130fa1c35a98025",
            "message": "Update any code that was using deprecated functions so that everything builds\nand links with OPENSSL_NO_DEPRECATED defined."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -903,0 +904,12 @@+\t{+\tchar c='*';++\tif (p == 0) c='.';+\tif (p == 1) c='+';+\tif (p == 2) c='*';+\tif (p == 3) c='\\n';+\tputc(c, stderr);+\tfflush(stderr);+\t(void)n;+\t(void)arg;+\t}",
            "commit_date": "2000-11-29 11:06:50+00:00",
            "commit_hash": "bdec3c5323c7a726814257ec9b43fcd259f4e206",
            "message": "Implement BN_kronecker test.\nModify \"CHANGES\" entry for BN_mod_inverse (it's not just avoiding BN_div\nthat increases performance, avoiding BN_mul also helps)"
        }
    ],
    "git log -L2124,2137:test/ectest.c": [
        {
            "author": {
                "email": "bbrumley@gmail.com",
                "name": "Billy Brumley"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -2125,0 +2191,14 @@+ */+static int cofactor_range_test(void)+{+    EC_GROUP *group = NULL;+    BIGNUM *cf = NULL;+    int ret = 0;+    const unsigned char *b1 = (const unsigned char *)params_cf_fail;+    const unsigned char *b2 = (const unsigned char *)params_cf_pass;++    if (!TEST_ptr(group = d2i_ECPKParameters(NULL, &b1, sizeof(params_cf_fail)))+        || !TEST_BN_eq_zero(EC_GROUP_get0_cofactor(group))+        || !TEST_ptr(group = d2i_ECPKParameters(&group, &b2,+                                                sizeof(params_cf_pass)))+        || !TEST_int_gt(BN_hex2bn(&cf, \"12bc94785251297abfafddf1565100da\"), 0)",
            "commit_date": "2019-09-09 11:29:09+03:00",
            "commit_hash": "1d3cd983f56e0a580ee4216692ee3c9c7bf14de9",
            "message": "[test] ECC: check the bounds for auto computing cofactor\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\n(Merged from https://github.com/openssl/openssl/pull/9821)"
        }
    ],
    "git log -L933,950:test/ectest.c": [
        {
            "author": {
                "email": "bbrumley@gmail.com",
                "name": "Billy Brumley"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -972,18 +934,18 @@ static int char2_field_tests(void) {-    EC_GROUP *group = NULL, *tmp = NULL;+    EC_GROUP *group = NULL;",
            "commit_date": "2020-05-27 13:30:04+03:00",
            "commit_hash": "23ccae80bd58adfe89e3e345414684eb82bdb531",
            "message": "Move EC_METHOD to internal-only\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/11928)\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL;\nEC_POINT *P = NULL, *Q = NULL, *R = NULL;\nBIGNUM *x = NULL, *y = NULL, *z = NULL, *cof = NULL, *yplusone = NULL;\nunsigned char buf[100];\nsize_t len;\nint k, r = 0;\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_true(BN_hex2bn(&p, \"13\"))\n|| !TEST_true(BN_hex2bn(&a, \"3\"))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1013,18 +979,18 @@ static int char2_field_tests(void) {-    size_t i, len;+    size_t len;",
            "commit_date": "2017-06-12 10:01:17+10:00",
            "commit_hash": "3791646202bb4da21992b0aecae253d394507a9e",
            "message": "Add output routines to allow consistent formatting of memory, strings\nand bignums.  These have been refactored into their own file, along with\ntheir error displays.  The formatting follows the output format used\non error, except that bignums of sixty four bits or less are displayed\nin a more compact one line form.\nAdded a TEST_note function for producing output without file and line\ninformation.\nUpdate the three tests that call BN_print so they use the new test\ninfrastructure instead.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3655)\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL;\nEC_GROUP *group = NULL, *tmp = NULL;\nEC_POINT *P = NULL, *Q = NULL, *R = NULL;\nBIGNUM *x = NULL, *y = NULL, *z = NULL, *cof = NULL, *yplusone = NULL;\nunsigned char buf[100];\nint k, r = 0;\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_true(BN_hex2bn(&p, \"13\"))\n|| !TEST_true(BN_hex2bn(&a, \"3\"))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -897,94 +1013,18 @@-/* Change test based on whether binary point compression is enabled or not. */-# ifdef OPENSSL_EC_BIN_PT_COMP-#  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-        if (!BN_hex2bn(&x, _x)) ABORT; \\-        if (!BN_hex2bn(&y, _y)) ABORT; \\-        if (!BN_add(yplusone, y, BN_value_one())) ABORT;        \\-        /* \\-         * When (x, y) is on the curve, (x, y + 1) is, as it happens, not, \\-         * and therefore setting the coordinates should fail. \\-         */ \\-        if (EC_POINT_set_affine_coordinates_GF2m(group, P, x, yplusone, ctx)) ABORT; \\-        if (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\-        if (EC_POINT_is_on_curve(group, P, ctx) <= 0) ABORT; \\-        if (!BN_hex2bn(&z, _order)) ABORT; \\-        if (!BN_hex2bn(&cof, _cof)) ABORT; \\-        if (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\-        if (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\-        fprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\-        BN_print_fp(stdout, x); \\-        fprintf(stdout, \"\\n     y = 0x\"); \\-        BN_print_fp(stdout, y); \\-        fprintf(stdout, \"\\n\"); \\-        /* G_y value taken from the standard: */ \\-        if (!BN_hex2bn(&z, _y)) ABORT; \\-        if (0 != BN_cmp(y, z)) ABORT;-# else-#  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-        if (!BN_hex2bn(&x, _x)) ABORT; \\-        if (!BN_hex2bn(&y, _y)) ABORT; \\-        if (!BN_add(yplusone, y, BN_value_one())) ABORT;        \\-        /* \\-         * When (x, y) is on the curve, (x, y + 1) is, as it happens, not, \\-         * and therefore setting the coordinates should fail. \\-         */ \\-        if (EC_POINT_set_affine_coordinates_GF2m(group, P, x, yplusone, ctx)) ABORT; \\-        if (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\-        if (EC_POINT_is_on_curve(group, P, ctx) <= 0) ABORT; \\-        if (!BN_hex2bn(&z, _order)) ABORT; \\-        if (!BN_hex2bn(&cof, _cof)) ABORT; \\-        if (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\-        fprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\-        BN_print_fp(stdout, x); \\-        fprintf(stdout, \"\\n     y = 0x\"); \\-        BN_print_fp(stdout, y); \\-        fprintf(stdout, \"\\n\");-# endif--# define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-        if (!BN_hex2bn(&p, _p)) ABORT; \\-        if (!BN_hex2bn(&a, _a)) ABORT; \\-        if (!BN_hex2bn(&b, _b)) ABORT; \\-        if (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\-        CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-        fprintf(stdout, \"verify degree ...\"); \\-        if (EC_GROUP_get_degree(group) != _degree) ABORT; \\-        fprintf(stdout, \" ok\\n\"); \\-        group_order_tests(group); \\-        if ((_variable = EC_GROUP_new(EC_GROUP_method_of(group))) == NULL) ABORT; \\-        if (!EC_GROUP_copy(_variable, group)) ABORT; \\--# ifndef OPENSSL_NO_EC2M--static void char2_field_tests(void)+static int char2_field_tests(void) {-    BIGNUM *p, *a, *b;-    EC_GROUP *group;-    EC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 =-        NULL, *C2_K571 = NULL;-    EC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 =-        NULL, *C2_B571 = NULL;-    EC_POINT *P, *Q, *R;-    BIGNUM *x, *y, *z, *cof, *yplusone;+    BIGNUM *p = NULL, *a = NULL, *b = NULL;+    EC_GROUP *group = NULL, *tmp = NULL;+    EC_POINT *P = NULL, *Q = NULL, *R = NULL;+    BIGNUM *x = NULL, *y = NULL, *z = NULL, *cof = NULL, *yplusone = NULL;-    int k;+    int k, r = 0;-    ctx = BN_CTX_new();-    if (!ctx)-        ABORT;--    p = BN_new();-    a = BN_new();-    b = BN_new();-    if (p == NULL || a == NULL || b == NULL)-        ABORT;--    if (!BN_hex2bn(&p, \"13\"))-        ABORT;-    if (!BN_hex2bn(&a, \"3\"))-        ABORT;-    if (!BN_hex2bn(&b, \"1\"))-        ABORT;+    if (!TEST_ptr(ctx = BN_CTX_new())+        || !TEST_ptr(p = BN_new())+        || !TEST_ptr(a = BN_new())+        || !TEST_ptr(b = BN_new())+        || !TEST_true(BN_hex2bn(&p, \"13\"))+        || !TEST_true(BN_hex2bn(&a, \"3\"))",
            "commit_date": "2017-04-28 14:06:11+10:00",
            "commit_hash": "2db85ac97a5dda90249f5e630e7b29c4196fc397",
            "message": "Conversion of the EC tests to use the framework.\nSome refactoring done as well.\nThe prime_field_tests() function needs splitting and refactoring still.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3340)\nBN_CTX *ctx = NULL;\nunsigned char buf[100];\nsize_t i, len;"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -841,81 +900,94 @@ /* Change test based on whether binary point compression is enabled or not. */ # ifdef OPENSSL_EC_BIN_PT_COMP #  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+        if (!BN_hex2bn(&y, _y)) ABORT; \\+        if (!BN_add(yplusone, y, BN_value_one())) ABORT;        \\+        /* \\+         * When (x, y) is on the curve, (x, y + 1) is, as it happens, not, \\+         * and therefore setting the coordinates should fail. \\+         */ \\+        if (EC_POINT_set_affine_coordinates_GF2m(group, P, x, yplusone, ctx)) ABORT; \\ # else #  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+        if (!BN_add(yplusone, y, BN_value_one())) ABORT;        \\+        /* \\+         * When (x, y) is on the curve, (x, y + 1) is, as it happens, not, \\+         * and therefore setting the coordinates should fail. \\+         */ \\+        if (EC_POINT_set_affine_coordinates_GF2m(group, P, x, yplusone, ctx)) ABORT; \\ # endif # define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ # ifndef OPENSSL_NO_EC2M static void char2_field_tests(void) {-    BIGNUM *x, *y, *z, *cof;+    BIGNUM *x, *y, *z, *cof, *yplusone;-    if (!p || !a || !b)+    if (p == NULL || a == NULL || b == NULL)",
            "commit_date": "2016-06-03 14:42:04+02:00",
            "commit_hash": "1e2012b7ff4a5f12273446b281775faa5c8a1858",
            "message": "RT 4242: reject invalid EC point coordinates\nWe already test in EC_POINT_oct2point that points are on the curve. To\nbe on the safe side, move this check to\nEC_POINT_set_affine_coordinates_* so as to also check point coordinates\nreceived through some other method.\nWe do not check projective coordinates, though, as\n- it's unlikely that applications would be receiving this primarily\ninternal representation from untrusted sources, and\n- it's possible that the projective setters are used in a setting where\nperformance matters.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nif (!BN_hex2bn(&x, _x)) ABORT; \\\nif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\\nif (EC_POINT_is_on_curve(group, P, ctx) <= 0) ABORT; \\\nif (!BN_hex2bn(&z, _order)) ABORT; \\\nif (!BN_hex2bn(&cof, _cof)) ABORT; \\\nif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\\nfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\\nBN_print_fp(stdout, x); \\\nfprintf(stdout, \"\\n     y = 0x\"); \\\nBN_print_fp(stdout, y); \\\nfprintf(stdout, \"\\n\"); \\\n/* G_y value taken from the standard: */ \\\nif (!BN_hex2bn(&z, _y)) ABORT; \\\nif (0 != BN_cmp(y, z)) ABORT;\nif (!BN_hex2bn(&x, _x)) ABORT; \\\nif (!BN_hex2bn(&y, _y)) ABORT; \\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\\nif (EC_POINT_is_on_curve(group, P, ctx) <= 0) ABORT; \\\nif (!BN_hex2bn(&z, _order)) ABORT; \\\nif (!BN_hex2bn(&cof, _cof)) ABORT; \\\nif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\\nfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\\nBN_print_fp(stdout, x); \\\nfprintf(stdout, \"\\n     y = 0x\"); \\\nBN_print_fp(stdout, y); \\\nfprintf(stdout, \"\\n\");\nif (!BN_hex2bn(&p, _p)) ABORT; \\\nif (!BN_hex2bn(&a, _a)) ABORT; \\\nif (!BN_hex2bn(&b, _b)) ABORT; \\\nif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\\nCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\\nfprintf(stdout, \"verify degree ...\"); \\\nif (EC_GROUP_get_degree(group) != _degree) ABORT; \\\nfprintf(stdout, \" ok\\n\"); \\\ngroup_order_tests(group); \\\nif ((_variable = EC_GROUP_new(EC_GROUP_method_of(group))) == NULL) ABORT; \\\nif (!EC_GROUP_copy(_variable, group)) ABORT; \\\nBN_CTX *ctx = NULL;\nBIGNUM *p, *a, *b;\nEC_GROUP *group;\nEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 =\nNULL, *C2_K571 = NULL;\nEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 =\nNULL, *C2_B571 = NULL;\nEC_POINT *P, *Q, *R;\nunsigned char buf[100];\nsize_t i, len;\nint k;\nctx = BN_CTX_new();\nif (!ctx)\nABORT;\np = BN_new();\na = BN_new();\nb = BN_new();\nABORT;\nif (!BN_hex2bn(&p, \"13\"))\nABORT;\nif (!BN_hex2bn(&a, \"3\"))\nABORT;\nif (!BN_hex2bn(&b, \"1\"))\nABORT;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -874,81 +874,81 @@ /* Change test based on whether binary point compression is enabled or not. */ # ifdef OPENSSL_EC_BIN_PT_COMP #  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-        if (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\+        if (EC_POINT_is_on_curve(group, P, ctx) <= 0) ABORT; \\ # else #  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-        if (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\+        if (EC_POINT_is_on_curve(group, P, ctx) <= 0) ABORT; \\ # endif # define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ # ifndef OPENSSL_NO_EC2M static void char2_field_tests(void) {",
            "commit_date": "2015-06-04 14:22:00+01:00",
            "commit_hash": "68886be7e2cd395a759fcd41d2cede461b68843d",
            "message": "EC_POINT_is_on_curve does not return a boolean\nThe function EC_POINT_is_on_curve does not return a boolean value.\nIt returns 1 if the point is on the curve, 0 if it is not, and -1\non error. Many usages within OpenSSL were incorrectly using this\nfunction and therefore not correctly handling error conditions.\nWith thanks to the Open Crypto Audit Project for reporting this issue.\nReviewed-by: Kurt Roeckx <kurt@openssl.org>\nif (!BN_hex2bn(&x, _x)) ABORT; \\\nif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\\nif (!BN_hex2bn(&z, _order)) ABORT; \\\nif (!BN_hex2bn(&cof, _cof)) ABORT; \\\nif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\\nfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\\nBN_print_fp(stdout, x); \\\nfprintf(stdout, \"\\n     y = 0x\"); \\\nBN_print_fp(stdout, y); \\\nfprintf(stdout, \"\\n\"); \\\n/* G_y value taken from the standard: */ \\\nif (!BN_hex2bn(&z, _y)) ABORT; \\\nif (0 != BN_cmp(y, z)) ABORT;\nif (!BN_hex2bn(&x, _x)) ABORT; \\\nif (!BN_hex2bn(&y, _y)) ABORT; \\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\\nif (!BN_hex2bn(&z, _order)) ABORT; \\\nif (!BN_hex2bn(&cof, _cof)) ABORT; \\\nif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\\nfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\\nBN_print_fp(stdout, x); \\\nfprintf(stdout, \"\\n     y = 0x\"); \\\nBN_print_fp(stdout, y); \\\nfprintf(stdout, \"\\n\");\nif (!BN_hex2bn(&p, _p)) ABORT; \\\nif (!BN_hex2bn(&a, _a)) ABORT; \\\nif (!BN_hex2bn(&b, _b)) ABORT; \\\nif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\\nCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\\nfprintf(stdout, \"verify degree ...\"); \\\nif (EC_GROUP_get_degree(group) != _degree) ABORT; \\\nfprintf(stdout, \" ok\\n\"); \\\ngroup_order_tests(group); \\\nif ((_variable = EC_GROUP_new(EC_GROUP_method_of(group))) == NULL) ABORT; \\\nif (!EC_GROUP_copy(_variable, group)) ABORT; \\\nBN_CTX *ctx = NULL;\nBIGNUM *p, *a, *b;\nEC_GROUP *group;\nEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 =\nNULL, *C2_K571 = NULL;\nEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 =\nNULL, *C2_B571 = NULL;\nEC_POINT *P, *Q, *R;\nBIGNUM *x, *y, *z, *cof;\nunsigned char buf[100];\nsize_t i, len;\nint k;\nctx = BN_CTX_new();\nif (!ctx)\nABORT;\np = BN_new();\na = BN_new();\nb = BN_new();\nif (!p || !a || !b)\nABORT;\nif (!BN_hex2bn(&p, \"13\"))\nABORT;\nif (!BN_hex2bn(&a, \"3\"))\nABORT;\nif (!BN_hex2bn(&b, \"1\"))\nABORT;"
        },
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -874,81 +874,81 @@ /* Change test based on whether binary point compression is enabled or not. */ # ifdef OPENSSL_EC_BIN_PT_COMP #  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ # else #  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ # endif # define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-        if (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\+        if ((_variable = EC_GROUP_new(EC_GROUP_method_of(group))) == NULL) ABORT; \\ # ifndef OPENSSL_NO_EC2M static void char2_field_tests(void) {",
            "commit_date": "2015-05-06 13:43:59-04:00",
            "commit_hash": "75ebbd9aa411c5b8b19ded6ace2b34181566b56a",
            "message": "Use p==NULL not !p (in if statements, mainly)\nReviewed-by: Tim Hudson <tjh@openssl.org>\nif (!BN_hex2bn(&x, _x)) ABORT; \\\nif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\\nif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\\nif (!BN_hex2bn(&z, _order)) ABORT; \\\nif (!BN_hex2bn(&cof, _cof)) ABORT; \\\nif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\\nfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\\nBN_print_fp(stdout, x); \\\nfprintf(stdout, \"\\n     y = 0x\"); \\\nBN_print_fp(stdout, y); \\\nfprintf(stdout, \"\\n\"); \\\n/* G_y value taken from the standard: */ \\\nif (!BN_hex2bn(&z, _y)) ABORT; \\\nif (0 != BN_cmp(y, z)) ABORT;\nif (!BN_hex2bn(&x, _x)) ABORT; \\\nif (!BN_hex2bn(&y, _y)) ABORT; \\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\\nif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\\nif (!BN_hex2bn(&z, _order)) ABORT; \\\nif (!BN_hex2bn(&cof, _cof)) ABORT; \\\nif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\\nfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\\nBN_print_fp(stdout, x); \\\nfprintf(stdout, \"\\n     y = 0x\"); \\\nBN_print_fp(stdout, y); \\\nfprintf(stdout, \"\\n\");\nif (!BN_hex2bn(&p, _p)) ABORT; \\\nif (!BN_hex2bn(&a, _a)) ABORT; \\\nif (!BN_hex2bn(&b, _b)) ABORT; \\\nif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\\nCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\\nfprintf(stdout, \"verify degree ...\"); \\\nif (EC_GROUP_get_degree(group) != _degree) ABORT; \\\nfprintf(stdout, \" ok\\n\"); \\\ngroup_order_tests(group); \\\nif (!EC_GROUP_copy(_variable, group)) ABORT; \\\nBN_CTX *ctx = NULL;\nBIGNUM *p, *a, *b;\nEC_GROUP *group;\nEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 =\nNULL, *C2_K571 = NULL;\nEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 =\nNULL, *C2_B571 = NULL;\nEC_POINT *P, *Q, *R;\nBIGNUM *x, *y, *z, *cof;\nunsigned char buf[100];\nsize_t i, len;\nint k;\nctx = BN_CTX_new();\nif (!ctx)\nABORT;\np = BN_new();\na = BN_new();\nb = BN_new();\nif (!p || !a || !b)\nABORT;\nif (!BN_hex2bn(&p, \"13\"))\nABORT;\nif (!BN_hex2bn(&a, \"3\"))\nABORT;\nif (!BN_hex2bn(&b, \"1\"))\nABORT;"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -883,83 +881,81 @@ /* Change test based on whether binary point compression is enabled or not. */ # ifdef OPENSSL_EC_BIN_PT_COMP #  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ # else #  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ # endif # define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ # ifndef OPENSSL_NO_EC2M static void char2_field_tests(void) {-#  if 1                         /* optional */-#  endif",
            "commit_date": "2015-02-06 10:54:20-05:00",
            "commit_hash": "6f91b017bbb7140f816721141ac156d1b828a6b3",
            "message": "Live code cleanup: remove #if 1 stuff\nFor code bracketed by \"#if 1\" then remove the alternate\n\"#else .. #endif\" lines.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nif (!BN_hex2bn(&x, _x)) ABORT; \\\nif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\\nif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\\nif (!BN_hex2bn(&z, _order)) ABORT; \\\nif (!BN_hex2bn(&cof, _cof)) ABORT; \\\nif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\\nif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\\nfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\\nBN_print_fp(stdout, x); \\\nfprintf(stdout, \"\\n     y = 0x\"); \\\nBN_print_fp(stdout, y); \\\nfprintf(stdout, \"\\n\"); \\\n/* G_y value taken from the standard: */ \\\nif (!BN_hex2bn(&z, _y)) ABORT; \\\nif (0 != BN_cmp(y, z)) ABORT;\nif (!BN_hex2bn(&x, _x)) ABORT; \\\nif (!BN_hex2bn(&y, _y)) ABORT; \\\nif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\\nif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\\nif (!BN_hex2bn(&z, _order)) ABORT; \\\nif (!BN_hex2bn(&cof, _cof)) ABORT; \\\nif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\\nfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\\nBN_print_fp(stdout, x); \\\nfprintf(stdout, \"\\n     y = 0x\"); \\\nBN_print_fp(stdout, y); \\\nfprintf(stdout, \"\\n\");\nif (!BN_hex2bn(&p, _p)) ABORT; \\\nif (!BN_hex2bn(&a, _a)) ABORT; \\\nif (!BN_hex2bn(&b, _b)) ABORT; \\\nif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\\nCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\\nfprintf(stdout, \"verify degree ...\"); \\\nif (EC_GROUP_get_degree(group) != _degree) ABORT; \\\nfprintf(stdout, \" ok\\n\"); \\\ngroup_order_tests(group); \\\nif (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\\nif (!EC_GROUP_copy(_variable, group)) ABORT; \\\nBN_CTX *ctx = NULL;\nBIGNUM *p, *a, *b;\nEC_GROUP *group;\nEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 =\nNULL, *C2_K571 = NULL;\nEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 =\nNULL, *C2_B571 = NULL;\nEC_POINT *P, *Q, *R;\nBIGNUM *x, *y, *z, *cof;\nunsigned char buf[100];\nsize_t i, len;\nint k;\nctx = BN_CTX_new();\nif (!ctx)\nABORT;\np = BN_new();\na = BN_new();\nb = BN_new();\nif (!p || !a || !b)\nABORT;\nif (!BN_hex2bn(&p, \"13\"))\nABORT;\nif (!BN_hex2bn(&a, \"3\"))\nABORT;\nif (!BN_hex2bn(&b, \"1\"))\nABORT;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -767,122 +1003,83 @@ /* Change test based on whether binary point compression is enabled or not. */-#ifdef OPENSSL_EC_BIN_PT_COMP-#define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-\tif (!BN_hex2bn(&x, _x)) ABORT; \\-\tif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\-\tif (!BN_hex2bn(&z, _order)) ABORT; \\-\tif (!BN_hex2bn(&cof, _cof)) ABORT; \\-\tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\-\tif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\-\tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\-\tBN_print_fp(stdout, x); \\-\tfprintf(stdout, \"\\n     y = 0x\"); \\-\tBN_print_fp(stdout, y); \\-\tfprintf(stdout, \"\\n\"); \\-\t/* G_y value taken from the standard: */ \\-\tif (!BN_hex2bn(&z, _y)) ABORT; \\-\tif (0 != BN_cmp(y, z)) ABORT;-#else -#define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-\tif (!BN_hex2bn(&x, _x)) ABORT; \\-\tif (!BN_hex2bn(&y, _y)) ABORT; \\-\tif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\-\tif (!BN_hex2bn(&z, _order)) ABORT; \\-\tif (!BN_hex2bn(&cof, _cof)) ABORT; \\-\tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\-\tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\-\tBN_print_fp(stdout, x); \\-\tfprintf(stdout, \"\\n     y = 0x\"); \\-\tBN_print_fp(stdout, y); \\-\tfprintf(stdout, \"\\n\");-#endif--#define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-\tif (!BN_hex2bn(&p, _p)) ABORT; \\-\tif (!BN_hex2bn(&a, _a)) ABORT; \\-\tif (!BN_hex2bn(&b, _b)) ABORT; \\-\tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\-\tCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\-\tfprintf(stdout, \"verify degree ...\"); \\-\tif (EC_GROUP_get_degree(group) != _degree) ABORT; \\-\tfprintf(stdout, \" ok\\n\"); \\-\tgroup_order_tests(group); \\-\tif (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\-\tif (!EC_GROUP_copy(_variable, group)) ABORT; \\--#ifndef OPENSSL_NO_EC2M+# ifdef OPENSSL_EC_BIN_PT_COMP+#  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+        if (!BN_hex2bn(&x, _x)) ABORT; \\+        if (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\+        if (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\+        if (!BN_hex2bn(&z, _order)) ABORT; \\+        if (!BN_hex2bn(&cof, _cof)) ABORT; \\+        if (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\+        if (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\+        fprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\+        BN_print_fp(stdout, x); \\+        fprintf(stdout, \"\\n     y = 0x\"); \\+        BN_print_fp(stdout, y); \\+        fprintf(stdout, \"\\n\"); \\+        /* G_y value taken from the standard: */ \\+        if (!BN_hex2bn(&z, _y)) ABORT; \\+        if (0 != BN_cmp(y, z)) ABORT;+# else+#  define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+        if (!BN_hex2bn(&x, _x)) ABORT; \\+        if (!BN_hex2bn(&y, _y)) ABORT; \\+        if (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\+        if (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\+        if (!BN_hex2bn(&z, _order)) ABORT; \\+        if (!BN_hex2bn(&cof, _cof)) ABORT; \\+        if (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\+        fprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\+        BN_print_fp(stdout, x); \\+        fprintf(stdout, \"\\n     y = 0x\"); \\+        BN_print_fp(stdout, y); \\+        fprintf(stdout, \"\\n\");+# endif++# define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+        if (!BN_hex2bn(&p, _p)) ABORT; \\+        if (!BN_hex2bn(&a, _a)) ABORT; \\+        if (!BN_hex2bn(&b, _b)) ABORT; \\+        if (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\+        CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+        fprintf(stdout, \"verify degree ...\"); \\+        if (EC_GROUP_get_degree(group) != _degree) ABORT; \\+        fprintf(stdout, \" ok\\n\"); \\+        group_order_tests(group); \\+        if (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\+        if (!EC_GROUP_copy(_variable, group)) ABORT; \\++# ifndef OPENSSL_NO_EC2M static void char2_field_tests(void)-\t{-\tBN_CTX *ctx = NULL;-\tBIGNUM *p, *a, *b;-\tEC_GROUP *group;-\tEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 = NULL, *C2_K571 = NULL;-\tEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 = NULL, *C2_B571 = NULL;-\tEC_POINT *P, *Q, *R;-\tBIGNUM *x, *y, *z, *cof;-\tunsigned char buf[100];-\tsize_t i, len;-\tint k;-\t-#if 1 /* optional */-\tctx = BN_CTX_new();-\tif (!ctx) ABORT;-#endif--\tp = BN_new();-\ta = BN_new();-\tb = BN_new();-\tif (!p || !a || !b) ABORT;--\tif (!BN_hex2bn(&p, \"13\")) ABORT;-\tif (!BN_hex2bn(&a, \"3\")) ABORT;-\tif (!BN_hex2bn(&b, \"1\")) ABORT;-\t-\tgroup = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use EC_GROUP_new_curve_GF2m-\t                                                * so that the library gets to choose the EC_METHOD */-\tif (!group) ABORT;-\tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT;--\t{-\t\tEC_GROUP *tmp;-\t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group));-\t\tif (!tmp) ABORT;-\t\tif (!EC_GROUP_copy(tmp, group)) ABORT;-\t\tEC_GROUP_free(group);-\t\tgroup = tmp;-\t}-\t-\tif (!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ABORT;--\tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x\");-\tBN_print_fp(stdout, p);-\tfprintf(stdout, \")\\n     a = 0x\");-\tBN_print_fp(stdout, a);-\tfprintf(stdout, \"\\n     b = 0x\");-\tBN_print_fp(stdout, b);-\tfprintf(stdout, \"\\n(0x... means binary polynomial)\\n\");--\tP = EC_POINT_new(group);-\tQ = EC_POINT_new(group);-\tR = EC_POINT_new(group);-\tif (!P || !Q || !R) ABORT;-\t-\tif (!EC_POINT_set_to_infinity(group, P)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\tbuf[0] = 0;-\tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT;--\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\tx = BN_new();-\ty = BN_new();-\tz = BN_new();-\tcof = BN_new();-\tif (!x || !y || !z || !cof) ABORT;--\tif (!BN_hex2bn(&x, \"6\")) ABORT;+{+    BN_CTX *ctx = NULL;+    BIGNUM *p, *a, *b;+    EC_GROUP *group;+    EC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 =+        NULL, *C2_K571 = NULL;+    EC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 =+        NULL, *C2_B571 = NULL;+    EC_POINT *P, *Q, *R;+    BIGNUM *x, *y, *z, *cof;+    unsigned char buf[100];+    size_t i, len;+    int k;++#  if 1                         /* optional */+    ctx = BN_CTX_new();+    if (!ctx)+        ABORT;+#  endif++    p = BN_new();+    a = BN_new();+    b = BN_new();+    if (!p || !a || !b)+        ABORT;++    if (!BN_hex2bn(&p, \"13\"))+        ABORT;+    if (!BN_hex2bn(&a, \"3\"))+        ABORT;+    if (!BN_hex2bn(&b, \"1\"))+        ABORT;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -731,121 +731,122 @@ /* Change test based on whether binary point compression is enabled or not. */ #ifdef OPENSSL_EC_BIN_PT_COMP #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); \\ \t/* G_y value taken from the standard: */ \\ \tif (!BN_hex2bn(&z, _y)) ABORT; \\ \tif (0 != BN_cmp(y, z)) ABORT; #else  #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!BN_hex2bn(&y, _y)) ABORT; \\ \tif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); #endif #define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&p, _p)) ABORT; \\ \tif (!BN_hex2bn(&a, _a)) ABORT; \\ \tif (!BN_hex2bn(&b, _b)) ABORT; \\ \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\ \tCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tfprintf(stdout, \"verify degree ...\"); \\ \tif (EC_GROUP_get_degree(group) != _degree) ABORT; \\ \tfprintf(stdout, \" ok\\n\"); \\ \tgroup_order_tests(group); \\ \tif (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\ \tif (!EC_GROUP_copy(_variable, group)) ABORT; \\+#ifndef OPENSSL_NO_EC2M static void char2_field_tests(void)-\t{\t+\t{ \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 = NULL, *C2_K571 = NULL; \tEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 = NULL, *C2_B571 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z, *cof; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"13\")) ABORT; \tif (!BN_hex2bn(&a, \"3\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use EC_GROUP_new_curve_GF2m \t                                                * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n(0x... means binary polynomial)\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tcof = BN_new(); \tif (!x || !y || !z || !cof) ABORT; \tif (!BN_hex2bn(&x, \"6\")) ABORT;",
            "commit_date": "2011-02-12 17:23:32+00:00",
            "commit_hash": "b3310161249a848a5243952467a1f3927ad78bfa",
            "message": "New option to disable characteristic two fields in EC code."
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -731,121 +731,121 @@ /* Change test based on whether binary point compression is enabled or not. */ #ifdef OPENSSL_EC_BIN_PT_COMP #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); \\ \t/* G_y value taken from the standard: */ \\ \tif (!BN_hex2bn(&z, _y)) ABORT; \\ \tif (0 != BN_cmp(y, z)) ABORT; #else  #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!BN_hex2bn(&y, _y)) ABORT; \\ \tif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); #endif #define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&p, _p)) ABORT; \\ \tif (!BN_hex2bn(&a, _a)) ABORT; \\ \tif (!BN_hex2bn(&b, _b)) ABORT; \\ \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\ \tCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tfprintf(stdout, \"verify degree ...\"); \\ \tif (EC_GROUP_get_degree(group) != _degree) ABORT; \\ \tfprintf(stdout, \" ok\\n\"); \\ \tgroup_order_tests(group); \\ \tif (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\ \tif (!EC_GROUP_copy(_variable, group)) ABORT; \\-static void char2_field_tests()+static void char2_field_tests(void) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 = NULL, *C2_K571 = NULL; \tEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 = NULL, *C2_B571 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z, *cof; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"13\")) ABORT; \tif (!BN_hex2bn(&a, \"3\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use EC_GROUP_new_curve_GF2m \t                                                * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n(0x... means binary polynomial)\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tcof = BN_new(); \tif (!x || !y || !z || !cof) ABORT; \tif (!BN_hex2bn(&x, \"6\")) ABORT;",
            "commit_date": "2011-01-09 17:50:06+00:00",
            "commit_hash": "c13d7c02968c17a7c5eb8dca1ace6a916be0de3a",
            "message": "Fix warning."
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -731,121 +731,121 @@ /* Change test based on whether binary point compression is enabled or not. */ #ifdef OPENSSL_EC_BIN_PT_COMP #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); \\ \t/* G_y value taken from the standard: */ \\ \tif (!BN_hex2bn(&z, _y)) ABORT; \\ \tif (0 != BN_cmp(y, z)) ABORT; #else  #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!BN_hex2bn(&y, _y)) ABORT; \\ \tif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); #endif #define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&p, _p)) ABORT; \\ \tif (!BN_hex2bn(&a, _a)) ABORT; \\ \tif (!BN_hex2bn(&b, _b)) ABORT; \\ \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\ \tCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tfprintf(stdout, \"verify degree ...\"); \\ \tif (EC_GROUP_get_degree(group) != _degree) ABORT; \\ \tfprintf(stdout, \" ok\\n\"); \\ \tgroup_order_tests(group); \\ \tif (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\ \tif (!EC_GROUP_copy(_variable, group)) ABORT; \\-void char2_field_tests()+static void char2_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 = NULL, *C2_K571 = NULL; \tEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 = NULL, *C2_B571 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z, *cof; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"13\")) ABORT; \tif (!BN_hex2bn(&a, \"3\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use EC_GROUP_new_curve_GF2m \t                                                * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n(0x... means binary polynomial)\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tcof = BN_new(); \tif (!x || !y || !z || !cof) ABORT; \tif (!BN_hex2bn(&x, \"6\")) ABORT;",
            "commit_date": "2010-09-05 16:34:49+00:00",
            "commit_hash": "5df2a2497a3e1ad7d5a386bbe34d3be9eb3a0ba3",
            "message": "Fix warnings."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -751,130 +730,121 @@ /* Change test based on whether binary point compression is enabled or not. */ #ifdef OPENSSL_EC_BIN_PT_COMP #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); \\ \t/* G_y value taken from the standard: */ \\ \tif (!BN_hex2bn(&z, _y)) ABORT; \\ \tif (0 != BN_cmp(y, z)) ABORT; #else  #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!BN_hex2bn(&y, _y)) ABORT; \\ \tif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); #endif #define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&p, _p)) ABORT; \\ \tif (!BN_hex2bn(&a, _a)) ABORT; \\ \tif (!BN_hex2bn(&b, _b)) ABORT; \\ \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\ \tCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tfprintf(stdout, \"verify degree ...\"); \\ \tif (EC_GROUP_get_degree(group) != _degree) ABORT; \\ \tfprintf(stdout, \" ok\\n\"); \\-\tfprintf(stdout, \"verify group order ...\"); \\-\tfflush(stdout); \\-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \\-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \\-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \\-\tfprintf(stdout, \".\"); \\-\tfflush(stdout); \\-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \\-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \\-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \\-\tfprintf(stdout, \" ok\\n\"); \\+\tgroup_order_tests(group); \\ \tif (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\-\tif (!EC_GROUP_copy(_variable, group)) ABORT;+\tif (!EC_GROUP_copy(_variable, group)) ABORT; \\+ void char2_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 = NULL, *C2_K571 = NULL; \tEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 = NULL, *C2_B571 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z, *cof; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"13\")) ABORT; \tif (!BN_hex2bn(&a, \"3\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use EC_GROUP_new_curve_GF2m \t                                                * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n(0x... means binary polynomial)\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tcof = BN_new(); \tif (!x || !y || !z || !cof) ABORT; \tif (!BN_hex2bn(&x, \"6\")) ABORT;",
            "commit_date": "2010-08-26 14:29:55+00:00",
            "commit_hash": "04daec862ced4e5e3921724b7a59c432fa9cbab3",
            "message": "New 64-bit optimized implementation EC_GFp_nistp224_method().\nThis will only be compiled in if explicitly requested\n(#ifdef EC_NISTP224_64_GCC_128).\nSubmitted by: Emilia Kasper (Google)"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -743,130 +743,130 @@ /* Change test based on whether binary point compression is enabled or not. */ #ifdef OPENSSL_EC_BIN_PT_COMP #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); \\ \t/* G_y value taken from the standard: */ \\ \tif (!BN_hex2bn(&z, _y)) ABORT; \\ \tif (0 != BN_cmp(y, z)) ABORT; #else  #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!BN_hex2bn(&y, _y)) ABORT; \\ \tif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); #endif #define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&p, _p)) ABORT; \\ \tif (!BN_hex2bn(&a, _a)) ABORT; \\ \tif (!BN_hex2bn(&b, _b)) ABORT; \\ \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\ \tCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tfprintf(stdout, \"verify degree ...\"); \\ \tif (EC_GROUP_get_degree(group) != _degree) ABORT; \\ \tfprintf(stdout, \" ok\\n\"); \\ \tfprintf(stdout, \"verify group order ...\"); \\ \tfflush(stdout); \\ \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \\ \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \\ \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \\ \tfprintf(stdout, \".\"); \\ \tfflush(stdout); \\ \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \\ \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \\ \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \\ \tfprintf(stdout, \" ok\\n\"); \\ \tif (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\ \tif (!EC_GROUP_copy(_variable, group)) ABORT; void char2_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 = NULL, *C2_K571 = NULL; \tEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 = NULL, *C2_B571 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z, *cof; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"13\")) ABORT; \tif (!BN_hex2bn(&a, \"3\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use EC_GROUP_new_curve_GF2m \t                                                * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT;-\t\tif (!EC_GROUP_copy(tmp, group));+\t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n(0x... means binary polynomial)\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tcof = BN_new(); \tif (!x || !y || !z || !cof) ABORT; \tif (!BN_hex2bn(&x, \"6\")) ABORT;",
            "commit_date": "2005-08-28 22:49:57+00:00",
            "commit_hash": "8215e7a93897347a97de87b3d26fe84cc8a5b05d",
            "message": "fix warnings when building openssl with the following compiler options:\n-Wmissing-prototypes -Wcomment -Wformat -Wimplicit -Wmain -Wmultichar\n-Wswitch -Wshadow -Wtrigraphs -Werror -Wchar-subscripts\n-Wstrict-prototypes -Wreturn-type -Wpointer-arith  -W -Wunused\n-Wno-unused-parameter -Wuninitialized"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -670,130 +670,130 @@ /* Change test based on whether binary point compression is enabled or not. */ #ifdef OPENSSL_EC_BIN_PT_COMP #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); \\ \t/* G_y value taken from the standard: */ \\ \tif (!BN_hex2bn(&z, _y)) ABORT; \\ \tif (0 != BN_cmp(y, z)) ABORT; #else  #define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&x, _x)) ABORT; \\ \tif (!BN_hex2bn(&y, _y)) ABORT; \\ \tif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\ \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\ \tif (!BN_hex2bn(&z, _order)) ABORT; \\ \tif (!BN_hex2bn(&cof, _cof)) ABORT; \\ \tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\ \tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\ \tBN_print_fp(stdout, x); \\ \tfprintf(stdout, \"\\n     y = 0x\"); \\ \tBN_print_fp(stdout, y); \\ \tfprintf(stdout, \"\\n\"); #endif #define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tif (!BN_hex2bn(&p, _p)) ABORT; \\ \tif (!BN_hex2bn(&a, _a)) ABORT; \\ \tif (!BN_hex2bn(&b, _b)) ABORT; \\ \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\ \tCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\ \tfprintf(stdout, \"verify degree ...\"); \\ \tif (EC_GROUP_get_degree(group) != _degree) ABORT; \\ \tfprintf(stdout, \" ok\\n\"); \\ \tfprintf(stdout, \"verify group order ...\"); \\ \tfflush(stdout); \\ \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \\ \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \\ \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \\ \tfprintf(stdout, \".\"); \\ \tfflush(stdout); \\ \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \\ \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \\ \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \\ \tfprintf(stdout, \" ok\\n\"); \\ \tif (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\ \tif (!EC_GROUP_copy(_variable, group)) ABORT; void char2_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 = NULL, *C2_K571 = NULL; \tEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 = NULL, *C2_B571 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z, *cof; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"13\")) ABORT; \tif (!BN_hex2bn(&a, \"3\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT;-\tgroup = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use EC_GROUP_new_curve_GFp-\t                                             * so that the library gets to choose the EC_METHOD */+\tgroup = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use EC_GROUP_new_curve_GF2m+\t                                                * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b);-\tfprintf(stdout, \"\\n\");+\tfprintf(stdout, \"\\n(0x... means binary polynomial)\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tcof = BN_new(); \tif (!x || !y || !z || !cof) ABORT; \tif (!BN_hex2bn(&x, \"6\")) ABORT;",
            "commit_date": "2002-08-02 17:25:05+00:00",
            "commit_hash": "848c849584c2c6de3373516a762fa4279d89a8c3",
            "message": "optical changes"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -626,0 +667,130 @@++/* Change test based on whether binary point compression is enabled or not. */+#ifdef OPENSSL_EC_BIN_PT_COMP+#define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+\tif (!BN_hex2bn(&x, _x)) ABORT; \\+\tif (!EC_POINT_set_compressed_coordinates_GF2m(group, P, x, _y_bit, ctx)) ABORT; \\+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\+\tif (!BN_hex2bn(&z, _order)) ABORT; \\+\tif (!BN_hex2bn(&cof, _cof)) ABORT; \\+\tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\+\tif (!EC_POINT_get_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\+\tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\+\tBN_print_fp(stdout, x); \\+\tfprintf(stdout, \"\\n     y = 0x\"); \\+\tBN_print_fp(stdout, y); \\+\tfprintf(stdout, \"\\n\"); \\+\t/* G_y value taken from the standard: */ \\+\tif (!BN_hex2bn(&z, _y)) ABORT; \\+\tif (0 != BN_cmp(y, z)) ABORT;+#else +#define CHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+\tif (!BN_hex2bn(&x, _x)) ABORT; \\+\tif (!BN_hex2bn(&y, _y)) ABORT; \\+\tif (!EC_POINT_set_affine_coordinates_GF2m(group, P, x, y, ctx)) ABORT; \\+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \\+\tif (!BN_hex2bn(&z, _order)) ABORT; \\+\tif (!BN_hex2bn(&cof, _cof)) ABORT; \\+\tif (!EC_GROUP_set_generator(group, P, z, cof)) ABORT; \\+\tfprintf(stdout, \"\\n%s -- Generator:\\n     x = 0x\", _name); \\+\tBN_print_fp(stdout, x); \\+\tfprintf(stdout, \"\\n     y = 0x\"); \\+\tBN_print_fp(stdout, y); \\+\tfprintf(stdout, \"\\n\");+#endif++#define CHAR2_CURVE_TEST(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+\tif (!BN_hex2bn(&p, _p)) ABORT; \\+\tif (!BN_hex2bn(&a, _a)) ABORT; \\+\tif (!BN_hex2bn(&b, _b)) ABORT; \\+\tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT; \\+\tCHAR2_CURVE_TEST_INTERNAL(_name, _p, _a, _b, _x, _y, _y_bit, _order, _cof, _degree, _variable) \\+\tfprintf(stdout, \"verify degree ...\"); \\+\tif (EC_GROUP_get_degree(group) != _degree) ABORT; \\+\tfprintf(stdout, \" ok\\n\"); \\+\tfprintf(stdout, \"verify group order ...\"); \\+\tfflush(stdout); \\+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \\+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \\+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \\+\tfprintf(stdout, \".\"); \\+\tfflush(stdout); \\+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \\+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \\+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \\+\tfprintf(stdout, \" ok\\n\"); \\+\tif (!(_variable = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \\+\tif (!EC_GROUP_copy(_variable, group)) ABORT;++void char2_field_tests()+\t{\t+\tBN_CTX *ctx = NULL;+\tBIGNUM *p, *a, *b;+\tEC_GROUP *group;+\tEC_GROUP *C2_K163 = NULL, *C2_K233 = NULL, *C2_K283 = NULL, *C2_K409 = NULL, *C2_K571 = NULL;+\tEC_GROUP *C2_B163 = NULL, *C2_B233 = NULL, *C2_B283 = NULL, *C2_B409 = NULL, *C2_B571 = NULL;+\tEC_POINT *P, *Q, *R;+\tBIGNUM *x, *y, *z, *cof;+\tunsigned char buf[100];+\tsize_t i, len;+\tint k;+\t+#if 1 /* optional */+\tctx = BN_CTX_new();+\tif (!ctx) ABORT;+#endif++\tp = BN_new();+\ta = BN_new();+\tb = BN_new();+\tif (!p || !a || !b) ABORT;++\tif (!BN_hex2bn(&p, \"13\")) ABORT;+\tif (!BN_hex2bn(&a, \"3\")) ABORT;+\tif (!BN_hex2bn(&b, \"1\")) ABORT;+\t+\tgroup = EC_GROUP_new(EC_GF2m_simple_method()); /* applications should use EC_GROUP_new_curve_GFp+\t                                             * so that the library gets to choose the EC_METHOD */+\tif (!group) ABORT;+\tif (!EC_GROUP_set_curve_GF2m(group, p, a, b, ctx)) ABORT;++\t{+\t\tEC_GROUP *tmp;+\t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group));+\t\tif (!tmp) ABORT;+\t\tif (!EC_GROUP_copy(tmp, group));+\t\tEC_GROUP_free(group);+\t\tgroup = tmp;+\t}+\t+\tif (!EC_GROUP_get_curve_GF2m(group, p, a, b, ctx)) ABORT;++\tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 + x*y = x^3 + a*x^2 + b  (mod 0x\");+\tBN_print_fp(stdout, p);+\tfprintf(stdout, \")\\n     a = 0x\");+\tBN_print_fp(stdout, a);+\tfprintf(stdout, \"\\n     b = 0x\");+\tBN_print_fp(stdout, b);+\tfprintf(stdout, \"\\n\");++\tP = EC_POINT_new(group);+\tQ = EC_POINT_new(group);+\tR = EC_POINT_new(group);+\tif (!P || !Q || !R) ABORT;+\t+\tif (!EC_POINT_set_to_infinity(group, P)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;++\tbuf[0] = 0;+\tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT;++\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;++\tx = BN_new();+\ty = BN_new();+\tz = BN_new();+\tcof = BN_new();+\tif (!x || !y || !z || !cof) ABORT;++\tif (!BN_hex2bn(&x, \"6\")) ABORT;",
            "commit_date": "2002-08-02 13:42:24+00:00",
            "commit_hash": "7793f30e09c104b209206608a20f2088b1b635fd",
            "message": "add support for elliptic curves over binary fields\nSubmitted by: Duglas Stebila <douglas.stebila@sun.com>,\nSheueling Chang <sheueling.chang@sun.com>\n(CHANGES entries by Bodo Moeller)"
        }
    ],
    "git log -L278,293:test/v3nametest.c": [
        {
            "author": {
                "email": "jiasheng@iscas.ac.cn",
                "name": "Jiasheng Jiang"
            },
            "changes": "diff --git a/test/v3nametest.c b/test/v3nametest.c--- a/test/v3nametest.c+++ b/test/v3nametest.c@@ -278,14 +278,16 @@ static int run_cert(X509 *crt, const char *nameincert, {+        if (!TEST_ptr(name))+            return 0;",
            "commit_date": "2022-06-15 15:37:36+08:00",
            "commit_hash": "b147b9daf17744d529f23b5da40397a6071a88aa",
            "message": "test/v3nametest.c: Add check for OPENSSL_malloc\nAs the potential failure of the OPENSSL_malloc(),\nit should be better to add the check and return\nerror if fails.\nSigned-off-by: Jiasheng Jiang <jiasheng@iscas.ac.cn>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/18573)\nconst struct set_name_fn *fn)\nconst char *const *pname = names;\nint failed = 0;\nfor (; *pname != NULL; ++pname) {\nint samename = OPENSSL_strcasecmp(nameincert, *pname) == 0;\nsize_t namelen = strlen(*pname);\nchar *name = OPENSSL_malloc(namelen + 1);\nint match, ret;\nmemcpy(name, *pname, namelen + 1);"
        },
        {
            "author": {
                "email": "beldmit@gmail.com",
                "name": "Dmitry Belyavskiy"
            },
            "changes": "diff --git a/test/v3nametest.c b/test/v3nametest.c--- a/test/v3nametest.c+++ b/test/v3nametest.c@@ -282,14 +278,14 @@ static int run_cert(X509 *crt, const char *nameincert, {-        int samename = strcasecmp(nameincert, *pname) == 0;+        int samename = OPENSSL_strcasecmp(nameincert, *pname) == 0;",
            "commit_date": "2022-04-12 12:30:08+02:00",
            "commit_hash": "fba140c73541c03e22b4fdb219a05d129bf0406d",
            "message": "str[n]casecmp => OPENSSL_strncasecmp\nReviewed-by: Tim Hudson <tjh@openssl.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/18069)\nconst struct set_name_fn *fn)\nconst char *const *pname = names;\nint failed = 0;\nfor (; *pname != NULL; ++pname) {\nsize_t namelen = strlen(*pname);\nchar *name = OPENSSL_malloc(namelen + 1);\nint match, ret;\nmemcpy(name, *pname, namelen + 1);"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/v3nametest.c b/test/v3nametest.c--- a/test/v3nametest.c+++ b/test/v3nametest.c@@ -282,14 +282,14 @@ static int run_cert(X509 *crt, const char *nameincert, {-        char *name = OPENSSL_malloc(namelen);+        char *name = OPENSSL_malloc(namelen + 1);-        memcpy(name, *pname, namelen);+        memcpy(name, *pname, namelen + 1);",
            "commit_date": "2020-10-09 09:32:04+10:00",
            "commit_hash": "fb33f99409972ea3d217399558d3baed4a57926d",
            "message": "coverity 1414446 out-of-bounds access: allocate \\0 terminator byte to be safe\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/13091)\nconst struct set_name_fn *fn)\nconst char *const *pname = names;\nint failed = 0;\nfor (; *pname != NULL; ++pname) {\nint samename = strcasecmp(nameincert, *pname) == 0;\nsize_t namelen = strlen(*pname);\nint match, ret;"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/v3nametest.c b/test/v3nametest.c--- a/test/v3nametest.c+++ b/test/v3nametest.c@@ -277,11 +277,14 @@-static void run_cert(X509 *crt, const char *nameincert,+static int run_cert(X509 *crt, const char *nameincert, {-    while (*pname) {+    int failed = 0;++    for (; *pname != NULL; ++pname) {-        char *name = malloc(namelen);+        char *name = OPENSSL_malloc(namelen);+",
            "commit_date": "2017-04-17 13:54:45-04:00",
            "commit_hash": "f3ab6c16c424054c8d6d2c152744dcbaf41c3232",
            "message": "Update more tests\nmodes_internal_test, sslcorrupttest, v3nametest\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3238)\nconst struct set_name_fn *fn)\nconst char *const *pname = names;\nint samename = strcasecmp(nameincert, *pname) == 0;\nsize_t namelen = strlen(*pname);\nint match, ret;\nmemcpy(name, *pname, namelen);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/x509v3/v3nametest.c b/crypto/x509v3/v3nametest.c--- a/crypto/x509v3/v3nametest.c+++ b/crypto/x509v3/v3nametest.c@@ -265,12 +258,11 @@ static void run_cert(X509 *crt, const char *nameincert,-\t\t     const struct set_name_fn *fn)-\t{-\tconst char *const *pname = names;-\twhile (*pname)-\t\t{-\t\tint samename = strcasecmp(nameincert, *pname) == 0;-\t\tsize_t namelen = strlen(*pname);-\t\tchar *name = malloc(namelen);-\t\tint match, ret;-\t\tmemcpy(name, *pname, namelen);+                     const struct set_name_fn *fn)+{+    const char *const *pname = names;+    while (*pname) {+        int samename = strcasecmp(nameincert, *pname) == 0;+        size_t namelen = strlen(*pname);+        char *name = malloc(namelen);+        int match, ret;+        memcpy(name, *pname, namelen);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/x509v3/v3nametest.c b/crypto/x509v3/v3nametest.c--- /dev/null+++ b/crypto/x509v3/v3nametest.c@@ -0,0 +260,12 @@++static void run_cert(X509 *crt, const char *nameincert,+\t\t     const struct set_name_fn *fn)+\t{+\tconst char *const *pname = names;+\twhile (*pname)+\t\t{+\t\tint samename = strcasecmp(nameincert, *pname) == 0;+\t\tsize_t namelen = strlen(*pname);+\t\tchar *name = malloc(namelen);+\t\tint match, ret;+\t\tmemcpy(name, *pname, namelen);",
            "commit_date": "2012-11-18 15:13:55+00:00",
            "commit_hash": "d88926f1815d79c800e4cf11ecee8e43f3a7ad1f",
            "message": "PR: 2909\nContributed by: Florian Weimer <fweimer@redhat.com>\nFixes to X509 hostname and email address checking. Wildcard matching support.\nNew test program and manual page."
        }
    ],
    "git log -L2122,2146:test/bntest.c": [
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1640,25 +1640,25 @@-static int test_asc2bn()+static int test_asc2bn(void) {",
            "commit_date": "2017-08-15 23:39:03+02:00",
            "commit_hash": "31a80694d425bf7f3a0ed5cc2ee775d9418a5490",
            "message": "[Win] Fix some test method signatures ...\nto halves MSVC warnings.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4172)\nBIGNUM *bn = NULL;\nint st = 0;\nif (!TEST_ptr(bn = BN_new()))\ngoto err;\nif (!TEST_true(BN_asc2bn(&bn, \"0\"))\n|| !TEST_BN_eq_zero(bn)\n|| !TEST_BN_ge_zero(bn))\ngoto err;\nif (!TEST_true(BN_asc2bn(&bn, \"256\"))\n|| !TEST_BN_eq_word(bn, 256)\n|| !TEST_BN_ge_zero(bn))\ngoto err;\nif (!TEST_true(BN_asc2bn(&bn, \"-42\"))\n|| !TEST_BN_abs_eq_word(bn, 42)\n|| !TEST_BN_lt_zero(bn))\ngoto err;\nif (!TEST_true(BN_asc2bn(&bn, \"0x1234\"))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1614,25 +1653,25 @@ static int test_asc2bn() {-            || !TEST_true(BN_is_zero(bn))-            || !TEST_false(BN_is_negative(bn)))+            || !TEST_BN_eq_zero(bn)+            || !TEST_BN_ge_zero(bn))-            || !TEST_true(BN_is_word(bn, 256))-            || !TEST_false(BN_is_negative(bn)))+            || !TEST_BN_eq_word(bn, 256)+            || !TEST_BN_ge_zero(bn))-            || !TEST_true(BN_abs_is_word(bn, 42))-            || !TEST_true(BN_is_negative(bn)))+            || !TEST_BN_abs_eq_word(bn, 42)+            || !TEST_BN_lt_zero(bn))",
            "commit_date": "2017-05-08 12:09:41+10:00",
            "commit_hash": "dc352c193755525292310c8992e3c9b81a556a31",
            "message": "Add BN support to the test infrastructure.\nThis includes support for:\n- comparisions between pairs of BIGNUMs\n- comparisions between BIGNUMs and zero\n- equality comparison between BIGNUMs and one\n- equality comparisons between BIGNUMs and constants\n- parity checks for BIGNUMs\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3405)\nBIGNUM *bn = NULL;\nint st = 0;\nif (!TEST_ptr(bn = BN_new()))\ngoto err;\nif (!TEST_true(BN_asc2bn(&bn, \"0\"))\ngoto err;\nif (!TEST_true(BN_asc2bn(&bn, \"256\"))\ngoto err;\nif (!TEST_true(BN_asc2bn(&bn, \"-42\"))\ngoto err;\nif (!TEST_true(BN_asc2bn(&bn, \"0x1234\"))"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1704,31 +1614,25 @@ static int test_asc2bn() {-    BIGNUM *bn = BN_new();+    BIGNUM *bn = NULL;-    if (!BN_asc2bn(&bn, \"0\") || !BN_is_zero(bn) || BN_is_negative(bn)) {-        fprintf(stderr, \"BN_asc2bn(0) gave a bad result.\\n\");+    if (!TEST_ptr(bn = BN_new()))-    }-    if (!BN_asc2bn(&bn, \"256\") || !BN_is_word(bn, 256) || BN_is_negative(bn)) {-        fprintf(stderr, \"BN_asc2bn(256) gave a bad result.\\n\");+    if (!TEST_true(BN_asc2bn(&bn, \"0\"))+            || !TEST_true(BN_is_zero(bn))+            || !TEST_false(BN_is_negative(bn)))-    }-    if (!BN_asc2bn(&bn, \"-42\")-            || !BN_abs_is_word(bn, 42) || !BN_is_negative(bn)) {-        fprintf(stderr, \"BN_asc2bn(-42) gave a bad result.\\n\");+    if (!TEST_true(BN_asc2bn(&bn, \"256\"))+            || !TEST_true(BN_is_word(bn, 256))+            || !TEST_false(BN_is_negative(bn)))-    }-    if (!BN_asc2bn(&bn, \"0x1234\")-            || !BN_is_word(bn, 0x1234) || BN_is_negative(bn)) {-        fprintf(stderr, \"BN_asc2bn(0x1234) gave a bad result.\\n\");+    if (!TEST_true(BN_asc2bn(&bn, \"-42\"))+            || !TEST_true(BN_abs_is_word(bn, 42))+            || !TEST_true(BN_is_negative(bn)))-    }-    if (!BN_asc2bn(&bn, \"0X1234\")-            || !BN_is_word(bn, 0x1234) || BN_is_negative(bn)) {-        fprintf(stderr, \"BN_asc2bn(0X1234) gave a bad result.\\n\");+    if (!TEST_true(BN_asc2bn(&bn, \"0x1234\"))",
            "commit_date": "2017-04-26 12:39:46-04:00",
            "commit_hash": "30bea14be6bbf77ed60acb9bd1befeb51d4c4b10",
            "message": "Convert bntest to TEST_ framework\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3265)\nint st = 0;\ngoto err;\ngoto err;\ngoto err;\ngoto err;"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1650,13 +1617,31 @@-    char c = '*';--    if (p == 0)-        c = '.';-    if (p == 1)-        c = '+';-    if (p == 2)-        c = '*';-    if (p == 3)-        c = '\\n';-    putc(c, stderr);-    fflush(stderr);-    return 1;++static int test_asc2bn()+{+    BIGNUM *bn = BN_new();+    int st = 0;++    if (!BN_asc2bn(&bn, \"0\") || !BN_is_zero(bn) || BN_is_negative(bn)) {+        fprintf(stderr, \"BN_asc2bn(0) gave a bad result.\\n\");+        goto err;+    }++    if (!BN_asc2bn(&bn, \"256\") || !BN_is_word(bn, 256) || BN_is_negative(bn)) {+        fprintf(stderr, \"BN_asc2bn(256) gave a bad result.\\n\");+        goto err;+    }++    if (!BN_asc2bn(&bn, \"-42\")+            || !BN_abs_is_word(bn, 42) || !BN_is_negative(bn)) {+        fprintf(stderr, \"BN_asc2bn(-42) gave a bad result.\\n\");+        goto err;+    }++    if (!BN_asc2bn(&bn, \"0x1234\")+            || !BN_is_word(bn, 0x1234) || BN_is_negative(bn)) {+        fprintf(stderr, \"BN_asc2bn(0x1234) gave a bad result.\\n\");+        goto err;+    }++    if (!BN_asc2bn(&bn, \"0X1234\")+            || !BN_is_word(bn, 0x1234) || BN_is_negative(bn)) {+        fprintf(stderr, \"BN_asc2bn(0X1234) gave a bad result.\\n\");",
            "commit_date": "2016-11-28 12:26:05-05:00",
            "commit_hash": "8d1ebff41c75e4eebc7d5cc5a561a1bab6b50e70",
            "message": "Make bntest be (mostly) file-based.\nTest suite used from boring, written by David Benjamin.\nTest driver converted from C++ to C.\nAdded a Perl program to check the testsuite file.\nExtensive review feedback incorporated (thanks folks).\nReviewed-by: Emilia K\u00e4sper <emilia@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -1784,11 +1713,13 @@-\t{-\tchar c='*';--\tif (p == 0) c='.';-\tif (p == 1) c='+';-\tif (p == 2) c='*';-\tif (p == 3) c='\\n';-\tputc(c, stderr);-\tfflush(stderr);-\treturn 1;-\t}+    char c = '*';++    if (p == 0)+        c = '.';+    if (p == 1)+        c = '+';+    if (p == 2)+        c = '*';+    if (p == 3)+        c = '\\n';+    putc(c, stderr);+    fflush(stderr);+    return 1;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -1506,12 +1506,11 @@ \t{ \tchar c='*'; \tif (p == 0) c='.'; \tif (p == 1) c='+'; \tif (p == 2) c='*'; \tif (p == 3) c='\\n'; \tputc(c, stderr); \tfflush(stderr);-\t(void)n;-\t(void)arg;+\treturn 1; \t}",
            "commit_date": "2003-10-29 04:14:08+00:00",
            "commit_hash": "2aaec9cced89edfdc8375b38a130fa1c35a98025",
            "message": "Update any code that was using deprecated functions so that everything builds\nand links with OPENSSL_NO_DEPRECATED defined."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -903,0 +904,12 @@+\t{+\tchar c='*';++\tif (p == 0) c='.';+\tif (p == 1) c='+';+\tif (p == 2) c='*';+\tif (p == 3) c='\\n';+\tputc(c, stderr);+\tfflush(stderr);+\t(void)n;+\t(void)arg;+\t}",
            "commit_date": "2000-11-29 11:06:50+00:00",
            "commit_hash": "bdec3c5323c7a726814257ec9b43fcd259f4e206",
            "message": "Implement BN_kronecker test.\nModify \"CHANGES\" entry for BN_mod_inverse (it's not just avoiding BN_div\nthat increases performance, avoiding BN_mul also helps)"
        }
    ],
    "git log -L2013,2023:test/ectest.c": [
        {
            "author": {
                "email": "nic.tuv@gmail.com",
                "name": "Nicola Tuveri"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1815,10 +2080,11 @@+ static int parameter_test(void) {",
            "commit_date": "2019-09-07 18:05:31+03:00",
            "commit_hash": "bacaa618c26411d212015493d0eb82076a3e76a1",
            "message": "[ec] Match built-in curves on EC_GROUP_new_from_ecparameters\nDescription\n-----------\nUpon `EC_GROUP_new_from_ecparameters()` check if the parameters match any\nof the built-in curves. If that is the case, return a new\n`EC_GROUP_new_by_curve_name()` object instead of the explicit parameters\n`EC_GROUP`.\nThis affects all users of `EC_GROUP_new_from_ecparameters()`:\n- direct calls to `EC_GROUP_new_from_ecparameters()`\n- direct calls to `EC_GROUP_new_from_ecpkparameters()` with an explicit\nparameters argument\n- ASN.1 parsing of explicit parameters keys (as it eventually\nends up calling `EC_GROUP_new_from_ecpkparameters()`)\nA parsed explicit parameter key will still be marked with the\n`OPENSSL_EC_EXPLICIT_CURVE` ASN.1 flag on load, so, unless\nprogrammatically forced otherwise, if the key is eventually serialized\nthe output will still be encoded with explicit parameters, even if\ninternally it is treated as a named curve `EC_GROUP`.\nBefore this change, creating any `EC_GROUP` object using\n`EC_GROUP_new_from_ecparameters()`, yielded an object associated with\nthe default generic `EC_METHOD`, but this was never guaranteed in the\ndocumentation.\nAfter this commit, users of the library that intentionally want to\ncreate an `EC_GROUP` object using a specific `EC_METHOD` can still\nexplicitly call `EC_GROUP_new(foo_method)` and then manually set the\ncurve parameters using `EC_GROUP_set_*()`.\nMotivation\n----------\nThis has obvious performance benefits for the built-in curves with\nspecialized `EC_METHOD`s and subtle but important security benefits:\n- the specialized methods have better security hardening than the\ngeneric implementations\n- optional fields in the parameter encoding, like the `cofactor`, cannot\nbe leveraged by an attacker to force execution of the less secure\ncode-paths for single point scalar multiplication\n- in general, this leads to reducing the attack surface\nCheck the manuscript at https://arxiv.org/abs/1909.01785 for an in depth\nanalysis of the issues related to this commit.\nIt should be noted that `libssl` does not allow to negotiate explicit\nparameters (as per RFC 8422), so it is not directly affected by the\nconsequences of using explicit parameters that this commit fixes.\nOn the other hand, we detected external applications and users in the\nwild that use explicit parameters by default (and sometimes using 0 as\nthe cofactor value, which is technically not a valid value per the\nspecification, but is tolerated by parsers for wider compatibility given\nthat the field is optional).\nThese external users of `libcrypto` are exposed to these vulnerabilities\nand their security will benefit from this commit.\nRelated commits\n---------------\nWhile this commit is beneficial for users using built-in curves and\nexplicit parameters encoding for serialized keys, commit\nb783beeadf6b80bc431e6f3230b5d5585c87ef87 (and its equivalents for the\n1.0.2, 1.1.0 and 1.1.1 stable branches) fixes the consequences of the\ninvalid cofactor values more in general also for other curves\n(CVE-2019-1547).\nThe following list covers commits in `master` that are related to the\nvulnerabilities presented in the manuscript motivating this commit:\n- d2baf88c43 [crypto/rsa] Set the constant-time flag in multi-prime RSA too\n- 311e903d84 [crypto/asn1] Fix multiple SCA vulnerabilities during RSA key validation.\n- b783beeadf [crypto/ec] for ECC parameters with NULL or zero cofactor, compute it\n- 724339ff44 Fix SCA vulnerability when using PVK and MSBLOB key formats\nNote that the PRs that contributed the listed commits also include other\ncommits providing related testing and documentation, in addition to\nlinks to PRs and commits backporting the fixes to the 1.0.2, 1.1.0 and\n1.1.1 branches.\nResponsible Disclosure\n----------------------\nThis and the other issues presented in https://arxiv.org/abs/1909.01785\nwere reported by Cesar Pereida Garc\u00eda, Sohaib ul Hassan, Nicola Tuveri,\nIaroslav Gridin, Alejandro Cabrera Aldaya and Billy Bob Brumley from the\nNISEC group at Tampere University, FINLAND.\nThe OpenSSL Security Team evaluated the security risk for this\nvulnerability as low, and encouraged to propose fixes using public Pull\nRequests.\n_______________________________________________________________________________\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/9808)\nEC_GROUP *group = NULL, *group2 = NULL;\nECPARAMETERS *ecparameters = NULL;\nunsigned char *buf = NULL;\nint r = 0, len;\nif (!TEST_ptr(group = EC_GROUP_new_by_curve_name(NID_secp384r1))\n|| !TEST_ptr(ecparameters = EC_GROUP_get_ecparameters(group, NULL))\n|| !TEST_ptr(group2 = EC_GROUP_new_from_ecparameters(ecparameters))"
        },
        {
            "author": {
                "email": "nic.tuv@gmail.com",
                "name": "Nicola Tuveri"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1816,10 +1816,10 @@ static int parameter_test(void) {-    if (!TEST_ptr(group = EC_GROUP_new_by_curve_name(NID_secp224r1))+    if (!TEST_ptr(group = EC_GROUP_new_by_curve_name(NID_secp384r1))",
            "commit_date": "2019-07-28 16:13:30+03:00",
            "commit_hash": "f5b7f99e690b1875e6d047acc435f0029642bfeb",
            "message": "Temporary workaround for ectest.c for [extended tests]\n[extended tests]\nThis is a temporary workaround for issue #9251, which contains a full\ndiscussion of the real problem.\nAs a temporary workaround, we test `EC_GROUP_new_from_ecparameters()`\nagainst a curve that does not currently have alternative\nimplementations.\nThe proper fix is dependant on resolution of issue #8615\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/9474)\nEC_GROUP *group = NULL, *group2 = NULL;\nECPARAMETERS *ecparameters = NULL;\nunsigned char *buf = NULL;\nint r = 0, len;\n|| !TEST_ptr(ecparameters = EC_GROUP_get_ecparameters(group, NULL))\n|| !TEST_ptr(group2 = EC_GROUP_new_from_ecparameters(ecparameters))"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1816,10 +1816,10 @@ static int parameter_test(void) {-    if (!TEST_ptr(group = EC_GROUP_new_by_curve_name(NID_secp112r1))+    if (!TEST_ptr(group = EC_GROUP_new_by_curve_name(NID_secp224r1))",
            "commit_date": "2019-06-05 08:24:16+10:00",
            "commit_hash": "10c25644e362381844e0089504f0db42f029d855",
            "message": "EC only uses approved curves in FIPS mode.\nOnce there are buildable fips tests, some tests that are data driven\nfrom files will need to be modified to exclude non approved curves in\nfips mode.\nThese changes were tested by temporarily adding #define FIPS_MODE 1 to\nall the modified source files.\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/9081)\nEC_GROUP *group = NULL, *group2 = NULL;\nECPARAMETERS *ecparameters = NULL;\nunsigned char *buf = NULL;\nint r = 0, len;\n|| !TEST_ptr(ecparameters = EC_GROUP_get_ecparameters(group, NULL))\n|| !TEST_ptr(group2 = EC_GROUP_new_from_ecparameters(ecparameters))"
        },
        {
            "author": {
                "email": "davidben@google.com",
                "name": "David Benjamin"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1410,5 +1455,10 @@ static int parameter_test(void) {-    int r;+    unsigned char *buf = NULL;+    int r = 0, len;++    if (!TEST_ptr(group = EC_GROUP_new_by_curve_name(NID_secp112r1))+        || !TEST_ptr(ecparameters = EC_GROUP_get_ecparameters(group, NULL))+        || !TEST_ptr(group2 = EC_GROUP_new_from_ecparameters(ecparameters))",
            "commit_date": "2018-05-20 14:33:49-04:00",
            "commit_hash": "fc6f579a9e625caa0c8b93d9716ddbc558e21a29",
            "message": "Fix explicit EC curve encoding.\nPer SEC 1, the curve coefficients must be padded up to size. See C.2's\ndefinition of Curve, C.1's definition of FieldElement, and 2.3.5's definition\nof how to encode the field elements in http://www.secg.org/sec1-v2.pdf.\nThis comes up for P-521, where b needs a leading zero.\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/6314)\nEC_GROUP *group = NULL, *group2 = NULL;\nECPARAMETERS *ecparameters = NULL;"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1712,19 +1476,5 @@-static void parameter_test(void)+static int parameter_test(void) {-    EC_GROUP *group, *group2;-    ECPARAMETERS *ecparameters;--    fprintf(stderr, \"\\ntesting ecparameters conversion ...\");--    group = EC_GROUP_new_by_curve_name(NID_secp112r1);-    if (!group)-        ABORT;--    ecparameters = EC_GROUP_get_ecparameters(group, NULL);-    if (!ecparameters)-        ABORT;-    group2 = EC_GROUP_new_from_ecparameters(ecparameters);-    if (!group2)-        ABORT;-    if (EC_GROUP_cmp(group, group2, NULL))-        ABORT;+    EC_GROUP *group = NULL, *group2 = NULL;+    ECPARAMETERS *ecparameters = NULL;+    int r;",
            "commit_date": "2017-04-28 14:06:11+10:00",
            "commit_hash": "2db85ac97a5dda90249f5e630e7b29c4196fc397",
            "message": "Conversion of the EC tests to use the framework.\nSome refactoring done as well.\nThe prime_field_tests() function needs splitting and refactoring still.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3340)"
        },
        {
            "author": {
                "email": "k@rhe.jp",
                "name": "Kazuki Yamaguchi"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1715,0 +1715,19 @@+static void parameter_test(void)+{+    EC_GROUP *group, *group2;+    ECPARAMETERS *ecparameters;++    fprintf(stderr, \"\\ntesting ecparameters conversion ...\");++    group = EC_GROUP_new_by_curve_name(NID_secp112r1);+    if (!group)+        ABORT;++    ecparameters = EC_GROUP_get_ecparameters(group, NULL);+    if (!ecparameters)+        ABORT;+    group2 = EC_GROUP_new_from_ecparameters(ecparameters);+    if (!group2)+        ABORT;+    if (EC_GROUP_cmp(group, group2, NULL))+        ABORT;",
            "commit_date": "2016-08-06 22:24:44+09:00",
            "commit_hash": "0110a4703608430c2131237c6afcf932a28c27ff",
            "message": "Fix a memory leak in EC_GROUP_get_ecparameters()\nThe variable 'buffer', allocated by EC_POINT_point2buf(), isn't\nfree'd on the success path.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>"
        }
    ],
    "git log -L327,336:test/params_test.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- /dev/null+++ b/test/params_test.c@@ -0,0 +239,10 @@++static int init_app_variables(void)+{+    int l = 0;++    cleanup_app_variables();++    app_p1 = app_p1_init;+    app_p2 = app_p2_init;+    if (!BN_hex2bn(&app_p3, app_p3_init)",
            "commit_date": "2019-03-04 17:22:45+01:00",
            "commit_hash": "9ad41d246f43d410ab4805e09786a88d56371908",
            "message": "test/params_test.c: Add \"real world\" parameter testing\ntest/params_test.c is a program that tries to mimic how a provider and\nan application would or could handle OSSL_PARAM arrays.\nFor the moment, this program tests a very raw way of handling\nOSSL_PARAM arrays.  It is, however, written in a way that will\nhopefully make it possible to extend with other methods as APIs arise,\nand to set up test cases where a \"provider\" handles the array one way\nwhile the \"application\" handles it another way.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)"
        }
    ],
    "git log -L72,115:test/ecdsatest.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -99,44 +99,44 @@  */ static int x9_62_tests(int n) {-#ifdef FIPS_MODE+#ifdef FIPS_MODULE-#endif /* FIPS_MODE */+#endif /* FIPS_MODULE */",
            "commit_date": "2020-04-13 22:34:56+02:00",
            "commit_hash": "f844f9eb44186df2f8b0cfd3264b4eb003d8c61a",
            "message": "Rename FIPS_MODE to FIPS_MODULE\nThis macro is used to determine if certain pieces of code should\nbecome part of the FIPS module or not.  The old name was confusing.\nFixes #11538\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/11539)\nint nid, md_nid, ret = 0;\nconst char *r_in = NULL, *s_in = NULL, *tbs = NULL;\nunsigned char *pbuf = NULL, *qbuf = NULL, *message = NULL;\nunsigned char digest[EVP_MAX_MD_SIZE];\nunsigned int dgst_len = 0;\nlong q_len, msg_len = 0;\nsize_t p_len;\nEVP_MD_CTX *mctx = NULL;\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;\nconst BIGNUM *sig_r = NULL, *sig_s = NULL;\nnid = ecdsa_cavs_kats[n].nid;\nmd_nid = ecdsa_cavs_kats[n].md_nid;\nr_in = ecdsa_cavs_kats[n].r;\ns_in = ecdsa_cavs_kats[n].s;\ntbs = ecdsa_cavs_kats[n].msg;\nnumbers[0] = ecdsa_cavs_kats[n].d;\nnumbers[1] = ecdsa_cavs_kats[n].k;\nTEST_info(\"ECDSA KATs for curve %s\", OBJ_nid2sn(nid));\nif (EC_curve_nid2nist(nid) == NULL)\nreturn TEST_skip(\"skip non approved curves\");\nif (!TEST_ptr(mctx = EVP_MD_CTX_new())\n/* get the message digest */\n|| !TEST_ptr(message = OPENSSL_hexstr2buf(tbs, &msg_len))\n|| !TEST_true(EVP_DigestInit_ex(mctx, EVP_get_digestbynid(md_nid), NULL))\n|| !TEST_true(EVP_DigestUpdate(mctx, message, msg_len))\n|| !TEST_true(EVP_DigestFinal_ex(mctx, digest, &dgst_len))\n/* create the key */\n|| !TEST_ptr(key = EC_KEY_new_by_curve_name(nid))\n/* load KAT variables */\n|| !TEST_ptr(r = BN_new())\n|| !TEST_ptr(s = BN_new())\n|| !TEST_true(BN_hex2bn(&r, r_in))"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -94,39 +94,44 @@  */ static int x9_62_tests(int n) {+#ifdef FIPS_MODE+    if (EC_curve_nid2nist(nid) == NULL)+        return TEST_skip(\"skip non approved curves\");+#endif /* FIPS_MODE */+",
            "commit_date": "2019-06-05 08:24:16+10:00",
            "commit_hash": "10c25644e362381844e0089504f0db42f029d855",
            "message": "EC only uses approved curves in FIPS mode.\nOnce there are buildable fips tests, some tests that are data driven\nfrom files will need to be modified to exclude non approved curves in\nfips mode.\nThese changes were tested by temporarily adding #define FIPS_MODE 1 to\nall the modified source files.\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/9081)\nint nid, md_nid, ret = 0;\nconst char *r_in = NULL, *s_in = NULL, *tbs = NULL;\nunsigned char *pbuf = NULL, *qbuf = NULL, *message = NULL;\nunsigned char digest[EVP_MAX_MD_SIZE];\nunsigned int dgst_len = 0;\nlong q_len, msg_len = 0;\nsize_t p_len;\nEVP_MD_CTX *mctx = NULL;\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;\nconst BIGNUM *sig_r = NULL, *sig_s = NULL;\nnid = ecdsa_cavs_kats[n].nid;\nmd_nid = ecdsa_cavs_kats[n].md_nid;\nr_in = ecdsa_cavs_kats[n].r;\ns_in = ecdsa_cavs_kats[n].s;\ntbs = ecdsa_cavs_kats[n].msg;\nnumbers[0] = ecdsa_cavs_kats[n].d;\nnumbers[1] = ecdsa_cavs_kats[n].k;\nTEST_info(\"ECDSA KATs for curve %s\", OBJ_nid2sn(nid));\nif (!TEST_ptr(mctx = EVP_MD_CTX_new())\n/* get the message digest */\n|| !TEST_ptr(message = OPENSSL_hexstr2buf(tbs, &msg_len))\n|| !TEST_true(EVP_DigestInit_ex(mctx, EVP_get_digestbynid(md_nid), NULL))\n|| !TEST_true(EVP_DigestUpdate(mctx, message, msg_len))\n|| !TEST_true(EVP_DigestFinal_ex(mctx, digest, &dgst_len))\n/* create the key */\n|| !TEST_ptr(key = EC_KEY_new_by_curve_name(nid))\n/* load KAT variables */\n|| !TEST_ptr(r = BN_new())\n|| !TEST_ptr(s = BN_new())\n|| !TEST_true(BN_hex2bn(&r, r_in))"
        },
        {
            "author": {
                "email": "bbrumley@gmail.com",
                "name": "Billy Brumley"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -102,28 +94,39 @@-/* some tests from the X9.62 draft */-static int x9_62_test_internal(int nid, const char *r_in, const char *s_in)+ */+static int x9_62_tests(int n) {-    int ret = 0;-    const char message[] = \"abc\";-    unsigned char digest[SHA_DIGEST_LENGTH];+    int nid, md_nid, ret = 0;+    const char *r_in = NULL, *s_in = NULL, *tbs = NULL;+    unsigned char *pbuf = NULL, *qbuf = NULL, *message = NULL;+    unsigned char digest[EVP_MAX_MD_SIZE];-    EVP_MD_CTX *md_ctx;+    long q_len, msg_len = 0;+    size_t p_len;+    EVP_MD_CTX *mctx = NULL;-    const BIGNUM *sig_r, *sig_s;--    if (!TEST_ptr(md_ctx = EVP_MD_CTX_new()))-        goto x962_int_err;--    /* get the message digest */-    if (!TEST_true(EVP_DigestInit(md_ctx, EVP_sha1()))-        || !TEST_true(EVP_DigestUpdate(md_ctx, (const void *)message, 3))-        || !TEST_true(EVP_DigestFinal(md_ctx, digest, &dgst_len)))-        goto x962_int_err;--    TEST_info(\"testing %s\", OBJ_nid2sn(nid));--    /* create the key */-    if (!TEST_ptr(key = EC_KEY_new_by_curve_name(nid)))-        goto x962_int_err;+    const BIGNUM *sig_r = NULL, *sig_s = NULL;++    nid = ecdsa_cavs_kats[n].nid;+    md_nid = ecdsa_cavs_kats[n].md_nid;+    r_in = ecdsa_cavs_kats[n].r;+    s_in = ecdsa_cavs_kats[n].s;+    tbs = ecdsa_cavs_kats[n].msg;+    numbers[0] = ecdsa_cavs_kats[n].d;+    numbers[1] = ecdsa_cavs_kats[n].k;++    TEST_info(\"ECDSA KATs for curve %s\", OBJ_nid2sn(nid));++    if (!TEST_ptr(mctx = EVP_MD_CTX_new())+        /* get the message digest */+        || !TEST_ptr(message = OPENSSL_hexstr2buf(tbs, &msg_len))+        || !TEST_true(EVP_DigestInit_ex(mctx, EVP_get_digestbynid(md_nid), NULL))+        || !TEST_true(EVP_DigestUpdate(mctx, message, msg_len))+        || !TEST_true(EVP_DigestFinal_ex(mctx, digest, &dgst_len))+        /* create the key */+        || !TEST_ptr(key = EC_KEY_new_by_curve_name(nid))+        /* load KAT variables */+        || !TEST_ptr(r = BN_new())+        || !TEST_ptr(s = BN_new())+        || !TEST_true(BN_hex2bn(&r, r_in))",
            "commit_date": "2019-02-23 10:12:35+02:00",
            "commit_hash": "1a31d8017ee7e8df0eca76fee601b826699c9ac1",
            "message": "[test] modernize ecdsatest and extend ECDSA sign KATs\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/8314)\nunsigned int dgst_len = 0;\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;"
        },
        {
            "author": {
                "email": "nb@cipher.kiev.ua",
                "name": "Mykola Baibuz"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -101,28 +101,28 @@ /* some tests from the X9.62 draft */ static int x9_62_test_internal(int nid, const char *r_in, const char *s_in) {-    unsigned char digest[20];+    unsigned char digest[SHA_DIGEST_LENGTH];",
            "commit_date": "2018-10-08 07:14:08+10:00",
            "commit_hash": "b770a80f6d0b08659cd03f26388b45512adb84f3",
            "message": "Remove useless check.\nHash can be longer than EC group degree and it will be truncated.\nCLA: trivial\nReviewed-by: Paul Yang <yang.yang@baishancloud.com>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/7329)\nint ret = 0;\nconst char message[] = \"abc\";\nunsigned int dgst_len = 0;\nEVP_MD_CTX *md_ctx;\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;\nconst BIGNUM *sig_r, *sig_s;\nif (!TEST_ptr(md_ctx = EVP_MD_CTX_new()))\ngoto x962_int_err;\n/* get the message digest */\nif (!TEST_true(EVP_DigestInit(md_ctx, EVP_sha1()))\n|| !TEST_true(EVP_DigestUpdate(md_ctx, (const void *)message, 3))\n|| !TEST_true(EVP_DigestFinal(md_ctx, digest, &dgst_len)))\ngoto x962_int_err;\nTEST_info(\"testing %s\", OBJ_nid2sn(nid));\n/* create the key */\nif (!TEST_ptr(key = EC_KEY_new_by_curve_name(nid)))\ngoto x962_int_err;"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -136,27 +125,28 @@ /* some tests from the X9.62 draft */-int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in)+static int x9_62_test_internal(int nid, const char *r_in, const char *s_in) {-    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();+    EVP_MD_CTX *md_ctx;-    if (md_ctx == NULL)+    if (!TEST_ptr(md_ctx = EVP_MD_CTX_new()))-    if (!EVP_DigestInit(md_ctx, EVP_sha1())-        || !EVP_DigestUpdate(md_ctx, (const void *)message, 3)-        || !EVP_DigestFinal(md_ctx, digest, &dgst_len))+    if (!TEST_true(EVP_DigestInit(md_ctx, EVP_sha1()))+        || !TEST_true(EVP_DigestUpdate(md_ctx, (const void *)message, 3))+        || !TEST_true(EVP_DigestFinal(md_ctx, digest, &dgst_len)))-    BIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid));+    TEST_info(\"testing %s\", OBJ_nid2sn(nid));+-    if ((key = EC_KEY_new_by_curve_name(nid)) == NULL)+    if (!TEST_ptr(key = EC_KEY_new_by_curve_name(nid)))",
            "commit_date": "2017-04-18 14:34:43-04:00",
            "commit_hash": "b66411f6cda6970c01283ddde6d8063c57b3b7d9",
            "message": "Convert more tests\nrecordlentest, srptest, ecdsatest, enginetest, pbelutest\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3237)\nint ret = 0;\nconst char message[] = \"abc\";\nunsigned char digest[20];\nunsigned int dgst_len = 0;\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;\nconst BIGNUM *sig_r, *sig_s;\ngoto x962_int_err;\n/* get the message digest */\ngoto x962_int_err;\n/* create the key */\ngoto x962_int_err;"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -136,27 +136,27 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) {-    BIGNUM *sig_r, *sig_s;+    const BIGNUM *sig_r, *sig_s;",
            "commit_date": "2016-06-09 23:09:48+02:00",
            "commit_hash": "9267c11bb5d408e43482173794f08a3c8472afba",
            "message": "Make DSA_SIG and ECDSA_SIG getters const.\nReorder arguments to follow convention.\nAlso allow r/s to be NULL in DSA_SIG_get0, similarly to ECDSA_SIG_get0.\nThis complements GH1193 which adds non-const setters.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nint ret = 0;\nconst char message[] = \"abc\";\nunsigned char digest[20];\nunsigned int dgst_len = 0;\nEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;\nif (md_ctx == NULL)\ngoto x962_int_err;\n/* get the message digest */\nif (!EVP_DigestInit(md_ctx, EVP_sha1())\n|| !EVP_DigestUpdate(md_ctx, (const void *)message, 3)\n|| !EVP_DigestFinal(md_ctx, digest, &dgst_len))\ngoto x962_int_err;\nBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid));\n/* create the key */\nif ((key = EC_KEY_new_by_curve_name(nid)) == NULL)\ngoto x962_int_err;"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -184,26 +184,27 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) {+    BIGNUM *sig_r, *sig_s;",
            "commit_date": "2015-10-27 18:51:37+00:00",
            "commit_hash": "cf70b8f5a6b35375dc00f9a661ad655c774440c5",
            "message": "modify ecdsatest to use accessor\nReviewed-by: Richard Levitte <levitte@openssl.org>\nint ret = 0;\nconst char message[] = \"abc\";\nunsigned char digest[20];\nunsigned int dgst_len = 0;\nEVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;\nif (md_ctx == NULL)\ngoto x962_int_err;\n/* get the message digest */\nif (!EVP_DigestInit(md_ctx, EVP_sha1())\n|| !EVP_DigestUpdate(md_ctx, (const void *)message, 3)\n|| !EVP_DigestFinal(md_ctx, digest, &dgst_len))\ngoto x962_int_err;\nBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid));\n/* create the key */\nif ((key = EC_KEY_new_by_curve_name(nid)) == NULL)\ngoto x962_int_err;"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -184,26 +184,26 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) {-    EVP_MD_CTX *md_ctx = EVP_MD_CTX_create();+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();",
            "commit_date": "2015-12-02 00:49:35+01:00",
            "commit_hash": "bfb0641f932490c2e7fb5f9f7cb4a88017a5abfa",
            "message": "Cleanup: fix all sources that used EVP_MD_CTX_(create|init|destroy)\nReviewed-by: Rich Salz <rsalz@openssl.org>\nint ret = 0;\nconst char message[] = \"abc\";\nunsigned char digest[20];\nunsigned int dgst_len = 0;\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;\nif (md_ctx == NULL)\ngoto x962_int_err;\n/* get the message digest */\nif (!EVP_DigestInit(md_ctx, EVP_sha1())\n|| !EVP_DigestUpdate(md_ctx, (const void *)message, 3)\n|| !EVP_DigestFinal(md_ctx, digest, &dgst_len))\ngoto x962_int_err;\nBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid));\n/* create the key */\nif ((key = EC_KEY_new_by_curve_name(nid)) == NULL)\ngoto x962_int_err;"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -184,24 +184,26 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) {-    EVP_MD_CTX md_ctx;+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_create();-    EVP_MD_CTX_init(&md_ctx);+    if (md_ctx == NULL)+        goto x962_int_err;+-    if (!EVP_DigestInit(&md_ctx, EVP_sha1())-        || !EVP_DigestUpdate(&md_ctx, (const void *)message, 3)-        || !EVP_DigestFinal(&md_ctx, digest, &dgst_len))+    if (!EVP_DigestInit(md_ctx, EVP_sha1())+        || !EVP_DigestUpdate(md_ctx, (const void *)message, 3)+        || !EVP_DigestFinal(md_ctx, digest, &dgst_len))",
            "commit_date": "2015-11-27 14:02:12+01:00",
            "commit_hash": "6e59a892db781658c050e5217127c4147c116ac9",
            "message": "Adjust all accesses to EVP_MD_CTX to use accessor functions.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nint ret = 0;\nconst char message[] = \"abc\";\nunsigned char digest[20];\nunsigned int dgst_len = 0;\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;\n/* get the message digest */\ngoto x962_int_err;\nBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid));\n/* create the key */\nif ((key = EC_KEY_new_by_curve_name(nid)) == NULL)\ngoto x962_int_err;"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/test/ecdsatest.c b/test/ecdsatest.c--- a/test/ecdsatest.c+++ b/test/ecdsatest.c@@ -184,24 +184,24 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) {-    if (!EVP_DigestInit(&md_ctx, EVP_ecdsa())+    if (!EVP_DigestInit(&md_ctx, EVP_sha1())",
            "commit_date": "2015-12-02 13:57:04+00:00",
            "commit_hash": "7f572e958b13041056f377a62d3219633cfb1e8a",
            "message": "Remove legacy sign/verify from EVP_MD.\nRemove sign/verify and required_pkey_type fields of EVP_MD: these are a\nlegacy from when digests were linked to public key types. All signing is\nnow handled by the corresponding EVP_PKEY_METHOD.\nOnly allow supported digest types in RSA EVP_PKEY_METHOD: other algorithms\nalready block unsupported types.\nRemove now obsolete EVP_dss1() and EVP_ecdsa().\nReviewed-by: Richard Levitte <levitte@openssl.org>\nint ret = 0;\nconst char message[] = \"abc\";\nunsigned char digest[20];\nunsigned int dgst_len = 0;\nEVP_MD_CTX md_ctx;\nEC_KEY *key = NULL;\nECDSA_SIG *signature = NULL;\nBIGNUM *r = NULL, *s = NULL;\nBIGNUM *kinv = NULL, *rp = NULL;\nEVP_MD_CTX_init(&md_ctx);\n/* get the message digest */\n|| !EVP_DigestUpdate(&md_ctx, (const void *)message, 3)\n|| !EVP_DigestFinal(&md_ctx, digest, &dgst_len))\ngoto x962_int_err;\nBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid));\n/* create the key */\nif ((key = EC_KEY_new_by_curve_name(nid)) == NULL)\ngoto x962_int_err;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ecdsa/ecdsatest.c b/crypto/ecdsa/ecdsatest.c--- a/crypto/ecdsa/ecdsatest.c+++ b/crypto/ecdsa/ecdsatest.c@@ -184,75 +184,24 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in)-\t{-\tint\tret = 0;-\tconst char message[] = \"abc\";-\tunsigned char digest[20];-\tunsigned int  dgst_len = 0;-\tEVP_MD_CTX md_ctx;-\tEC_KEY    *key = NULL;-\tECDSA_SIG *signature = NULL;-\tBIGNUM    *r = NULL, *s = NULL;-\tBIGNUM    *kinv = NULL, *rp = NULL;--\tEVP_MD_CTX_init(&md_ctx);-\t/* get the message digest */-\tif (!EVP_DigestInit(&md_ctx, EVP_ecdsa())-\t    || !EVP_DigestUpdate(&md_ctx, (const void*)message, 3)-\t    || !EVP_DigestFinal(&md_ctx, digest, &dgst_len))-\t\tgoto x962_int_err;--\tBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid));-\t/* create the key */-\tif ((key = EC_KEY_new_by_curve_name(nid)) == NULL)-\t\tgoto x962_int_err;-\tuse_fake = 1;-\tif (!EC_KEY_generate_key(key))-\t\tgoto x962_int_err;-\tBIO_printf(out, \".\");-\t(void)BIO_flush(out);-\t/* create the signature */-\tuse_fake = 1;-\t/* Use ECDSA_sign_setup to avoid use of ECDSA nonces */-\tif (!ECDSA_sign_setup(key, NULL, &kinv, &rp))-\t\tgoto x962_int_err;-\tsignature = ECDSA_do_sign_ex(digest, 20, kinv, rp, key);-\tif (signature == NULL)-\t\tgoto x962_int_err;-\tBIO_printf(out, \".\");-\t(void)BIO_flush(out);-\t/* compare the created signature with the expected signature */-\tif ((r = BN_new()) == NULL || (s = BN_new()) == NULL)-\t\tgoto x962_int_err;-\tif (!BN_dec2bn(&r, r_in) ||-\t    !BN_dec2bn(&s, s_in))-\t\tgoto x962_int_err;-\tif (BN_cmp(signature->r ,r) || BN_cmp(signature->s, s))-\t\tgoto x962_int_err;-\tBIO_printf(out, \".\");-\t(void)BIO_flush(out);-\t/* verify the signature */-\tif (ECDSA_do_verify(digest, 20, signature, key) != 1)-\t\tgoto x962_int_err;-\tBIO_printf(out, \".\");-\t(void)BIO_flush(out);--\tBIO_printf(out, \" ok\\n\");-\tret = 1;-x962_int_err:-\tif (!ret)-\t\tBIO_printf(out, \" failed\\n\");-\tif (key)-\t\tEC_KEY_free(key);-\tif (signature)-\t\tECDSA_SIG_free(signature);-\tif (r)-\t\tBN_free(r);-\tif (s)-\t\tBN_free(s);-\tEVP_MD_CTX_cleanup(&md_ctx);-\tif (kinv)-\t\tBN_clear_free(kinv);-\tif (rp)-\t\tBN_clear_free(rp);-\treturn ret;-\t}+{+    int ret = 0;+    const char message[] = \"abc\";+    unsigned char digest[20];+    unsigned int dgst_len = 0;+    EVP_MD_CTX md_ctx;+    EC_KEY *key = NULL;+    ECDSA_SIG *signature = NULL;+    BIGNUM *r = NULL, *s = NULL;+    BIGNUM *kinv = NULL, *rp = NULL;++    EVP_MD_CTX_init(&md_ctx);+    /* get the message digest */+    if (!EVP_DigestInit(&md_ctx, EVP_ecdsa())+        || !EVP_DigestUpdate(&md_ctx, (const void *)message, 3)+        || !EVP_DigestFinal(&md_ctx, digest, &dgst_len))+        goto x962_int_err;++    BIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid));+    /* create the key */+    if ((key = EC_KEY_new_by_curve_name(nid)) == NULL)+        goto x962_int_err;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/ecdsa/ecdsatest.c b/crypto/ecdsa/ecdsatest.c--- a/crypto/ecdsa/ecdsatest.c+++ b/crypto/ecdsa/ecdsatest.c@@ -185,67 +185,75 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) \t{ \tint\tret = 0; \tconst char message[] = \"abc\"; \tunsigned char digest[20]; \tunsigned int  dgst_len = 0; \tEVP_MD_CTX md_ctx; \tEC_KEY    *key = NULL; \tECDSA_SIG *signature = NULL; \tBIGNUM    *r = NULL, *s = NULL;+\tBIGNUM    *kinv = NULL, *rp = NULL; \tEVP_MD_CTX_init(&md_ctx); \t/* get the message digest */ \tif (!EVP_DigestInit(&md_ctx, EVP_ecdsa()) \t    || !EVP_DigestUpdate(&md_ctx, (const void*)message, 3) \t    || !EVP_DigestFinal(&md_ctx, digest, &dgst_len)) \t\tgoto x962_int_err; \tBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid)); \t/* create the key */ \tif ((key = EC_KEY_new_by_curve_name(nid)) == NULL) \t\tgoto x962_int_err; \tuse_fake = 1; \tif (!EC_KEY_generate_key(key)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \t/* create the signature */ \tuse_fake = 1;-\tsignature = ECDSA_do_sign(digest, 20, key);+\t/* Use ECDSA_sign_setup to avoid use of ECDSA nonces */+\tif (!ECDSA_sign_setup(key, NULL, &kinv, &rp))+\t\tgoto x962_int_err;+\tsignature = ECDSA_do_sign_ex(digest, 20, kinv, rp, key); \tif (signature == NULL) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \t/* compare the created signature with the expected signature */ \tif ((r = BN_new()) == NULL || (s = BN_new()) == NULL) \t\tgoto x962_int_err; \tif (!BN_dec2bn(&r, r_in) || \t    !BN_dec2bn(&s, s_in)) \t\tgoto x962_int_err; \tif (BN_cmp(signature->r ,r) || BN_cmp(signature->s, s)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \t/* verify the signature */ \tif (ECDSA_do_verify(digest, 20, signature, key) != 1) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \tBIO_printf(out, \" ok\\n\"); \tret = 1; x962_int_err: \tif (!ret) \t\tBIO_printf(out, \" failed\\n\"); \tif (key) \t\tEC_KEY_free(key); \tif (signature) \t\tECDSA_SIG_free(signature); \tif (r) \t\tBN_free(r); \tif (s) \t\tBN_free(s); \tEVP_MD_CTX_cleanup(&md_ctx);+\tif (kinv)+\t\tBN_clear_free(kinv);+\tif (rp)+\t\tBN_clear_free(rp); \treturn ret; \t}",
            "commit_date": "2013-07-19 14:11:43+01:00",
            "commit_hash": "584ac22110b2ff367d3632a89cf7b15c015903b8",
            "message": "Make ecdsatest work with nonces.\nUpdate ecdsatest to use ECDSA_sign_setup and ECDSA_sign_ex, this\navoids the nonce generation which would otherwise break the test.\nReinstate ecdsatest."
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/ecdsa/ecdsatest.c b/crypto/ecdsa/ecdsatest.c--- a/crypto/ecdsa/ecdsatest.c+++ b/crypto/ecdsa/ecdsatest.c@@ -185,66 +185,67 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) \t{ \tint\tret = 0; \tconst char message[] = \"abc\"; \tunsigned char digest[20]; \tunsigned int  dgst_len = 0; \tEVP_MD_CTX md_ctx; \tEC_KEY    *key = NULL; \tECDSA_SIG *signature = NULL; \tBIGNUM    *r = NULL, *s = NULL; \tEVP_MD_CTX_init(&md_ctx); \t/* get the message digest */-\tEVP_DigestInit(&md_ctx, EVP_ecdsa());-\tEVP_DigestUpdate(&md_ctx, (const void*)message, 3);-\tEVP_DigestFinal(&md_ctx, digest, &dgst_len);+\tif (!EVP_DigestInit(&md_ctx, EVP_ecdsa())+\t    || !EVP_DigestUpdate(&md_ctx, (const void*)message, 3)+\t    || !EVP_DigestFinal(&md_ctx, digest, &dgst_len))+\t\tgoto x962_int_err; \tBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid)); \t/* create the key */ \tif ((key = EC_KEY_new_by_curve_name(nid)) == NULL) \t\tgoto x962_int_err; \tuse_fake = 1; \tif (!EC_KEY_generate_key(key)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \t/* create the signature */ \tuse_fake = 1; \tsignature = ECDSA_do_sign(digest, 20, key); \tif (signature == NULL) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \t/* compare the created signature with the expected signature */ \tif ((r = BN_new()) == NULL || (s = BN_new()) == NULL) \t\tgoto x962_int_err; \tif (!BN_dec2bn(&r, r_in) || \t    !BN_dec2bn(&s, s_in)) \t\tgoto x962_int_err; \tif (BN_cmp(signature->r ,r) || BN_cmp(signature->s, s)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \t/* verify the signature */ \tif (ECDSA_do_verify(digest, 20, signature, key) != 1) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \tBIO_printf(out, \" ok\\n\"); \tret = 1; x962_int_err: \tif (!ret) \t\tBIO_printf(out, \" failed\\n\"); \tif (key) \t\tEC_KEY_free(key); \tif (signature) \t\tECDSA_SIG_free(signature); \tif (r) \t\tBN_free(r); \tif (s) \t\tBN_free(s); \tEVP_MD_CTX_cleanup(&md_ctx); \treturn ret; \t}",
            "commit_date": "2011-11-14 00:36:10+00:00",
            "commit_hash": "ae551760917614647ad6fbacec6e4c1b495a94cf",
            "message": "Fix some warnings caused by __owur. Temporarily (I hope) remove the more\naspirational __owur annotations."
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/ecdsa/ecdsatest.c b/crypto/ecdsa/ecdsatest.c--- a/crypto/ecdsa/ecdsatest.c+++ b/crypto/ecdsa/ecdsatest.c@@ -180,64 +185,66 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) \t{ \tint\tret = 0; \tconst char message[] = \"abc\"; \tunsigned char digest[20]; \tunsigned int  dgst_len = 0; \tEVP_MD_CTX md_ctx; \tEC_KEY    *key = NULL; \tECDSA_SIG *signature = NULL; \tBIGNUM    *r = NULL, *s = NULL; \tEVP_MD_CTX_init(&md_ctx); \t/* get the message digest */ \tEVP_DigestInit(&md_ctx, EVP_ecdsa()); \tEVP_DigestUpdate(&md_ctx, (const void*)message, 3); \tEVP_DigestFinal(&md_ctx, digest, &dgst_len); \tBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid)); \t/* create the key */ \tif ((key = EC_KEY_new_by_curve_name(nid)) == NULL) \t\tgoto x962_int_err;+\tuse_fake = 1; \tif (!EC_KEY_generate_key(key)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \t/* create the signature */+\tuse_fake = 1; \tsignature = ECDSA_do_sign(digest, 20, key); \tif (signature == NULL) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \t/* compare the created signature with the expected signature */ \tif ((r = BN_new()) == NULL || (s = BN_new()) == NULL) \t\tgoto x962_int_err; \tif (!BN_dec2bn(&r, r_in) || \t    !BN_dec2bn(&s, s_in)) \t\tgoto x962_int_err; \tif (BN_cmp(signature->r ,r) || BN_cmp(signature->s, s)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \t/* verify the signature */ \tif (ECDSA_do_verify(digest, 20, signature, key) != 1) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \t(void)BIO_flush(out); \tBIO_printf(out, \" ok\\n\"); \tret = 1; x962_int_err: \tif (!ret) \t\tBIO_printf(out, \" failed\\n\"); \tif (key) \t\tEC_KEY_free(key); \tif (signature) \t\tECDSA_SIG_free(signature); \tif (r) \t\tBN_free(r); \tif (s) \t\tBN_free(s); \tEVP_MD_CTX_cleanup(&md_ctx); \treturn ret; \t}",
            "commit_date": "2011-04-06 23:42:55+00:00",
            "commit_hash": "d80399a3571e58a2c96da68c4fc6c95fb555902e",
            "message": "Only use fake rand once per operation. This stops the EC\npairwise consistency test interfering with the test."
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/ecdsa/ecdsatest.c b/crypto/ecdsa/ecdsatest.c--- a/crypto/ecdsa/ecdsatest.c+++ b/crypto/ecdsa/ecdsatest.c@@ -181,64 +181,64 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) \t{ \tint\tret = 0; \tconst char message[] = \"abc\"; \tunsigned char digest[20]; \tunsigned int  dgst_len = 0; \tEVP_MD_CTX md_ctx; \tEC_KEY    *key = NULL; \tECDSA_SIG *signature = NULL; \tBIGNUM    *r = NULL, *s = NULL; \tEVP_MD_CTX_init(&md_ctx); \t/* get the message digest */ \tEVP_DigestInit(&md_ctx, EVP_ecdsa()); \tEVP_DigestUpdate(&md_ctx, (const void*)message, 3); \tEVP_DigestFinal(&md_ctx, digest, &dgst_len); \tBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid)); \t/* create the key */ \tif ((key = EC_KEY_new_by_curve_name(nid)) == NULL) \t\tgoto x962_int_err; \tif (!EC_KEY_generate_key(key)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\");-\tBIO_flush(out);+\t(void)BIO_flush(out); \t/* create the signature */ \tsignature = ECDSA_do_sign(digest, 20, key); \tif (signature == NULL) \t\tgoto x962_int_err; \tBIO_printf(out, \".\");-\tBIO_flush(out);+\t(void)BIO_flush(out); \t/* compare the created signature with the expected signature */ \tif ((r = BN_new()) == NULL || (s = BN_new()) == NULL) \t\tgoto x962_int_err; \tif (!BN_dec2bn(&r, r_in) || \t    !BN_dec2bn(&s, s_in)) \t\tgoto x962_int_err; \tif (BN_cmp(signature->r ,r) || BN_cmp(signature->s, s)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\");-\tBIO_flush(out);+\t(void)BIO_flush(out); \t/* verify the signature */ \tif (ECDSA_do_verify(digest, 20, signature, key) != 1) \t\tgoto x962_int_err; \tBIO_printf(out, \".\");-\tBIO_flush(out);+\t(void)BIO_flush(out); \tBIO_printf(out, \" ok\\n\"); \tret = 1; x962_int_err: \tif (!ret) \t\tBIO_printf(out, \" failed\\n\"); \tif (key) \t\tEC_KEY_free(key); \tif (signature) \t\tECDSA_SIG_free(signature); \tif (r) \t\tBN_free(r); \tif (s) \t\tBN_free(s); \tEVP_MD_CTX_cleanup(&md_ctx); \treturn ret; \t}",
            "commit_date": "2007-08-12 17:44:32+00:00",
            "commit_hash": "710069c19ee1795dfd614a4ba683d07e1b8e6f81",
            "message": "Fix warnings."
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/ecdsa/ecdsatest.c b/crypto/ecdsa/ecdsatest.c--- a/crypto/ecdsa/ecdsatest.c+++ b/crypto/ecdsa/ecdsatest.c@@ -184,66 +184,64 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) \t{ \tint\tret = 0; \tconst char message[] = \"abc\"; \tunsigned char digest[20]; \tunsigned int  dgst_len = 0; \tEVP_MD_CTX md_ctx; \tEC_KEY    *key = NULL; \tECDSA_SIG *signature = NULL; \tBIGNUM    *r = NULL, *s = NULL; \tEVP_MD_CTX_init(&md_ctx); \t/* get the message digest */ \tEVP_DigestInit(&md_ctx, EVP_ecdsa()); \tEVP_DigestUpdate(&md_ctx, (const void*)message, 3); \tEVP_DigestFinal(&md_ctx, digest, &dgst_len); \tBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid)); \t/* create the key */-\tif ((key = EC_KEY_new()) == NULL)-\t\tgoto x962_int_err;-\tif ((key->group = EC_GROUP_new_by_curve_name(nid)) == NULL)+\tif ((key = EC_KEY_new_by_curve_name(nid)) == NULL) \t\tgoto x962_int_err; \tif (!EC_KEY_generate_key(key)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \tBIO_flush(out); \t/* create the signature */ \tsignature = ECDSA_do_sign(digest, 20, key); \tif (signature == NULL) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \tBIO_flush(out); \t/* compare the created signature with the expected signature */ \tif ((r = BN_new()) == NULL || (s = BN_new()) == NULL) \t\tgoto x962_int_err; \tif (!BN_dec2bn(&r, r_in) || \t    !BN_dec2bn(&s, s_in)) \t\tgoto x962_int_err; \tif (BN_cmp(signature->r ,r) || BN_cmp(signature->s, s)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \tBIO_flush(out); \t/* verify the signature */ \tif (ECDSA_do_verify(digest, 20, signature, key) != 1) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \tBIO_flush(out); \tBIO_printf(out, \" ok\\n\"); \tret = 1; x962_int_err: \tif (!ret) \t\tBIO_printf(out, \" failed\\n\"); \tif (key) \t\tEC_KEY_free(key); \tif (signature) \t\tECDSA_SIG_free(signature); \tif (r) \t\tBN_free(r); \tif (s) \t\tBN_free(s); \tEVP_MD_CTX_cleanup(&md_ctx); \treturn ret; \t}",
            "commit_date": "2005-05-16 10:11:04+00:00",
            "commit_hash": "9dd84053419aa220b5e66a5f9fcf809dbd6d9369",
            "message": "ecc api cleanup; summary:\n- hide the EC_KEY structure definition in ec_lcl.c + add\nsome functions to use/access the EC_KEY fields\n- change the way how method specific data (ecdsa/ecdh) is\nattached to a EC_KEY\n- add ECDSA_sign_ex and ECDSA_do_sign_ex functions with\nadditional parameters for pre-computed values\n- rebuild libeay.num from 0.9.7"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/ecdsa/ecdsatest.c b/crypto/ecdsa/ecdsatest.c--- a/crypto/ecdsa/ecdsatest.c+++ b/crypto/ecdsa/ecdsatest.c@@ -184,66 +184,66 @@ /* some tests from the X9.62 draft */ int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) \t{ \tint\tret = 0; \tconst char message[] = \"abc\"; \tunsigned char digest[20]; \tunsigned int  dgst_len = 0; \tEVP_MD_CTX md_ctx; \tEC_KEY    *key = NULL; \tECDSA_SIG *signature = NULL; \tBIGNUM    *r = NULL, *s = NULL; \tEVP_MD_CTX_init(&md_ctx); \t/* get the message digest */ \tEVP_DigestInit(&md_ctx, EVP_ecdsa()); \tEVP_DigestUpdate(&md_ctx, (const void*)message, 3); \tEVP_DigestFinal(&md_ctx, digest, &dgst_len); \tBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid)); \t/* create the key */ \tif ((key = EC_KEY_new()) == NULL) \t\tgoto x962_int_err;-\tif ((key->group = EC_GROUP_new_by_nid(nid)) == NULL)+\tif ((key->group = EC_GROUP_new_by_curve_name(nid)) == NULL) \t\tgoto x962_int_err; \tif (!EC_KEY_generate_key(key)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \tBIO_flush(out); \t/* create the signature */ \tsignature = ECDSA_do_sign(digest, 20, key); \tif (signature == NULL) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \tBIO_flush(out); \t/* compare the created signature with the expected signature */ \tif ((r = BN_new()) == NULL || (s = BN_new()) == NULL) \t\tgoto x962_int_err; \tif (!BN_dec2bn(&r, r_in) || \t    !BN_dec2bn(&s, s_in)) \t\tgoto x962_int_err; \tif (BN_cmp(signature->r ,r) || BN_cmp(signature->s, s)) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \tBIO_flush(out); \t/* verify the signature */ \tif (ECDSA_do_verify(digest, 20, signature, key) != 1) \t\tgoto x962_int_err; \tBIO_printf(out, \".\"); \tBIO_flush(out); \tBIO_printf(out, \" ok\\n\"); \tret = 1; x962_int_err: \tif (!ret) \t\tBIO_printf(out, \" failed\\n\"); \tif (key) \t\tEC_KEY_free(key); \tif (signature) \t\tECDSA_SIG_free(signature); \tif (r) \t\tBN_free(r); \tif (s) \t\tBN_free(s); \tEVP_MD_CTX_cleanup(&md_ctx); \treturn ret; \t}",
            "commit_date": "2005-05-10 11:37:47+00:00",
            "commit_hash": "8b15c740180725e3e1e71ff619151840cdec46a5",
            "message": "give EC_GROUP_new_by_nid a more meanigful name:\nEC_GROUP_new_by_nid -> EC_GROUP_new_by_curve_name"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ecdsa/ecdsatest.c b/crypto/ecdsa/ecdsatest.c--- a/crypto/ecdsa/ecdsatest.c+++ b/crypto/ecdsa/ecdsatest.c@@ -151,5 +175,66 @@-\tif ((ecdsa->pub_key = EC_POINT_new(ecdsa->group)) == NULL)+/* some tests from the X9.62 draft */+int x9_62_test_internal(BIO *out, int nid, const char *r_in, const char *s_in) \t{-\t\tBIO_printf(bio_err,\"EC_POINT_new failed \\n\");-\t\tgoto err;+\tint\tret = 0;+\tconst char message[] = \"abc\";+\tunsigned char digest[20];+\tunsigned int  dgst_len = 0;+\tEVP_MD_CTX md_ctx;+\tEC_KEY    *key = NULL;+\tECDSA_SIG *signature = NULL;+\tBIGNUM    *r = NULL, *s = NULL;++\tEVP_MD_CTX_init(&md_ctx);+\t/* get the message digest */+\tEVP_DigestInit(&md_ctx, EVP_ecdsa());+\tEVP_DigestUpdate(&md_ctx, (const void*)message, 3);+\tEVP_DigestFinal(&md_ctx, digest, &dgst_len);++\tBIO_printf(out, \"testing %s: \", OBJ_nid2sn(nid));+\t/* create the key */+\tif ((key = EC_KEY_new()) == NULL)+\t\tgoto x962_int_err;+\tif ((key->group = EC_GROUP_new_by_nid(nid)) == NULL)+\t\tgoto x962_int_err;+\tif (!EC_KEY_generate_key(key))+\t\tgoto x962_int_err;+\tBIO_printf(out, \".\");+\tBIO_flush(out);+\t/* create the signature */+\tsignature = ECDSA_do_sign(digest, 20, key);+\tif (signature == NULL)+\t\tgoto x962_int_err;+\tBIO_printf(out, \".\");+\tBIO_flush(out);+\t/* compare the created signature with the expected signature */+\tif ((r = BN_new()) == NULL || (s = BN_new()) == NULL)+\t\tgoto x962_int_err;+\tif (!BN_dec2bn(&r, r_in) ||+\t    !BN_dec2bn(&s, s_in))+\t\tgoto x962_int_err;+\tif (BN_cmp(signature->r ,r) || BN_cmp(signature->s, s))+\t\tgoto x962_int_err;+\tBIO_printf(out, \".\");+\tBIO_flush(out);+\t/* verify the signature */+\tif (ECDSA_do_verify(digest, 20, signature, key) != 1)+\t\tgoto x962_int_err;+\tBIO_printf(out, \".\");+\tBIO_flush(out);++\tBIO_printf(out, \" ok\\n\");+\tret = 1;+x962_int_err:+\tif (!ret)+\t\tBIO_printf(out, \" failed\\n\");+\tif (key)+\t\tEC_KEY_free(key);+\tif (signature)+\t\tECDSA_SIG_free(signature);+\tif (r)+\t\tBN_free(r);+\tif (s)+\t\tBN_free(s);+\tEVP_MD_CTX_cleanup(&md_ctx);+\treturn ret; \t}",
            "commit_date": "2002-12-04 17:38:40+00:00",
            "commit_hash": "2b32b2819187564e450539f94d5ae9716a11c757",
            "message": "Don't compute timings here, we can do this elsewhere.\nInclude X9.62 signature examples.\nSubmitted by: Nils Larsch"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ecdsa/ecdsatest.c b/crypto/ecdsa/ecdsatest.c--- /dev/null+++ b/crypto/ecdsa/ecdsatest.c@@ -0,0 +127,5 @@+\tif ((ecdsa->pub_key = EC_POINT_new(ecdsa->group)) == NULL)+\t{+\t\tBIO_printf(bio_err,\"EC_POINT_new failed \\n\");+\t\tgoto err;+\t}",
            "commit_date": "2002-02-13 18:21:51+00:00",
            "commit_hash": "4d94ae00d5614d64d4dd065860c4b00161a81f82",
            "message": "ECDSA support\nSubmitted by: Nils Larsch <nla@trustcenter.de>"
        }
    ],
    "git log -L313,473:apps/passwd.c": [
        {
            "author": {
                "email": "jlu.hpw@foxmail.com",
                "name": "Peiwei Hu"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -313,161 +313,161 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) { #ifdef CHARSET_EBCDIC #endif #ifdef CHARSET_EBCDIC #endif #ifdef CHARSET_EBCDIC #endif-        return NULL;+        goto err; # ifndef PEDANTIC              /* Unfortunately, this generates a \"no # endif",
            "commit_date": "2022-01-04 09:10:32+08:00",
            "commit_hash": "ea4d16bc60dee53feb71997c1e78379eeb69b7ac",
            "message": "apps/passwd.c: free before error exiting\nuse goto instead of returning directly while error handling\nSigned-off-by: Peiwei Hu <jlu.hpw@foxmail.com>\nReviewed-by: Ben Kaduk <kaduk@mit.edu>\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/17404)\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar ascii_magic[5];         /* \"apr1\" plus '\\0' */\nchar ascii_salt[9];          /* Max 8 chars plus '\\0' */\nchar *ascii_passwd = NULL;\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md = NULL, *md2 = NULL;\nsize_t passwd_len, salt_len, magic_len;\npasswd_len = strlen(passwd);\nout_buf[0] = 0;\nmagic_len = strlen(magic);\nOPENSSL_strlcpy(ascii_magic, magic, sizeof(ascii_magic));\nif ((magic[0] & 0x80) != 0)    /* High bit is 1 in EBCDIC alnums */\nebcdic2ascii(ascii_magic, ascii_magic, magic_len);\n/* The salt gets truncated to 8 chars */\nOPENSSL_strlcpy(ascii_salt, salt, sizeof(ascii_salt));\nsalt_len = strlen(ascii_salt);\nebcdic2ascii(ascii_salt, ascii_salt, salt_len);\nascii_passwd = OPENSSL_strdup(passwd);\nif (ascii_passwd == NULL)\nreturn NULL;\nebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);\npasswd = ascii_passwd;\nif (magic_len > 0) {\nOPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));\nif (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */\ngoto err;\nOPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));\nOPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));\n}\nOPENSSL_strlcat(out_buf, ascii_salt, sizeof(out_buf));\nif (strlen(out_buf) > 6 + 8) /* assert \"$apr1$..salt..\" */\ngoto err;\nsalt_out = out_buf;\nif (magic_len > 0)\nsalt_out += 2 + magic_len;\nif (salt_len > 8)\ngoto err;\nmd = EVP_MD_CTX_new();\nif (md == NULL\n|| !EVP_DigestInit_ex(md, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md, passwd, passwd_len))\ngoto err;\nif (magic_len > 0)\nif (!EVP_DigestUpdate(md, ascii_dollar, 1)\n|| !EVP_DigestUpdate(md, ascii_magic, magic_len)\n|| !EVP_DigestUpdate(md, ascii_dollar, 1))\ngoto err;\nif (!EVP_DigestUpdate(md, ascii_salt, salt_len))\ngoto err;\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL\n|| !EVP_DigestInit_ex(md2, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestUpdate(md2, ascii_salt, salt_len)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\nfor (i = passwd_len; i > sizeof(buf); i -= sizeof(buf)) {\nif (!EVP_DigestUpdate(md, buf, sizeof(buf)))\ngoto err;\n}\nif (!EVP_DigestUpdate(md, buf, i))\ngoto err;\nn = passwd_len;\nwhile (n) {\nif (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))\ngoto err;\nn >>= 1;\n}\nif (!EVP_DigestFinal_ex(md, buf, NULL))\nfor (i = 0; i < 1000; i++) {\nif (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))\ngoto err;\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? (const unsigned char *)passwd : buf,\n(i & 1) ? passwd_len : sizeof(buf)))\ngoto err;\nif (i % 3) {\nif (!EVP_DigestUpdate(md2, ascii_salt, salt_len))\ngoto err;\n}\nif (i % 7) {\nif (!EVP_DigestUpdate(md2, passwd, passwd_len))\ngoto err;\n}\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? buf : (const unsigned char *)passwd,\n(i & 1) ? sizeof(buf) : passwd_len))\ngoto err;\nif (!EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\nmd2 = NULL;\nmd = NULL;\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof(buf)];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof(buf_perm));\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = ascii_dollar[0];\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "thomas.de_schampheleire@nokia.com",
                "name": "Thomas De Schampheleire"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -310,161 +310,161 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) { #ifdef CHARSET_EBCDIC #endif #ifdef CHARSET_EBCDIC #endif #ifdef CHARSET_EBCDIC #endif-                              (i & 1) ? (unsigned const char *)passwd : buf,+                              (i & 1) ? (const unsigned char *)passwd : buf,-                              (i & 1) ? buf : (unsigned const char *)passwd,+                              (i & 1) ? buf : (const unsigned char *)passwd, # ifndef PEDANTIC              /* Unfortunately, this generates a \"no # endif",
            "commit_date": "2020-12-21 15:17:24+01:00",
            "commit_hash": "6d4313f03eddd39ca8d06a5e1d20fc1adcb207c5",
            "message": "replace 'unsigned const char' with 'const unsigned char'\nThe openssl code base has only a few occurrences of 'unsigned const char'\n(15 occurrences), compared to the more common 'const unsigned char' (4420\noccurrences).\nWhile the former is not illegal C, mixing the 'const' keyword (a 'type\nqualifier') in between 'unsigned' and 'char' (both 'type specifiers') is a\nbit odd.\nThe background for writing this patch is not to be pedantic, but because\nthe 'opmock' program (used to mock headers for unit tests) does not accept\nthe 'unsigned const char' construct. While this definitely is a bug in\nopmock or one of its dependencies, openssl is the only piece of software we\nare using in combination with opmock that has this construct.\nCLA: trivial\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>\n(Merged from https://github.com/openssl/openssl/pull/13722)\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar ascii_magic[5];         /* \"apr1\" plus '\\0' */\nchar ascii_salt[9];          /* Max 8 chars plus '\\0' */\nchar *ascii_passwd = NULL;\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md = NULL, *md2 = NULL;\nsize_t passwd_len, salt_len, magic_len;\npasswd_len = strlen(passwd);\nout_buf[0] = 0;\nmagic_len = strlen(magic);\nOPENSSL_strlcpy(ascii_magic, magic, sizeof(ascii_magic));\nif ((magic[0] & 0x80) != 0)    /* High bit is 1 in EBCDIC alnums */\nebcdic2ascii(ascii_magic, ascii_magic, magic_len);\n/* The salt gets truncated to 8 chars */\nOPENSSL_strlcpy(ascii_salt, salt, sizeof(ascii_salt));\nsalt_len = strlen(ascii_salt);\nebcdic2ascii(ascii_salt, ascii_salt, salt_len);\nascii_passwd = OPENSSL_strdup(passwd);\nif (ascii_passwd == NULL)\nreturn NULL;\nebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);\npasswd = ascii_passwd;\nif (magic_len > 0) {\nOPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));\nif (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */\ngoto err;\nOPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));\nOPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));\n}\nOPENSSL_strlcat(out_buf, ascii_salt, sizeof(out_buf));\nif (strlen(out_buf) > 6 + 8) /* assert \"$apr1$..salt..\" */\ngoto err;\nsalt_out = out_buf;\nif (magic_len > 0)\nsalt_out += 2 + magic_len;\nif (salt_len > 8)\ngoto err;\nmd = EVP_MD_CTX_new();\nif (md == NULL\n|| !EVP_DigestInit_ex(md, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md, passwd, passwd_len))\ngoto err;\nif (magic_len > 0)\nif (!EVP_DigestUpdate(md, ascii_dollar, 1)\n|| !EVP_DigestUpdate(md, ascii_magic, magic_len)\n|| !EVP_DigestUpdate(md, ascii_dollar, 1))\ngoto err;\nif (!EVP_DigestUpdate(md, ascii_salt, salt_len))\ngoto err;\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL\n|| !EVP_DigestInit_ex(md2, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestUpdate(md2, ascii_salt, salt_len)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\nfor (i = passwd_len; i > sizeof(buf); i -= sizeof(buf)) {\nif (!EVP_DigestUpdate(md, buf, sizeof(buf)))\ngoto err;\n}\nif (!EVP_DigestUpdate(md, buf, i))\ngoto err;\nn = passwd_len;\nwhile (n) {\nif (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))\ngoto err;\nn >>= 1;\n}\nif (!EVP_DigestFinal_ex(md, buf, NULL))\nreturn NULL;\nfor (i = 0; i < 1000; i++) {\nif (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))\ngoto err;\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? passwd_len : sizeof(buf)))\ngoto err;\nif (i % 3) {\nif (!EVP_DigestUpdate(md2, ascii_salt, salt_len))\ngoto err;\n}\nif (i % 7) {\nif (!EVP_DigestUpdate(md2, passwd, passwd_len))\ngoto err;\n}\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? sizeof(buf) : passwd_len))\ngoto err;\nif (!EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\nmd2 = NULL;\nmd = NULL;\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof(buf)];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof(buf_perm));\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = ascii_dollar[0];\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -309,161 +309,161 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {-    OPENSSL_strlcpy(ascii_magic, magic, sizeof ascii_magic);+    OPENSSL_strlcpy(ascii_magic, magic, sizeof(ascii_magic)); #ifdef CHARSET_EBCDIC #endif-    OPENSSL_strlcpy(ascii_salt, salt, sizeof ascii_salt);+    OPENSSL_strlcpy(ascii_salt, salt, sizeof(ascii_salt)); #ifdef CHARSET_EBCDIC #endif #ifdef CHARSET_EBCDIC #endif-        OPENSSL_strlcat(out_buf, ascii_dollar, sizeof out_buf);+        OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));-        OPENSSL_strlcat(out_buf, ascii_magic, sizeof out_buf);-        OPENSSL_strlcat(out_buf, ascii_dollar, sizeof out_buf);+        OPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));+        OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));-    OPENSSL_strlcat(out_buf, ascii_salt, sizeof out_buf);+    OPENSSL_strlcat(out_buf, ascii_salt, sizeof(out_buf));-    for (i = passwd_len; i > sizeof buf; i -= sizeof buf) {-        if (!EVP_DigestUpdate(md, buf, sizeof buf))+    for (i = passwd_len; i > sizeof(buf); i -= sizeof(buf)) {+        if (!EVP_DigestUpdate(md, buf, sizeof(buf)))-                              (i & 1) ? passwd_len : sizeof buf))+                              (i & 1) ? passwd_len : sizeof(buf)))-                              (i & 1) ? sizeof buf : passwd_len))+                              (i & 1) ? sizeof(buf) : passwd_len))-        unsigned char buf_perm[sizeof buf];+        unsigned char buf_perm[sizeof(buf)]; # ifndef PEDANTIC              /* Unfortunately, this generates a \"no-        assert(16 == sizeof buf_perm);+        assert(16 == sizeof(buf_perm)); # endif",
            "commit_date": "2017-12-07 13:39:34-05:00",
            "commit_hash": "cbe2964821bb063f61ed2544cfce196ec1c0d62b",
            "message": "Consistent formatting for sizeof(foo)\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4872)\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar ascii_magic[5];         /* \"apr1\" plus '\\0' */\nchar ascii_salt[9];          /* Max 8 chars plus '\\0' */\nchar *ascii_passwd = NULL;\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md = NULL, *md2 = NULL;\nsize_t passwd_len, salt_len, magic_len;\npasswd_len = strlen(passwd);\nout_buf[0] = 0;\nmagic_len = strlen(magic);\nif ((magic[0] & 0x80) != 0)    /* High bit is 1 in EBCDIC alnums */\nebcdic2ascii(ascii_magic, ascii_magic, magic_len);\n/* The salt gets truncated to 8 chars */\nsalt_len = strlen(ascii_salt);\nebcdic2ascii(ascii_salt, ascii_salt, salt_len);\nascii_passwd = OPENSSL_strdup(passwd);\nif (ascii_passwd == NULL)\nreturn NULL;\nebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);\npasswd = ascii_passwd;\nif (magic_len > 0) {\nif (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */\ngoto err;\n}\nif (strlen(out_buf) > 6 + 8) /* assert \"$apr1$..salt..\" */\ngoto err;\nsalt_out = out_buf;\nif (magic_len > 0)\nsalt_out += 2 + magic_len;\nif (salt_len > 8)\ngoto err;\nmd = EVP_MD_CTX_new();\nif (md == NULL\n|| !EVP_DigestInit_ex(md, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md, passwd, passwd_len))\ngoto err;\nif (magic_len > 0)\nif (!EVP_DigestUpdate(md, ascii_dollar, 1)\n|| !EVP_DigestUpdate(md, ascii_magic, magic_len)\n|| !EVP_DigestUpdate(md, ascii_dollar, 1))\ngoto err;\nif (!EVP_DigestUpdate(md, ascii_salt, salt_len))\ngoto err;\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL\n|| !EVP_DigestInit_ex(md2, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestUpdate(md2, ascii_salt, salt_len)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\ngoto err;\n}\nif (!EVP_DigestUpdate(md, buf, i))\ngoto err;\nn = passwd_len;\nwhile (n) {\nif (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))\ngoto err;\nn >>= 1;\n}\nif (!EVP_DigestFinal_ex(md, buf, NULL))\nreturn NULL;\nfor (i = 0; i < 1000; i++) {\nif (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))\ngoto err;\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? (unsigned const char *)passwd : buf,\ngoto err;\nif (i % 3) {\nif (!EVP_DigestUpdate(md2, ascii_salt, salt_len))\ngoto err;\n}\nif (i % 7) {\nif (!EVP_DigestUpdate(md2, passwd, passwd_len))\ngoto err;\n}\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? buf : (unsigned const char *)passwd,\ngoto err;\nif (!EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\nmd2 = NULL;\nmd = NULL;\n{\n/* transform buf into output string */\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = ascii_dollar[0];\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -305,140 +309,161 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {+    char ascii_magic[5];         /* \"apr1\" plus '\\0' */+    char ascii_salt[9];          /* Max 8 chars plus '\\0' */+    char *ascii_passwd = NULL;+    OPENSSL_strlcpy(ascii_magic, magic, sizeof ascii_magic);+#ifdef CHARSET_EBCDIC+    if ((magic[0] & 0x80) != 0)    /* High bit is 1 in EBCDIC alnums */+        ebcdic2ascii(ascii_magic, ascii_magic, magic_len);+#endif++    /* The salt gets truncated to 8 chars */+    OPENSSL_strlcpy(ascii_salt, salt, sizeof ascii_salt);+    salt_len = strlen(ascii_salt);+#ifdef CHARSET_EBCDIC+    ebcdic2ascii(ascii_salt, ascii_salt, salt_len);+#endif++#ifdef CHARSET_EBCDIC+    ascii_passwd = OPENSSL_strdup(passwd);+    if (ascii_passwd == NULL)+        return NULL;+    ebcdic2ascii(ascii_passwd, ascii_passwd, passwd_len);+    passwd = ascii_passwd;+#endif-        out_buf[0] = '$';-        out_buf[1] = 0;+        OPENSSL_strlcat(out_buf, ascii_dollar, sizeof out_buf);-            return NULL;+            goto err;-        OPENSSL_strlcat(out_buf, magic, sizeof out_buf);-        OPENSSL_strlcat(out_buf, \"$\", sizeof out_buf);+        OPENSSL_strlcat(out_buf, ascii_magic, sizeof out_buf);+        OPENSSL_strlcat(out_buf, ascii_dollar, sizeof out_buf);-    OPENSSL_strlcat(out_buf, salt, sizeof out_buf);+    OPENSSL_strlcat(out_buf, ascii_salt, sizeof out_buf);-        return NULL;+        goto err;-    salt_len = strlen(salt_out);-        return NULL;+        goto err;-        if (!EVP_DigestUpdate(md, \"$\", 1)-            || !EVP_DigestUpdate(md, magic, magic_len)-            || !EVP_DigestUpdate(md, \"$\", 1))+        if (!EVP_DigestUpdate(md, ascii_dollar, 1)+            || !EVP_DigestUpdate(md, ascii_magic, magic_len)+            || !EVP_DigestUpdate(md, ascii_dollar, 1))-    if (!EVP_DigestUpdate(md, salt_out, salt_len))+    if (!EVP_DigestUpdate(md, ascii_salt, salt_len))-        || !EVP_DigestUpdate(md2, salt_out, salt_len)+        || !EVP_DigestUpdate(md2, ascii_salt, salt_len)-            if (!EVP_DigestUpdate(md2, salt_out, salt_len))+            if (!EVP_DigestUpdate(md2, ascii_salt, salt_len)) # ifndef PEDANTIC              /* Unfortunately, this generates a \"no # endif-        *output++ = '$';+        *output++ = ascii_dollar[0];",
            "commit_date": "2017-08-23 16:03:18+02:00",
            "commit_hash": "0f3ffbd1581fad58095fedcc32b0da42a486b8b7",
            "message": "apps/passwd.c: Make MD5 and SHA password making EBCDIC aware\nThis mimics the behaviour of DES_crypt, where the salt and password\nare expected to be in EBCDIC when CHARSET_EBCDIC is defined, and are\nconverted internally to ASCII.  This is also done with the magic ID\nstring if it's not already ASCII.  The resulting output is entirely\nbuilt up of ASCII components and is converted back to EBCDIC at the\nend.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/4229)\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md = NULL, *md2 = NULL;\nsize_t passwd_len, salt_len, magic_len;\npasswd_len = strlen(passwd);\nout_buf[0] = 0;\nmagic_len = strlen(magic);\nif (magic_len > 0) {\nif (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */\n}\nif (strlen(out_buf) > 6 + 8) /* assert \"$apr1$..salt..\" */\nsalt_out = out_buf;\nif (magic_len > 0)\nsalt_out += 2 + magic_len;\nif (salt_len > 8)\nmd = EVP_MD_CTX_new();\nif (md == NULL\n|| !EVP_DigestInit_ex(md, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md, passwd, passwd_len))\ngoto err;\nif (magic_len > 0)\ngoto err;\ngoto err;\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL\n|| !EVP_DigestInit_ex(md2, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) {\nif (!EVP_DigestUpdate(md, buf, sizeof buf))\ngoto err;\n}\nif (!EVP_DigestUpdate(md, buf, i))\ngoto err;\nn = passwd_len;\nwhile (n) {\nif (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))\ngoto err;\nn >>= 1;\n}\nif (!EVP_DigestFinal_ex(md, buf, NULL))\nreturn NULL;\nfor (i = 0; i < 1000; i++) {\nif (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))\ngoto err;\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? (unsigned const char *)passwd : buf,\n(i & 1) ? passwd_len : sizeof buf))\ngoto err;\nif (i % 3) {\ngoto err;\n}\nif (i % 7) {\nif (!EVP_DigestUpdate(md2, passwd, passwd_len))\ngoto err;\n}\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? buf : (unsigned const char *)passwd,\n(i & 1) ? sizeof buf : passwd_len))\ngoto err;\nif (!EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\nmd2 = NULL;\nmd = NULL;\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -303,140 +305,140 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {-#  ifndef PEDANTIC              /* Unfortunately, this generates a \"no+# ifndef PEDANTIC              /* Unfortunately, this generates a \"no-#  endif+# endif",
            "commit_date": "2017-08-23 11:43:36+02:00",
            "commit_hash": "17621bc2bc6605e7ef6317a6c9a1b1c04216b01a",
            "message": "apps/passwd.c: Fix code layout\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/4229)\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md = NULL, *md2 = NULL;\nsize_t passwd_len, salt_len, magic_len;\npasswd_len = strlen(passwd);\nout_buf[0] = 0;\nmagic_len = strlen(magic);\nif (magic_len > 0) {\nout_buf[0] = '$';\nout_buf[1] = 0;\nif (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */\nreturn NULL;\nOPENSSL_strlcat(out_buf, magic, sizeof out_buf);\nOPENSSL_strlcat(out_buf, \"$\", sizeof out_buf);\n}\nOPENSSL_strlcat(out_buf, salt, sizeof out_buf);\nif (strlen(out_buf) > 6 + 8) /* assert \"$apr1$..salt..\" */\nreturn NULL;\nsalt_out = out_buf;\nif (magic_len > 0)\nsalt_out += 2 + magic_len;\nsalt_len = strlen(salt_out);\nif (salt_len > 8)\nreturn NULL;\nmd = EVP_MD_CTX_new();\nif (md == NULL\n|| !EVP_DigestInit_ex(md, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md, passwd, passwd_len))\ngoto err;\nif (magic_len > 0)\nif (!EVP_DigestUpdate(md, \"$\", 1)\n|| !EVP_DigestUpdate(md, magic, magic_len)\n|| !EVP_DigestUpdate(md, \"$\", 1))\ngoto err;\nif (!EVP_DigestUpdate(md, salt_out, salt_len))\ngoto err;\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL\n|| !EVP_DigestInit_ex(md2, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestUpdate(md2, salt_out, salt_len)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) {\nif (!EVP_DigestUpdate(md, buf, sizeof buf))\ngoto err;\n}\nif (!EVP_DigestUpdate(md, buf, i))\ngoto err;\nn = passwd_len;\nwhile (n) {\nif (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))\ngoto err;\nn >>= 1;\n}\nif (!EVP_DigestFinal_ex(md, buf, NULL))\nreturn NULL;\nfor (i = 0; i < 1000; i++) {\nif (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))\ngoto err;\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? (unsigned const char *)passwd : buf,\n(i & 1) ? passwd_len : sizeof buf))\ngoto err;\nif (i % 3) {\nif (!EVP_DigestUpdate(md2, salt_out, salt_len))\ngoto err;\n}\nif (i % 7) {\nif (!EVP_DigestUpdate(md2, passwd, passwd_len))\ngoto err;\n}\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? buf : (unsigned const char *)passwd,\n(i & 1) ? sizeof buf : passwd_len))\ngoto err;\nif (!EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\nmd2 = NULL;\nmd = NULL;\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = '$';\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "gaetan.njinang@gmail.com",
                "name": "Ga\u00e9tan Njinang"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -315,127 +322,140 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {-    out_buf[0] = '$';-    out_buf[1] = 0;++    out_buf[0] = 0;-    if (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */-        return NULL;+    if (magic_len > 0) {+        out_buf[0] = '$';+        out_buf[1] = 0;++        if (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */+            return NULL;++        OPENSSL_strlcat(out_buf, magic, sizeof out_buf);+        OPENSSL_strlcat(out_buf, \"$\", sizeof out_buf);+    }-    OPENSSL_strlcat(out_buf, magic, sizeof out_buf);-    OPENSSL_strlcat(out_buf, \"$\", sizeof out_buf);-    salt_out = out_buf + 2 + magic_len;+    salt_out = out_buf;+    if (magic_len > 0)+        salt_out += 2 + magic_len;-        || !EVP_DigestUpdate(md, passwd, passwd_len)-        || !EVP_DigestUpdate(md, \"$\", 1)-        || !EVP_DigestUpdate(md, magic, magic_len)-        || !EVP_DigestUpdate(md, \"$\", 1)-        || !EVP_DigestUpdate(md, salt_out, salt_len))+        || !EVP_DigestUpdate(md, passwd, passwd_len))+        goto err;++    if (magic_len > 0)+        if (!EVP_DigestUpdate(md, \"$\", 1)+            || !EVP_DigestUpdate(md, magic, magic_len)+            || !EVP_DigestUpdate(md, \"$\", 1))+          goto err;++    if (!EVP_DigestUpdate(md, salt_out, salt_len)) #  ifndef PEDANTIC              /* Unfortunately, this generates a \"no #  endif",
            "commit_date": "2017-01-20 06:37:43+01:00",
            "commit_hash": "037f2c3f48fadfae58dcb1d496841a6b38c0e6a0",
            "message": "'openssl passwd' command can now compute AIX MD5-based passwords hashes.\nThe difference between the AIX MD5 password algorithm and the standard MD5\npassword algorithm is that in AIX there is no magic string while in the\nstandard MD5 password algorithm the magic string is \"$1$\"\nDocumentation of '-aixmd5' option of 'openssl passwd' command is added.\n1 test is added in test/recipes/20-test-passwd.t\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/2251)\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md = NULL, *md2 = NULL;\nsize_t passwd_len, salt_len, magic_len;\npasswd_len = strlen(passwd);\nmagic_len = strlen(magic);\nOPENSSL_strlcat(out_buf, salt, sizeof out_buf);\nif (strlen(out_buf) > 6 + 8) /* assert \"$apr1$..salt..\" */\nreturn NULL;\nsalt_len = strlen(salt_out);\nif (salt_len > 8)\nreturn NULL;\nmd = EVP_MD_CTX_new();\nif (md == NULL\n|| !EVP_DigestInit_ex(md, EVP_md5(), NULL)\ngoto err;\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL\n|| !EVP_DigestInit_ex(md2, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestUpdate(md2, salt_out, salt_len)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) {\nif (!EVP_DigestUpdate(md, buf, sizeof buf))\ngoto err;\n}\nif (!EVP_DigestUpdate(md, buf, i))\ngoto err;\nn = passwd_len;\nwhile (n) {\nif (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))\ngoto err;\nn >>= 1;\n}\nif (!EVP_DigestFinal_ex(md, buf, NULL))\nreturn NULL;\nfor (i = 0; i < 1000; i++) {\nif (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))\ngoto err;\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? (unsigned const char *)passwd : buf,\n(i & 1) ? passwd_len : sizeof buf))\ngoto err;\nif (i % 3) {\nif (!EVP_DigestUpdate(md2, salt_out, salt_len))\ngoto err;\n}\nif (i % 7) {\nif (!EVP_DigestUpdate(md2, passwd, passwd_len))\ngoto err;\n}\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? buf : (unsigned const char *)passwd,\n(i & 1) ? sizeof buf : passwd_len))\ngoto err;\nif (!EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\nmd2 = NULL;\nmd = NULL;\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = '$';\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -281,126 +281,127 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {+        goto err; #  ifndef PEDANTIC              /* Unfortunately, this generates a \"no #  endif",
            "commit_date": "2016-09-13 22:48:35+02:00",
            "commit_hash": "9f9f962d96425ed741569460791eee0280fcf942",
            "message": "Fix 'openssl passwd' with arguments -1 or -apr1\nRT#4674\nReviewed-by: Rich Salz <rsalz@openssl.org>\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md = NULL, *md2 = NULL;\nsize_t passwd_len, salt_len, magic_len;\npasswd_len = strlen(passwd);\nout_buf[0] = '$';\nout_buf[1] = 0;\nmagic_len = strlen(magic);\nif (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */\nreturn NULL;\nOPENSSL_strlcat(out_buf, magic, sizeof out_buf);\nOPENSSL_strlcat(out_buf, \"$\", sizeof out_buf);\nOPENSSL_strlcat(out_buf, salt, sizeof out_buf);\nif (strlen(out_buf) > 6 + 8) /* assert \"$apr1$..salt..\" */\nreturn NULL;\nsalt_out = out_buf + 2 + magic_len;\nsalt_len = strlen(salt_out);\nif (salt_len > 8)\nreturn NULL;\nmd = EVP_MD_CTX_new();\nif (md == NULL\n|| !EVP_DigestInit_ex(md, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md, passwd, passwd_len)\n|| !EVP_DigestUpdate(md, \"$\", 1)\n|| !EVP_DigestUpdate(md, magic, magic_len)\n|| !EVP_DigestUpdate(md, \"$\", 1)\n|| !EVP_DigestUpdate(md, salt_out, salt_len))\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL\n|| !EVP_DigestInit_ex(md2, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestUpdate(md2, salt_out, salt_len)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) {\nif (!EVP_DigestUpdate(md, buf, sizeof buf))\ngoto err;\n}\nif (!EVP_DigestUpdate(md, buf, i))\ngoto err;\nn = passwd_len;\nwhile (n) {\nif (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))\ngoto err;\nn >>= 1;\n}\nif (!EVP_DigestFinal_ex(md, buf, NULL))\nreturn NULL;\nfor (i = 0; i < 1000; i++) {\nif (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))\ngoto err;\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? (unsigned const char *)passwd : buf,\n(i & 1) ? passwd_len : sizeof buf))\ngoto err;\nif (i % 3) {\nif (!EVP_DigestUpdate(md2, salt_out, salt_len))\ngoto err;\n}\nif (i % 7) {\nif (!EVP_DigestUpdate(md2, passwd, passwd_len))\ngoto err;\n}\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? buf : (unsigned const char *)passwd,\n(i & 1) ? sizeof buf : passwd_len))\ngoto err;\nif (!EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\nmd2 = NULL;\nmd = NULL;\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = '$';\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -281,126 +281,126 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {-    if (strlen(out_buf) > 6 + 8); /* assert \"$apr1$..salt..\" */+    if (strlen(out_buf) > 6 + 8) /* assert \"$apr1$..salt..\" */ #  ifndef PEDANTIC              /* Unfortunately, this generates a \"no #  endif",
            "commit_date": "2016-05-19 08:39:47+02:00",
            "commit_hash": "edbff8da9b95d22dba22475bcf69ccf1ed15cab7",
            "message": "Code factorisation and simplification\nFix some code indentation\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1284)\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md = NULL, *md2 = NULL;\nsize_t passwd_len, salt_len, magic_len;\npasswd_len = strlen(passwd);\nout_buf[0] = '$';\nout_buf[1] = 0;\nmagic_len = strlen(magic);\nif (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */\nreturn NULL;\nOPENSSL_strlcat(out_buf, magic, sizeof out_buf);\nOPENSSL_strlcat(out_buf, \"$\", sizeof out_buf);\nOPENSSL_strlcat(out_buf, salt, sizeof out_buf);\nreturn NULL;\nsalt_out = out_buf + 2 + magic_len;\nsalt_len = strlen(salt_out);\nif (salt_len > 8)\nreturn NULL;\nmd = EVP_MD_CTX_new();\nif (md == NULL\n|| !EVP_DigestInit_ex(md, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md, passwd, passwd_len)\n|| !EVP_DigestUpdate(md, \"$\", 1)\n|| !EVP_DigestUpdate(md, magic, magic_len)\n|| !EVP_DigestUpdate(md, \"$\", 1)\n|| !EVP_DigestUpdate(md, salt_out, salt_len))\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL\n|| !EVP_DigestInit_ex(md2, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestUpdate(md2, salt_out, salt_len)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) {\nif (!EVP_DigestUpdate(md, buf, sizeof buf))\ngoto err;\n}\nif (!EVP_DigestUpdate(md, buf, i))\ngoto err;\nn = passwd_len;\nwhile (n) {\nif (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))\ngoto err;\nn >>= 1;\n}\nif (!EVP_DigestFinal_ex(md, buf, NULL))\nreturn NULL;\nfor (i = 0; i < 1000; i++) {\nif (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))\ngoto err;\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? (unsigned const char *)passwd : buf,\n(i & 1) ? passwd_len : sizeof buf))\ngoto err;\nif (i % 3) {\nif (!EVP_DigestUpdate(md2, salt_out, salt_len))\ngoto err;\n}\nif (i % 7) {\nif (!EVP_DigestUpdate(md2, passwd, passwd_len))\ngoto err;\n}\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? buf : (unsigned const char *)passwd,\n(i & 1) ? sizeof buf : passwd_len))\ngoto err;\nif (!EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\nmd2 = NULL;\nmd = NULL;\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = '$';\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -281,118 +281,126 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {-    size_t passwd_len, salt_len;+    size_t passwd_len, salt_len, magic_len;-    assert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */+    magic_len = strlen(magic);++    if (magic_len > 4)    /* assert it's  \"1\" or \"apr1\" */+        return NULL;+-    assert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */-    salt_out = out_buf + 2 + strlen(magic);++    if (strlen(out_buf) > 6 + 8); /* assert \"$apr1$..salt..\" */+        return NULL;++    salt_out = out_buf + 2 + magic_len;-    assert(salt_len <= 8);++    if (salt_len > 8)+        return NULL;-        || !EVP_DigestUpdate(md, magic, strlen(magic))+        || !EVP_DigestUpdate(md, magic, magic_len)- #  ifndef PEDANTIC              /* Unfortunately, this generates a \"no #  endif",
            "commit_date": "2016-05-09 18:42:58+02:00",
            "commit_hash": "f6c460e8f69e90fdb87129bb70951ced89c7906f",
            "message": "Fix double calls to strlen\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/1284)\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md = NULL, *md2 = NULL;\npasswd_len = strlen(passwd);\nout_buf[0] = '$';\nout_buf[1] = 0;\nOPENSSL_strlcat(out_buf, magic, sizeof out_buf);\nOPENSSL_strlcat(out_buf, \"$\", sizeof out_buf);\nOPENSSL_strlcat(out_buf, salt, sizeof out_buf);\nsalt_len = strlen(salt_out);\nmd = EVP_MD_CTX_new();\nif (md == NULL\n|| !EVP_DigestInit_ex(md, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md, passwd, passwd_len)\n|| !EVP_DigestUpdate(md, \"$\", 1)\n|| !EVP_DigestUpdate(md, \"$\", 1)\n|| !EVP_DigestUpdate(md, salt_out, salt_len))\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL\n|| !EVP_DigestInit_ex(md2, EVP_md5(), NULL)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestUpdate(md2, salt_out, salt_len)\n|| !EVP_DigestUpdate(md2, passwd, passwd_len)\n|| !EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) {\nif (!EVP_DigestUpdate(md, buf, sizeof buf))\ngoto err;\n}\nif (!EVP_DigestUpdate(md, buf, i))\ngoto err;\nn = passwd_len;\nwhile (n) {\nif (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))\ngoto err;\nn >>= 1;\n}\nif (!EVP_DigestFinal_ex(md, buf, NULL))\nreturn NULL;\nfor (i = 0; i < 1000; i++) {\nif (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))\ngoto err;\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? (unsigned const char *)passwd : buf,\n(i & 1) ? passwd_len : sizeof buf))\ngoto err;\nif (i % 3) {\nif (!EVP_DigestUpdate(md2, salt_out, salt_len))\ngoto err;\n}\nif (i % 7) {\nif (!EVP_DigestUpdate(md2, passwd, passwd_len))\ngoto err;\n}\nif (!EVP_DigestUpdate(md2,\n(i & 1) ? buf : (unsigned const char *)passwd,\n(i & 1) ? sizeof buf : passwd_len))\ngoto err;\nif (!EVP_DigestFinal_ex(md2, buf, NULL))\ngoto err;\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\nmd2 = NULL;\nmd = NULL;\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = '$';\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -281,102 +281,118 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {-    EVP_MD_CTX *md, *md2;+    EVP_MD_CTX *md = NULL, *md2 = NULL;-    if (md == NULL)-        return NULL;-    EVP_DigestInit_ex(md, EVP_md5(), NULL);-    EVP_DigestUpdate(md, passwd, passwd_len);-    EVP_DigestUpdate(md, \"$\", 1);-    EVP_DigestUpdate(md, magic, strlen(magic));-    EVP_DigestUpdate(md, \"$\", 1);-    EVP_DigestUpdate(md, salt_out, salt_len);+    if (md == NULL+        || !EVP_DigestInit_ex(md, EVP_md5(), NULL)+        || !EVP_DigestUpdate(md, passwd, passwd_len)+        || !EVP_DigestUpdate(md, \"$\", 1)+        || !EVP_DigestUpdate(md, magic, strlen(magic))+        || !EVP_DigestUpdate(md, \"$\", 1)+        || !EVP_DigestUpdate(md, salt_out, salt_len))-    if (md2 == NULL)-        return NULL;-    EVP_DigestInit_ex(md2, EVP_md5(), NULL);-    EVP_DigestUpdate(md2, passwd, passwd_len);-    EVP_DigestUpdate(md2, salt_out, salt_len);-    EVP_DigestUpdate(md2, passwd, passwd_len);-    EVP_DigestFinal_ex(md2, buf, NULL);--    for (i = passwd_len; i > sizeof buf; i -= sizeof buf)-        EVP_DigestUpdate(md, buf, sizeof buf);-    EVP_DigestUpdate(md, buf, i);+    if (md2 == NULL+        || !EVP_DigestInit_ex(md2, EVP_md5(), NULL)+        || !EVP_DigestUpdate(md2, passwd, passwd_len)+        || !EVP_DigestUpdate(md2, salt_out, salt_len)+        || !EVP_DigestUpdate(md2, passwd, passwd_len)+        || !EVP_DigestFinal_ex(md2, buf, NULL))+        goto err;++    for (i = passwd_len; i > sizeof buf; i -= sizeof buf) {+        if (!EVP_DigestUpdate(md, buf, sizeof buf))+            goto err;+    }+    if (!EVP_DigestUpdate(md, buf, i))+        goto err;-        EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1);+        if (!EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1))+            goto err;-    EVP_DigestFinal_ex(md, buf, NULL);+    if (!EVP_DigestFinal_ex(md, buf, NULL))+        return NULL;-        EVP_DigestInit_ex(md2, EVP_md5(), NULL);-        EVP_DigestUpdate(md2, (i & 1) ? (unsigned const char *)passwd : buf,-                         (i & 1) ? passwd_len : sizeof buf);-        if (i % 3)-            EVP_DigestUpdate(md2, salt_out, salt_len);-        if (i % 7)-            EVP_DigestUpdate(md2, passwd, passwd_len);-        EVP_DigestUpdate(md2, (i & 1) ? buf : (unsigned const char *)passwd,-                         (i & 1) ? sizeof buf : passwd_len);-        EVP_DigestFinal_ex(md2, buf, NULL);+        if (!EVP_DigestInit_ex(md2, EVP_md5(), NULL))+            goto err;+        if (!EVP_DigestUpdate(md2,+                              (i & 1) ? (unsigned const char *)passwd : buf,+                              (i & 1) ? passwd_len : sizeof buf))+            goto err;+        if (i % 3) {+            if (!EVP_DigestUpdate(md2, salt_out, salt_len))+                goto err;+        }+        if (i % 7) {+            if (!EVP_DigestUpdate(md2, passwd, passwd_len))+                goto err;+        }+        if (!EVP_DigestUpdate(md2,+                              (i & 1) ? buf : (unsigned const char *)passwd,+                              (i & 1) ? sizeof buf : passwd_len))+                goto err;+        if (!EVP_DigestFinal_ex(md2, buf, NULL))+                goto err;+    md2 = NULL;+    md = NULL; #  ifndef PEDANTIC              /* Unfortunately, this generates a \"no #  endif",
            "commit_date": "2016-06-18 15:46:13+01:00",
            "commit_hash": "d166ed8c11e10e9fdaeac182effb9dd318843924",
            "message": "check return values for EVP_Digest*() APIs\nReviewed-by: Richard Levitte <levitte@openssl.org>\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nsize_t passwd_len, salt_len;\npasswd_len = strlen(passwd);\nout_buf[0] = '$';\nout_buf[1] = 0;\nassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */\nOPENSSL_strlcat(out_buf, magic, sizeof out_buf);\nOPENSSL_strlcat(out_buf, \"$\", sizeof out_buf);\nOPENSSL_strlcat(out_buf, salt, sizeof out_buf);\nassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */\nsalt_out = out_buf + 2 + strlen(magic);\nsalt_len = strlen(salt_out);\nassert(salt_len <= 8);\nmd = EVP_MD_CTX_new();\nmd2 = EVP_MD_CTX_new();\nn = passwd_len;\nwhile (n) {\nn >>= 1;\n}\nfor (i = 0; i < 1000; i++) {\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = '$';\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -301,102 +301,102 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {-    strncat(out_buf, magic, 4);-    strncat(out_buf, \"$\", 1);-    strncat(out_buf, salt, 8);+    OPENSSL_strlcat(out_buf, magic, sizeof out_buf);+    OPENSSL_strlcat(out_buf, \"$\", sizeof out_buf);+    OPENSSL_strlcat(out_buf, salt, sizeof out_buf); #  ifndef PEDANTIC              /* Unfortunately, this generates a \"no #  endif",
            "commit_date": "2015-12-16 16:12:24-05:00",
            "commit_hash": "7644a9aef8932ed4d1c3f25ed776c997702982be",
            "message": "Rename some BUF_xxx to OPENSSL_xxx\nRename BUF_{strdup,strlcat,strlcpy,memdup,strndup,strnlen}\nto OPENSSL_{strdup,strlcat,strlcpy,memdup,strndup,strnlen}\nAdd #define's for the old names.\nAdd CRYPTO_{memdup,strndup}, called by OPENSSL_{memdup,strndup} macros.\nReviewed-by: Tim Hudson <tjh@openssl.org>\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md, *md2;\nsize_t passwd_len, salt_len;\npasswd_len = strlen(passwd);\nout_buf[0] = '$';\nout_buf[1] = 0;\nassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */\nassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */\nsalt_out = out_buf + 2 + strlen(magic);\nsalt_len = strlen(salt_out);\nassert(salt_len <= 8);\nmd = EVP_MD_CTX_new();\nif (md == NULL)\nreturn NULL;\nEVP_DigestInit_ex(md, EVP_md5(), NULL);\nEVP_DigestUpdate(md, passwd, passwd_len);\nEVP_DigestUpdate(md, \"$\", 1);\nEVP_DigestUpdate(md, magic, strlen(magic));\nEVP_DigestUpdate(md, \"$\", 1);\nEVP_DigestUpdate(md, salt_out, salt_len);\nmd2 = EVP_MD_CTX_new();\nif (md2 == NULL)\nreturn NULL;\nEVP_DigestInit_ex(md2, EVP_md5(), NULL);\nEVP_DigestUpdate(md2, passwd, passwd_len);\nEVP_DigestUpdate(md2, salt_out, salt_len);\nEVP_DigestUpdate(md2, passwd, passwd_len);\nEVP_DigestFinal_ex(md2, buf, NULL);\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf)\nEVP_DigestUpdate(md, buf, sizeof buf);\nEVP_DigestUpdate(md, buf, i);\nn = passwd_len;\nwhile (n) {\nEVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1);\nn >>= 1;\n}\nEVP_DigestFinal_ex(md, buf, NULL);\nfor (i = 0; i < 1000; i++) {\nEVP_DigestInit_ex(md2, EVP_md5(), NULL);\nEVP_DigestUpdate(md2, (i & 1) ? (unsigned const char *)passwd : buf,\n(i & 1) ? passwd_len : sizeof buf);\nif (i % 3)\nEVP_DigestUpdate(md2, salt_out, salt_len);\nif (i % 7)\nEVP_DigestUpdate(md2, passwd, passwd_len);\nEVP_DigestUpdate(md2, (i & 1) ? buf : (unsigned const char *)passwd,\n(i & 1) ? sizeof buf : passwd_len);\nEVP_DigestFinal_ex(md2, buf, NULL);\n}\nEVP_MD_CTX_free(md2);\nEVP_MD_CTX_free(md);\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = '$';\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -301,102 +301,102 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {-    md = EVP_MD_CTX_create();+    md = EVP_MD_CTX_new();-    md2 = EVP_MD_CTX_create();+    md2 = EVP_MD_CTX_new();-    EVP_MD_CTX_destroy(md2);-    EVP_MD_CTX_destroy(md);+    EVP_MD_CTX_free(md2);+    EVP_MD_CTX_free(md); #  ifndef PEDANTIC              /* Unfortunately, this generates a \"no #  endif",
            "commit_date": "2015-12-02 00:49:35+01:00",
            "commit_hash": "bfb0641f932490c2e7fb5f9f7cb4a88017a5abfa",
            "message": "Cleanup: fix all sources that used EVP_MD_CTX_(create|init|destroy)\nReviewed-by: Rich Salz <rsalz@openssl.org>\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nEVP_MD_CTX *md, *md2;\nsize_t passwd_len, salt_len;\npasswd_len = strlen(passwd);\nout_buf[0] = '$';\nout_buf[1] = 0;\nassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */\nstrncat(out_buf, magic, 4);\nstrncat(out_buf, \"$\", 1);\nstrncat(out_buf, salt, 8);\nassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */\nsalt_out = out_buf + 2 + strlen(magic);\nsalt_len = strlen(salt_out);\nassert(salt_len <= 8);\nif (md == NULL)\nreturn NULL;\nEVP_DigestInit_ex(md, EVP_md5(), NULL);\nEVP_DigestUpdate(md, passwd, passwd_len);\nEVP_DigestUpdate(md, \"$\", 1);\nEVP_DigestUpdate(md, magic, strlen(magic));\nEVP_DigestUpdate(md, \"$\", 1);\nEVP_DigestUpdate(md, salt_out, salt_len);\nif (md2 == NULL)\nreturn NULL;\nEVP_DigestInit_ex(md2, EVP_md5(), NULL);\nEVP_DigestUpdate(md2, passwd, passwd_len);\nEVP_DigestUpdate(md2, salt_out, salt_len);\nEVP_DigestUpdate(md2, passwd, passwd_len);\nEVP_DigestFinal_ex(md2, buf, NULL);\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf)\nEVP_DigestUpdate(md, buf, sizeof buf);\nEVP_DigestUpdate(md, buf, i);\nn = passwd_len;\nwhile (n) {\nEVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1);\nn >>= 1;\n}\nEVP_DigestFinal_ex(md, buf, NULL);\nfor (i = 0; i < 1000; i++) {\nEVP_DigestInit_ex(md2, EVP_md5(), NULL);\nEVP_DigestUpdate(md2, (i & 1) ? (unsigned const char *)passwd : buf,\n(i & 1) ? passwd_len : sizeof buf);\nif (i % 3)\nEVP_DigestUpdate(md2, salt_out, salt_len);\nif (i % 7)\nEVP_DigestUpdate(md2, passwd, passwd_len);\nEVP_DigestUpdate(md2, (i & 1) ? buf : (unsigned const char *)passwd,\n(i & 1) ? sizeof buf : passwd_len);\nEVP_DigestFinal_ex(md2, buf, NULL);\n}\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = '$';\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -301,97 +301,102 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) {-    EVP_MD_CTX md, md2;+    EVP_MD_CTX *md, *md2;-    EVP_MD_CTX_init(&md);-    EVP_DigestInit_ex(&md, EVP_md5(), NULL);-    EVP_DigestUpdate(&md, passwd, passwd_len);-    EVP_DigestUpdate(&md, \"$\", 1);-    EVP_DigestUpdate(&md, magic, strlen(magic));-    EVP_DigestUpdate(&md, \"$\", 1);-    EVP_DigestUpdate(&md, salt_out, salt_len);--    EVP_MD_CTX_init(&md2);-    EVP_DigestInit_ex(&md2, EVP_md5(), NULL);-    EVP_DigestUpdate(&md2, passwd, passwd_len);-    EVP_DigestUpdate(&md2, salt_out, salt_len);-    EVP_DigestUpdate(&md2, passwd, passwd_len);-    EVP_DigestFinal_ex(&md2, buf, NULL);+    md = EVP_MD_CTX_create();+    if (md == NULL)+        return NULL;+    EVP_DigestInit_ex(md, EVP_md5(), NULL);+    EVP_DigestUpdate(md, passwd, passwd_len);+    EVP_DigestUpdate(md, \"$\", 1);+    EVP_DigestUpdate(md, magic, strlen(magic));+    EVP_DigestUpdate(md, \"$\", 1);+    EVP_DigestUpdate(md, salt_out, salt_len);++    md2 = EVP_MD_CTX_create();+    if (md2 == NULL)+        return NULL;+    EVP_DigestInit_ex(md2, EVP_md5(), NULL);+    EVP_DigestUpdate(md2, passwd, passwd_len);+    EVP_DigestUpdate(md2, salt_out, salt_len);+    EVP_DigestUpdate(md2, passwd, passwd_len);+    EVP_DigestFinal_ex(md2, buf, NULL);-        EVP_DigestUpdate(&md, buf, sizeof buf);-    EVP_DigestUpdate(&md, buf, i);+        EVP_DigestUpdate(md, buf, sizeof buf);+    EVP_DigestUpdate(md, buf, i);-        EVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1);+        EVP_DigestUpdate(md, (n & 1) ? \"\\0\" : passwd, 1);-    EVP_DigestFinal_ex(&md, buf, NULL);+    EVP_DigestFinal_ex(md, buf, NULL);-        EVP_DigestInit_ex(&md2, EVP_md5(), NULL);-        EVP_DigestUpdate(&md2, (i & 1) ? (unsigned const char *)passwd : buf,+        EVP_DigestInit_ex(md2, EVP_md5(), NULL);+        EVP_DigestUpdate(md2, (i & 1) ? (unsigned const char *)passwd : buf,-            EVP_DigestUpdate(&md2, salt_out, salt_len);+            EVP_DigestUpdate(md2, salt_out, salt_len);-            EVP_DigestUpdate(&md2, passwd, passwd_len);-        EVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned const char *)passwd,+            EVP_DigestUpdate(md2, passwd, passwd_len);+        EVP_DigestUpdate(md2, (i & 1) ? buf : (unsigned const char *)passwd,-        EVP_DigestFinal_ex(&md2, buf, NULL);+        EVP_DigestFinal_ex(md2, buf, NULL);-    EVP_MD_CTX_cleanup(&md2);+    EVP_MD_CTX_destroy(md2);+    EVP_MD_CTX_destroy(md); #  ifndef PEDANTIC              /* Unfortunately, this generates a \"no #  endif",
            "commit_date": "2015-11-27 14:02:12+01:00",
            "commit_hash": "6e59a892db781658c050e5217127c4147c116ac9",
            "message": "Adjust all accesses to EVP_MD_CTX to use accessor functions.\nReviewed-by: Rich Salz <rsalz@openssl.org>\n/* \"$apr1$..salt..$.......md5hash..........\\0\" */\nstatic char out_buf[6 + 9 + 24 + 2];\nunsigned char buf[MD5_DIGEST_LENGTH];\nchar *salt_out;\nint n;\nunsigned int i;\nsize_t passwd_len, salt_len;\npasswd_len = strlen(passwd);\nout_buf[0] = '$';\nout_buf[1] = 0;\nassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */\nstrncat(out_buf, magic, 4);\nstrncat(out_buf, \"$\", 1);\nstrncat(out_buf, salt, 8);\nassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */\nsalt_out = out_buf + 2 + strlen(magic);\nsalt_len = strlen(salt_out);\nassert(salt_len <= 8);\nfor (i = passwd_len; i > sizeof buf; i -= sizeof buf)\nn = passwd_len;\nwhile (n) {\nn >>= 1;\n}\nfor (i = 0; i < 1000; i++) {\n(i & 1) ? passwd_len : sizeof buf);\nif (i % 3)\nif (i % 7)\n(i & 1) ? sizeof buf : passwd_len);\n}\n{\n/* transform buf into output string */\nunsigned char buf_perm[sizeof buf];\nint dest, source;\nchar *output;\n/* silly output permutation */\nfor (dest = 0, source = 0; dest < 14;\ndest++, source = (source + 6) % 17)\nbuf_perm[dest] = buf[source];\nbuf_perm[14] = buf[5];\nbuf_perm[15] = buf[11];\n* effect\" warning */\nassert(16 == sizeof buf_perm);\noutput = salt_out + salt_len;\nassert(output == out_buf + strlen(out_buf));\n*output++ = '$';\nfor (i = 0; i < 15; i += 3) {\n*output++ = cov_2char[buf_perm[i + 2] & 0x3f];\n*output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |\n(buf_perm[i + 2] >> 6)];\n*output++ = cov_2char[((buf_perm[i] & 3) << 4) |\n(buf_perm[i + 1] >> 4)];\n*output++ = cov_2char[buf_perm[i] >> 2];\n}\nassert(i == 15);\n*output++ = cov_2char[buf_perm[i] & 0x3f];"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -310,108 +293,97 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt)-\t{-\t/* \"$apr1$..salt..$.......md5hash..........\\0\" */-\tstatic char out_buf[6 + 9 + 24 + 2];-\tunsigned char buf[MD5_DIGEST_LENGTH];-\tchar *salt_out;-\tint n;-\tunsigned int i;-\tEVP_MD_CTX md,md2;-\tsize_t passwd_len, salt_len;--\tpasswd_len = strlen(passwd);-\tout_buf[0] = '$';-\tout_buf[1] = 0;-\tassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */-\tstrncat(out_buf, magic, 4);-\tstrncat(out_buf, \"$\", 1);-\tstrncat(out_buf, salt, 8);-\tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */-\tsalt_out = out_buf + 2 + strlen(magic);-\tsalt_len = strlen(salt_out);-\tassert(salt_len <= 8);-\t-\tEVP_MD_CTX_init(&md);-\tEVP_DigestInit_ex(&md,EVP_md5(), NULL);-\tEVP_DigestUpdate(&md, passwd, passwd_len);-\tEVP_DigestUpdate(&md, \"$\", 1);-\tEVP_DigestUpdate(&md, magic, strlen(magic));-\tEVP_DigestUpdate(&md, \"$\", 1);-\tEVP_DigestUpdate(&md, salt_out, salt_len);-\t-\tEVP_MD_CTX_init(&md2);-\tEVP_DigestInit_ex(&md2,EVP_md5(), NULL);-\tEVP_DigestUpdate(&md2, passwd, passwd_len);-\tEVP_DigestUpdate(&md2, salt_out, salt_len);-\tEVP_DigestUpdate(&md2, passwd, passwd_len);-\tEVP_DigestFinal_ex(&md2, buf, NULL);--\tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf)-\t\tEVP_DigestUpdate(&md, buf, sizeof buf);-\tEVP_DigestUpdate(&md, buf, i);-\t-\tn = passwd_len;-\twhile (n)-\t\t{-\t\tEVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1);-\t\tn >>= 1;-\t\t}-\tEVP_DigestFinal_ex(&md, buf, NULL);--\tfor (i = 0; i < 1000; i++)-\t\t{-\t\tEVP_DigestInit_ex(&md2,EVP_md5(), NULL);-\t\tEVP_DigestUpdate(&md2, (i & 1) ? (unsigned const char *) passwd : buf,-\t\t                       (i & 1) ? passwd_len : sizeof buf);-\t\tif (i % 3)-\t\t\tEVP_DigestUpdate(&md2, salt_out, salt_len);-\t\tif (i % 7)-\t\t\tEVP_DigestUpdate(&md2, passwd, passwd_len);-\t\tEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned const char *) passwd,-\t\t                       (i & 1) ? sizeof buf : passwd_len);-\t\tEVP_DigestFinal_ex(&md2, buf, NULL);-\t\t}-\tEVP_MD_CTX_cleanup(&md2);-\t-\t {-\t\t/* transform buf into output string */-\t-\t\tunsigned char buf_perm[sizeof buf];-\t\tint dest, source;-\t\tchar *output;--\t\t/* silly output permutation */-\t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17)-\t\t\tbuf_perm[dest] = buf[source];-\t\tbuf_perm[14] = buf[5];-\t\tbuf_perm[15] = buf[11];-#ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */-\t\tassert(16 == sizeof buf_perm);-#endif-\t\t-\t\toutput = salt_out + salt_len;-\t\tassert(output == out_buf + strlen(out_buf));-\t\t-\t\t*output++ = '$';--\t\tfor (i = 0; i < 15; i += 3)-\t\t\t{-\t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f];-\t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) |-\t\t\t\t                  (buf_perm[i+2] >> 6)];-\t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) |-\t\t\t\t                  (buf_perm[i+1] >> 4)];-\t\t\t*output++ = cov_2char[buf_perm[i] >> 2];-\t\t\t}-\t\tassert(i == 15);-\t\t*output++ = cov_2char[buf_perm[i] & 0x3f];-\t\t*output++ = cov_2char[buf_perm[i] >> 6];-\t\t*output = 0;-\t\tassert(strlen(out_buf) < sizeof(out_buf));-\t }-\tEVP_MD_CTX_cleanup(&md);--\treturn out_buf;-\t}-#endif-+{+    /* \"$apr1$..salt..$.......md5hash..........\\0\" */+    static char out_buf[6 + 9 + 24 + 2];+    unsigned char buf[MD5_DIGEST_LENGTH];+    char *salt_out;+    int n;+    unsigned int i;+    EVP_MD_CTX md, md2;+    size_t passwd_len, salt_len;++    passwd_len = strlen(passwd);+    out_buf[0] = '$';+    out_buf[1] = 0;+    assert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */+    strncat(out_buf, magic, 4);+    strncat(out_buf, \"$\", 1);+    strncat(out_buf, salt, 8);+    assert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */+    salt_out = out_buf + 2 + strlen(magic);+    salt_len = strlen(salt_out);+    assert(salt_len <= 8);++    EVP_MD_CTX_init(&md);+    EVP_DigestInit_ex(&md, EVP_md5(), NULL);+    EVP_DigestUpdate(&md, passwd, passwd_len);+    EVP_DigestUpdate(&md, \"$\", 1);+    EVP_DigestUpdate(&md, magic, strlen(magic));+    EVP_DigestUpdate(&md, \"$\", 1);+    EVP_DigestUpdate(&md, salt_out, salt_len);++    EVP_MD_CTX_init(&md2);+    EVP_DigestInit_ex(&md2, EVP_md5(), NULL);+    EVP_DigestUpdate(&md2, passwd, passwd_len);+    EVP_DigestUpdate(&md2, salt_out, salt_len);+    EVP_DigestUpdate(&md2, passwd, passwd_len);+    EVP_DigestFinal_ex(&md2, buf, NULL);++    for (i = passwd_len; i > sizeof buf; i -= sizeof buf)+        EVP_DigestUpdate(&md, buf, sizeof buf);+    EVP_DigestUpdate(&md, buf, i);++    n = passwd_len;+    while (n) {+        EVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1);+        n >>= 1;+    }+    EVP_DigestFinal_ex(&md, buf, NULL);++    for (i = 0; i < 1000; i++) {+        EVP_DigestInit_ex(&md2, EVP_md5(), NULL);+        EVP_DigestUpdate(&md2, (i & 1) ? (unsigned const char *)passwd : buf,+                         (i & 1) ? passwd_len : sizeof buf);+        if (i % 3)+            EVP_DigestUpdate(&md2, salt_out, salt_len);+        if (i % 7)+            EVP_DigestUpdate(&md2, passwd, passwd_len);+        EVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned const char *)passwd,+                         (i & 1) ? sizeof buf : passwd_len);+        EVP_DigestFinal_ex(&md2, buf, NULL);+    }+    EVP_MD_CTX_cleanup(&md2);++    {+        /* transform buf into output string */++        unsigned char buf_perm[sizeof buf];+        int dest, source;+        char *output;++        /* silly output permutation */+        for (dest = 0, source = 0; dest < 14;+             dest++, source = (source + 6) % 17)+            buf_perm[dest] = buf[source];+        buf_perm[14] = buf[5];+        buf_perm[15] = buf[11];+#  ifndef PEDANTIC              /* Unfortunately, this generates a \"no+                                 * effect\" warning */+        assert(16 == sizeof buf_perm);+#  endif++        output = salt_out + salt_len;+        assert(output == out_buf + strlen(out_buf));++        *output++ = '$';++        for (i = 0; i < 15; i += 3) {+            *output++ = cov_2char[buf_perm[i + 2] & 0x3f];+            *output++ = cov_2char[((buf_perm[i + 1] & 0xf) << 2) |+                                  (buf_perm[i + 2] >> 6)];+            *output++ = cov_2char[((buf_perm[i] & 3) << 4) |+                                  (buf_perm[i + 1] >> 4)];+            *output++ = cov_2char[buf_perm[i] >> 2];+        }+        assert(i == 15);+        *output++ = cov_2char[buf_perm[i] & 0x3f];",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -310,107 +310,108 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) \t{-\tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */+\t/* \"$apr1$..salt..$.......md5hash..........\\0\" */+\tstatic char out_buf[6 + 9 + 24 + 2]; \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n; \tunsigned int i; \tEVP_MD_CTX md,md2; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tout_buf[0] = '$'; \tout_buf[1] = 0; \tassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */ \tstrncat(out_buf, magic, 4); \tstrncat(out_buf, \"$\", 1); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 2 + strlen(magic); \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8); \tEVP_MD_CTX_init(&md); \tEVP_DigestInit_ex(&md,EVP_md5(), NULL); \tEVP_DigestUpdate(&md, passwd, passwd_len); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, magic, strlen(magic)); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, salt_out, salt_len); \tEVP_MD_CTX_init(&md2); \tEVP_DigestInit_ex(&md2,EVP_md5(), NULL); \tEVP_DigestUpdate(&md2, passwd, passwd_len); \tEVP_DigestUpdate(&md2, salt_out, salt_len); \tEVP_DigestUpdate(&md2, passwd, passwd_len); \tEVP_DigestFinal_ex(&md2, buf, NULL); \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tEVP_DigestUpdate(&md, buf, sizeof buf); \tEVP_DigestUpdate(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tEVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t} \tEVP_DigestFinal_ex(&md, buf, NULL); \tfor (i = 0; i < 1000; i++) \t\t{ \t\tEVP_DigestInit_ex(&md2,EVP_md5(), NULL); \t\tEVP_DigestUpdate(&md2, (i & 1) ? (unsigned const char *) passwd : buf, \t\t                       (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tEVP_DigestUpdate(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tEVP_DigestUpdate(&md2, passwd, passwd_len); \t\tEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned const char *) passwd, \t\t                       (i & 1) ? sizeof buf : passwd_len); \t\tEVP_DigestFinal_ex(&md2, buf, NULL); \t\t} \tEVP_MD_CTX_cleanup(&md2); \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \tEVP_MD_CTX_cleanup(&md); \treturn out_buf; \t} #endif",
            "commit_date": "2015-01-21 19:18:47+00:00",
            "commit_hash": "68d39f3ce6ff4f65170d94f7310b3f485f33328d",
            "message": "Move more comments that confuse indent\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -309,107 +309,107 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n; \tunsigned int i; \tEVP_MD_CTX md,md2; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tout_buf[0] = '$'; \tout_buf[1] = 0; \tassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */ \tstrncat(out_buf, magic, 4); \tstrncat(out_buf, \"$\", 1); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 2 + strlen(magic); \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8); \tEVP_MD_CTX_init(&md); \tEVP_DigestInit_ex(&md,EVP_md5(), NULL); \tEVP_DigestUpdate(&md, passwd, passwd_len); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, magic, strlen(magic)); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, salt_out, salt_len); \tEVP_MD_CTX_init(&md2); \tEVP_DigestInit_ex(&md2,EVP_md5(), NULL); \tEVP_DigestUpdate(&md2, passwd, passwd_len); \tEVP_DigestUpdate(&md2, salt_out, salt_len); \tEVP_DigestUpdate(&md2, passwd, passwd_len); \tEVP_DigestFinal_ex(&md2, buf, NULL); \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tEVP_DigestUpdate(&md, buf, sizeof buf); \tEVP_DigestUpdate(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tEVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t} \tEVP_DigestFinal_ex(&md, buf, NULL); \tfor (i = 0; i < 1000; i++) \t\t{ \t\tEVP_DigestInit_ex(&md2,EVP_md5(), NULL);-\t\tEVP_DigestUpdate(&md2, (i & 1) ? (unsigned char *) passwd : buf,+\t\tEVP_DigestUpdate(&md2, (i & 1) ? (unsigned const char *) passwd : buf, \t\t                       (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tEVP_DigestUpdate(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tEVP_DigestUpdate(&md2, passwd, passwd_len);-\t\tEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned char *) passwd,+\t\tEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned const char *) passwd, \t\t                       (i & 1) ? sizeof buf : passwd_len); \t\tEVP_DigestFinal_ex(&md2, buf, NULL); \t\t} \tEVP_MD_CTX_cleanup(&md2); \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \tEVP_MD_CTX_cleanup(&md); \treturn out_buf; \t} #endif",
            "commit_date": "2005-04-05 19:11:19+00:00",
            "commit_hash": "7d727231b735750c0876089204fe46c058e3f675",
            "message": "some const fixes"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -309,106 +309,107 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out;-\tint n, i;+\tint n;+\tunsigned int i; \tEVP_MD_CTX md,md2; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tout_buf[0] = '$'; \tout_buf[1] = 0; \tassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */ \tstrncat(out_buf, magic, 4); \tstrncat(out_buf, \"$\", 1); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 2 + strlen(magic); \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8); \tEVP_MD_CTX_init(&md); \tEVP_DigestInit_ex(&md,EVP_md5(), NULL); \tEVP_DigestUpdate(&md, passwd, passwd_len); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, magic, strlen(magic)); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, salt_out, salt_len); \tEVP_MD_CTX_init(&md2); \tEVP_DigestInit_ex(&md2,EVP_md5(), NULL); \tEVP_DigestUpdate(&md2, passwd, passwd_len); \tEVP_DigestUpdate(&md2, salt_out, salt_len); \tEVP_DigestUpdate(&md2, passwd, passwd_len); \tEVP_DigestFinal_ex(&md2, buf, NULL); \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tEVP_DigestUpdate(&md, buf, sizeof buf); \tEVP_DigestUpdate(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tEVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t} \tEVP_DigestFinal_ex(&md, buf, NULL); \tfor (i = 0; i < 1000; i++) \t\t{ \t\tEVP_DigestInit_ex(&md2,EVP_md5(), NULL); \t\tEVP_DigestUpdate(&md2, (i & 1) ? (unsigned char *) passwd : buf, \t\t                       (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tEVP_DigestUpdate(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tEVP_DigestUpdate(&md2, passwd, passwd_len); \t\tEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned char *) passwd, \t\t                       (i & 1) ? sizeof buf : passwd_len); \t\tEVP_DigestFinal_ex(&md2, buf, NULL); \t\t} \tEVP_MD_CTX_cleanup(&md2); \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \tEVP_MD_CTX_cleanup(&md); \treturn out_buf; \t} #endif",
            "commit_date": "2003-10-29 20:24:15+00:00",
            "commit_hash": "27545970134d703ed96027aac9b67eced124eec3",
            "message": "A general spring-cleaning (in autumn) to fix up signed/unsigned warnings.\nI have tried to convert 'len' type variable declarations to unsigned as a\nmeans to address these warnings when appropriate, but when in doubt I have\nused casts in the comparisons instead. The better solution (that would get\nus all lynched by API users) would be to go through and convert all the\nfunction prototypes and structure definitions to use unsigned variables\nexcept when signed is necessary. The proliferation of (signed) \"int\" for\nstrictly non-negative uses is unfortunate."
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -307,106 +307,106 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n, i; \tEVP_MD_CTX md,md2; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tout_buf[0] = '$'; \tout_buf[1] = 0; \tassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */ \tstrncat(out_buf, magic, 4); \tstrncat(out_buf, \"$\", 1); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 2 + strlen(magic); \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8); \tEVP_MD_CTX_init(&md);-\tEVP_DigestInit(&md,EVP_md5());+\tEVP_DigestInit_ex(&md,EVP_md5(), NULL); \tEVP_DigestUpdate(&md, passwd, passwd_len); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, magic, strlen(magic)); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, salt_out, salt_len); \tEVP_MD_CTX_init(&md2);-\tEVP_DigestInit(&md2,EVP_md5());+\tEVP_DigestInit_ex(&md2,EVP_md5(), NULL); \tEVP_DigestUpdate(&md2, passwd, passwd_len); \tEVP_DigestUpdate(&md2, salt_out, salt_len); \tEVP_DigestUpdate(&md2, passwd, passwd_len);-\tEVP_DigestFinal(&md2, buf, NULL);+\tEVP_DigestFinal_ex(&md2, buf, NULL); \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tEVP_DigestUpdate(&md, buf, sizeof buf); \tEVP_DigestUpdate(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tEVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t}-\tEVP_DigestFinal(&md, buf, NULL);+\tEVP_DigestFinal_ex(&md, buf, NULL); \tfor (i = 0; i < 1000; i++) \t\t{-\t\tEVP_DigestInit(&md2,EVP_md5());+\t\tEVP_DigestInit_ex(&md2,EVP_md5(), NULL); \t\tEVP_DigestUpdate(&md2, (i & 1) ? (unsigned char *) passwd : buf, \t\t                       (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tEVP_DigestUpdate(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tEVP_DigestUpdate(&md2, passwd, passwd_len); \t\tEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned char *) passwd, \t\t                       (i & 1) ? sizeof buf : passwd_len);-\t\tEVP_DigestFinal(&md2, buf, NULL);+\t\tEVP_DigestFinal_ex(&md2, buf, NULL); \t\t} \tEVP_MD_CTX_cleanup(&md2); \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \tEVP_MD_CTX_cleanup(&md); \treturn out_buf; \t} #endif",
            "commit_date": "2001-10-16 01:24:29+00:00",
            "commit_hash": "20d2186c87dabec56c6da48961a779843724a019",
            "message": "Retain compatibility of EVP_DigestInit() and EVP_DigestFinal()\nwith existing code.\nModify library to use digest *_ex() functions."
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -307,107 +307,106 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n, i;-\tEVP_MD_CTX md;+\tEVP_MD_CTX md,md2; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tout_buf[0] = '$'; \tout_buf[1] = 0; \tassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */ \tstrncat(out_buf, magic, 4); \tstrncat(out_buf, \"$\", 1); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 2 + strlen(magic); \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8);+\tEVP_MD_CTX_init(&md); \tEVP_DigestInit(&md,EVP_md5()); \tEVP_DigestUpdate(&md, passwd, passwd_len); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, magic, strlen(magic)); \tEVP_DigestUpdate(&md, \"$\", 1); \tEVP_DigestUpdate(&md, salt_out, salt_len);-\t {-\t\tEVP_MD_CTX md2;+\tEVP_MD_CTX_init(&md2);+\tEVP_DigestInit(&md2,EVP_md5());+\tEVP_DigestUpdate(&md2, passwd, passwd_len);+\tEVP_DigestUpdate(&md2, salt_out, salt_len);+\tEVP_DigestUpdate(&md2, passwd, passwd_len);+\tEVP_DigestFinal(&md2, buf, NULL);-\t\tEVP_DigestInit(&md2,EVP_md5());-\t\tEVP_DigestUpdate(&md2, passwd, passwd_len);-\t\tEVP_DigestUpdate(&md2, salt_out, salt_len);-\t\tEVP_DigestUpdate(&md2, passwd, passwd_len);-\t\tEVP_DigestFinal(&md2, buf, NULL);-\t } \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tEVP_DigestUpdate(&md, buf, sizeof buf); \tEVP_DigestUpdate(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tEVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t} \tEVP_DigestFinal(&md, buf, NULL); \tfor (i = 0; i < 1000; i++) \t\t{-\t\tEVP_MD_CTX md2;- \t\tEVP_DigestInit(&md2,EVP_md5()); \t\tEVP_DigestUpdate(&md2, (i & 1) ? (unsigned char *) passwd : buf, \t\t                       (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tEVP_DigestUpdate(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tEVP_DigestUpdate(&md2, passwd, passwd_len); \t\tEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned char *) passwd, \t\t                       (i & 1) ? sizeof buf : passwd_len); \t\tEVP_DigestFinal(&md2, buf, NULL); \t\t}+\tEVP_MD_CTX_cleanup(&md2); \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t }+\tEVP_MD_CTX_cleanup(&md); \treturn out_buf; \t} #endif",
            "commit_date": "2001-07-30 23:57:25+00:00",
            "commit_hash": "dbad169019598981174ff46c7a9bf58373b0e53a",
            "message": "Really add the EVP and all of the DES changes."
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -306,107 +306,107 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n, i;-\tMD5_CTX md;+\tEVP_MD_CTX md; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tout_buf[0] = '$'; \tout_buf[1] = 0; \tassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */ \tstrncat(out_buf, magic, 4); \tstrncat(out_buf, \"$\", 1); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 2 + strlen(magic); \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8);-\tMD5_Init(&md);-\tMD5_Update(&md, passwd, passwd_len);-\tMD5_Update(&md, \"$\", 1);-\tMD5_Update(&md, magic, strlen(magic));-\tMD5_Update(&md, \"$\", 1);-\tMD5_Update(&md, salt_out, salt_len);+\tEVP_DigestInit(&md,EVP_md5());+\tEVP_DigestUpdate(&md, passwd, passwd_len);+\tEVP_DigestUpdate(&md, \"$\", 1);+\tEVP_DigestUpdate(&md, magic, strlen(magic));+\tEVP_DigestUpdate(&md, \"$\", 1);+\tEVP_DigestUpdate(&md, salt_out, salt_len); \t {-\t\tMD5_CTX md2;+\t\tEVP_MD_CTX md2;-\t\tMD5_Init(&md2);-\t\tMD5_Update(&md2, passwd, passwd_len);-\t\tMD5_Update(&md2, salt_out, salt_len);-\t\tMD5_Update(&md2, passwd, passwd_len);-\t\tMD5_Final(buf, &md2);+\t\tEVP_DigestInit(&md2,EVP_md5());+\t\tEVP_DigestUpdate(&md2, passwd, passwd_len);+\t\tEVP_DigestUpdate(&md2, salt_out, salt_len);+\t\tEVP_DigestUpdate(&md2, passwd, passwd_len);+\t\tEVP_DigestFinal(&md2, buf, NULL); \t } \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf)-\t\tMD5_Update(&md, buf, sizeof buf);-\tMD5_Update(&md, buf, i);+\t\tEVP_DigestUpdate(&md, buf, sizeof buf);+\tEVP_DigestUpdate(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{-\t\tMD5_Update(&md, (n & 1) ? \"\\0\" : passwd, 1);+\t\tEVP_DigestUpdate(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t}-\tMD5_Final(buf, &md);+\tEVP_DigestFinal(&md, buf, NULL); \tfor (i = 0; i < 1000; i++) \t\t{-\t\tMD5_CTX md2;+\t\tEVP_MD_CTX md2;-\t\tMD5_Init(&md2);-\t\tMD5_Update(&md2, (i & 1) ? (unsigned char *) passwd : buf,-\t\t                 (i & 1) ? passwd_len : sizeof buf);+\t\tEVP_DigestInit(&md2,EVP_md5());+\t\tEVP_DigestUpdate(&md2, (i & 1) ? (unsigned char *) passwd : buf,+\t\t                       (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3)-\t\t\tMD5_Update(&md2, salt_out, salt_len);+\t\t\tEVP_DigestUpdate(&md2, salt_out, salt_len); \t\tif (i % 7)-\t\t\tMD5_Update(&md2, passwd, passwd_len);-\t\tMD5_Update(&md2, (i & 1) ? buf : (unsigned char *) passwd,-\t\t                 (i & 1) ? sizeof buf : passwd_len);-\t\tMD5_Final(buf, &md2);+\t\t\tEVP_DigestUpdate(&md2, passwd, passwd_len);+\t\tEVP_DigestUpdate(&md2, (i & 1) ? buf : (unsigned char *) passwd,+\t\t                       (i & 1) ? sizeof buf : passwd_len);+\t\tEVP_DigestFinal(&md2, buf, NULL); \t\t} \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \treturn out_buf; \t} #endif",
            "commit_date": "2001-06-19 22:30:40+00:00",
            "commit_hash": "323f289c480b0a8eb15ed3be2befbcc0f86e8904",
            "message": "Change all calls to low level digest routines in the library and\napplications to use EVP. Add missing calls to HMAC_cleanup() and\ndon't assume HMAC_CTX can be copied using memcpy().\nNote: this is almost identical to the patch submitted to openssl-dev\nby Verdon Walker <VWalker@novell.com> except some redundant\nEVP_add_digest_()/EVP_cleanup() calls were removed and some changes\nmade to avoid compiler warnings."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -305,107 +305,107 @@  */ static char *md5crypt(const char *passwd, const char *magic, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n, i; \tMD5_CTX md; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tout_buf[0] = '$'; \tout_buf[1] = 0; \tassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */ \tstrncat(out_buf, magic, 4); \tstrncat(out_buf, \"$\", 1); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */-\tsalt_out = out_buf + 6;+\tsalt_out = out_buf + 2 + strlen(magic); \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8); \tMD5_Init(&md); \tMD5_Update(&md, passwd, passwd_len); \tMD5_Update(&md, \"$\", 1); \tMD5_Update(&md, magic, strlen(magic)); \tMD5_Update(&md, \"$\", 1); \tMD5_Update(&md, salt_out, salt_len); \t { \t\tMD5_CTX md2; \t\tMD5_Init(&md2); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Update(&md2, salt_out, salt_len); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Final(buf, &md2); \t } \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tMD5_Update(&md, buf, sizeof buf); \tMD5_Update(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tMD5_Update(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t} \tMD5_Final(buf, &md); \tfor (i = 0; i < 1000; i++) \t\t{ \t\tMD5_CTX md2; \t\tMD5_Init(&md2); \t\tMD5_Update(&md2, (i & 1) ? (unsigned char *) passwd : buf, \t\t                 (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tMD5_Update(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Update(&md2, (i & 1) ? buf : (unsigned char *) passwd, \t\t                 (i & 1) ? sizeof buf : passwd_len); \t\tMD5_Final(buf, &md2); \t\t} \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \treturn out_buf; \t} #endif",
            "commit_date": "2001-01-19 07:37:56+00:00",
            "commit_hash": "57108f0ad573347af91681568dc790f606fd0a5b",
            "message": "Fix openssl passwd -1"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -280,104 +294,107 @@-#ifndef NO_APR1-/* MD5-based password algorithm compatible to the one found in Apache- * (should probably be available as a library function;- * then the static buffer would not be acceptable) */-static char *apr1_crypt(const char *passwd, const char *salt)+ */+static char *md5crypt(const char *passwd, const char *magic, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n, i; \tMD5_CTX md; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd);-\tstrcpy(out_buf, \"$apr1$\");+\tout_buf[0] = '$';+\tout_buf[1] = 0;+\tassert(strlen(magic) <= 4); /* \"1\" or \"apr1\" */+\tstrncat(out_buf, magic, 4);+\tstrncat(out_buf, \"$\", 1); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 6; \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8); \tMD5_Init(&md); \tMD5_Update(&md, passwd, passwd_len);-\tMD5_Update(&md, \"$apr1$\", 6);+\tMD5_Update(&md, \"$\", 1);+\tMD5_Update(&md, magic, strlen(magic));+\tMD5_Update(&md, \"$\", 1); \tMD5_Update(&md, salt_out, salt_len); \t { \t\tMD5_CTX md2; \t\tMD5_Init(&md2); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Update(&md2, salt_out, salt_len); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Final(buf, &md2); \t } \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tMD5_Update(&md, buf, sizeof buf); \tMD5_Update(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tMD5_Update(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t} \tMD5_Final(buf, &md); \tfor (i = 0; i < 1000; i++) \t\t{ \t\tMD5_CTX md2; \t\tMD5_Init(&md2); \t\tMD5_Update(&md2, (i & 1) ? (unsigned char *) passwd : buf, \t\t                 (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tMD5_Update(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Update(&md2, (i & 1) ? buf : (unsigned char *) passwd, \t\t                 (i & 1) ? sizeof buf : passwd_len); \t\tMD5_Final(buf, &md2); \t\t} \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \treturn out_buf; \t} #endif",
            "commit_date": "2000-06-23 18:00:16+00:00",
            "commit_hash": "1f4643a2f4c090f95cc2eb7868fcbcb6cf1708db",
            "message": "BSD-style MD5-based password algorithm in 'openssl passwd'.\n(Still needs to be tested against the original using sample passwords\nof different length.)"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -274,104 +274,104 @@ #ifndef NO_APR1 /* MD5-based password algorithm compatible to the one found in Apache  * (should probably be available as a library function;  * then the static buffer would not be acceptable) */ static char *apr1_crypt(const char *passwd, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n, i; \tMD5_CTX md; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tstrcpy(out_buf, \"$apr1$\"); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 6; \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8); \tMD5_Init(&md); \tMD5_Update(&md, passwd, passwd_len); \tMD5_Update(&md, \"$apr1$\", 6); \tMD5_Update(&md, salt_out, salt_len); \t { \t\tMD5_CTX md2; \t\tMD5_Init(&md2); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Update(&md2, salt_out, salt_len); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Final(buf, &md2); \t } \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tMD5_Update(&md, buf, sizeof buf); \tMD5_Update(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tMD5_Update(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t} \tMD5_Final(buf, &md); \tfor (i = 0; i < 1000; i++) \t\t{ \t\tMD5_CTX md2; \t\tMD5_Init(&md2);-\t\tMD5_Update(&md2, (i & 1) ?     passwd : buf,+\t\tMD5_Update(&md2, (i & 1) ? (unsigned char *) passwd : buf, \t\t                 (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tMD5_Update(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tMD5_Update(&md2, passwd, passwd_len);-\t\tMD5_Update(&md2, (i & 1) ?        buf : passwd,+\t\tMD5_Update(&md2, (i & 1) ? buf : (unsigned char *) passwd, \t\t                 (i & 1) ? sizeof buf : passwd_len); \t\tMD5_Final(buf, &md2); \t\t} \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \treturn out_buf; \t} #endif",
            "commit_date": "2000-02-20 20:59:21+00:00",
            "commit_hash": "4ec19e203c7ad918c1fb61dfdf92042bca113238",
            "message": "Fix gcc warnings."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -274,104 +274,104 @@ #ifndef NO_APR1 /* MD5-based password algorithm compatible to the one found in Apache  * (should probably be available as a library function;  * then the static buffer would not be acceptable) */ static char *apr1_crypt(const char *passwd, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n, i; \tMD5_CTX md; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tstrcpy(out_buf, \"$apr1$\"); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 6; \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8); \tMD5_Init(&md); \tMD5_Update(&md, passwd, passwd_len); \tMD5_Update(&md, \"$apr1$\", 6); \tMD5_Update(&md, salt_out, salt_len); \t { \t\tMD5_CTX md2; \t\tMD5_Init(&md2); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Update(&md2, salt_out, salt_len); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Final(buf, &md2); \t } \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tMD5_Update(&md, buf, sizeof buf); \tMD5_Update(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tMD5_Update(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t} \tMD5_Final(buf, &md); \tfor (i = 0; i < 1000; i++) \t\t{ \t\tMD5_CTX md2; \t\tMD5_Init(&md2);-\t\tMD5_Update(&md2, (i & 1) ? (unsigned char *) passwd : buf,-\t\t                 (i & 1) ?               passwd_len : sizeof buf);+\t\tMD5_Update(&md2, (i & 1) ?     passwd : buf,+\t\t                 (i & 1) ? passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tMD5_Update(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tMD5_Update(&md2, passwd, passwd_len);-\t\tMD5_Update(&md2, (i & 1) ?        buf : (unsigned char *) passwd,+\t\tMD5_Update(&md2, (i & 1) ?        buf : passwd, \t\t                 (i & 1) ? sizeof buf : passwd_len); \t\tMD5_Final(buf, &md2); \t\t} \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11]; #ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm); #endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \treturn out_buf; \t} #endif",
            "commit_date": "2000-02-17 18:36:21+00:00",
            "commit_hash": "73c55919443640e0856d4e80be9b7123fc270b02",
            "message": "Casts now unnecessary because of changed prototype."
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -274,102 +274,104 @@ #ifndef NO_APR1 /* MD5-based password algorithm compatible to the one found in Apache  * (should probably be available as a library function;  * then the static buffer would not be acceptable) */ static char *apr1_crypt(const char *passwd, const char *salt) \t{ \tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */ \tunsigned char buf[MD5_DIGEST_LENGTH]; \tchar *salt_out; \tint n, i; \tMD5_CTX md; \tsize_t passwd_len, salt_len; \tpasswd_len = strlen(passwd); \tstrcpy(out_buf, \"$apr1$\"); \tstrncat(out_buf, salt, 8); \tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */ \tsalt_out = out_buf + 6; \tsalt_len = strlen(salt_out); \tassert(salt_len <= 8); \tMD5_Init(&md); \tMD5_Update(&md, passwd, passwd_len); \tMD5_Update(&md, \"$apr1$\", 6); \tMD5_Update(&md, salt_out, salt_len); \t { \t\tMD5_CTX md2; \t\tMD5_Init(&md2); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Update(&md2, salt_out, salt_len); \t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Final(buf, &md2); \t } \tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf) \t\tMD5_Update(&md, buf, sizeof buf); \tMD5_Update(&md, buf, i); \tn = passwd_len; \twhile (n) \t\t{ \t\tMD5_Update(&md, (n & 1) ? \"\\0\" : passwd, 1); \t\tn >>= 1; \t\t} \tMD5_Final(buf, &md); \tfor (i = 0; i < 1000; i++) \t\t{ \t\tMD5_CTX md2; \t\tMD5_Init(&md2); \t\tMD5_Update(&md2, (i & 1) ? (unsigned char *) passwd : buf, \t\t                 (i & 1) ?               passwd_len : sizeof buf); \t\tif (i % 3) \t\t\tMD5_Update(&md2, salt_out, salt_len); \t\tif (i % 7) \t\t\tMD5_Update(&md2, passwd, passwd_len); \t\tMD5_Update(&md2, (i & 1) ?        buf : (unsigned char *) passwd, \t\t                 (i & 1) ? sizeof buf : passwd_len); \t\tMD5_Final(buf, &md2); \t\t} \t { \t\t/* transform buf into output string */ \t\tunsigned char buf_perm[sizeof buf]; \t\tint dest, source; \t\tchar *output; \t\t/* silly output permutation */ \t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17) \t\t\tbuf_perm[dest] = buf[source]; \t\tbuf_perm[14] = buf[5]; \t\tbuf_perm[15] = buf[11];+#ifndef PEDANTIC /* Unfortunately, this generates a \"no effect\" warning */ \t\tassert(16 == sizeof buf_perm);+#endif \t\toutput = salt_out + salt_len; \t\tassert(output == out_buf + strlen(out_buf)); \t\t*output++ = '$'; \t\tfor (i = 0; i < 15; i += 3) \t\t\t{ \t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f]; \t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) | \t\t\t\t                  (buf_perm[i+2] >> 6)]; \t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) | \t\t\t\t                  (buf_perm[i+1] >> 4)]; \t\t\t*output++ = cov_2char[buf_perm[i] >> 2]; \t\t\t} \t\tassert(i == 15); \t\t*output++ = cov_2char[buf_perm[i] & 0x3f]; \t\t*output++ = cov_2char[buf_perm[i] >> 6]; \t\t*output = 0; \t\tassert(strlen(out_buf) < sizeof(out_buf)); \t } \treturn out_buf; \t} #endif",
            "commit_date": "2000-02-16 12:09:17+00:00",
            "commit_hash": "bd44570322940cf1d1e01ad27c9e1949806a06cd",
            "message": "Fix signed/unsigned warnings."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- a/apps/passwd.c+++ b/apps/passwd.c@@ -192,1 +274,102 @@+#ifndef NO_APR1+/* MD5-based password algorithm compatible to the one found in Apache+ * (should probably be available as a library function;+ * then the static buffer would not be acceptable) */+static char *apr1_crypt(const char *passwd, const char *salt)+\t{+\tstatic char out_buf[6 + 9 + 24 + 2]; /* \"$apr1$..salt..$.......md5hash..........\\0\" */+\tunsigned char buf[MD5_DIGEST_LENGTH];+\tchar *salt_out;+\tint n, i;+\tMD5_CTX md;+\tsize_t passwd_len, salt_len;++\tpasswd_len = strlen(passwd);+\tstrcpy(out_buf, \"$apr1$\");+\tstrncat(out_buf, salt, 8);+\tassert(strlen(out_buf) <= 6 + 8); /* \"$apr1$..salt..\" */+\tsalt_out = out_buf + 6;+\tsalt_len = strlen(salt_out);+\tassert(salt_len <= 8);+\t+\tMD5_Init(&md);+\tMD5_Update(&md, passwd, passwd_len);+\tMD5_Update(&md, \"$apr1$\", 6);+\tMD5_Update(&md, salt_out, salt_len);+\t+\t {+\t\tMD5_CTX md2;++\t\tMD5_Init(&md2);+\t\tMD5_Update(&md2, passwd, passwd_len);+\t\tMD5_Update(&md2, salt_out, salt_len);+\t\tMD5_Update(&md2, passwd, passwd_len);+\t\tMD5_Final(buf, &md2);+\t }+\tfor (i = passwd_len; i > sizeof buf; i -= sizeof buf)+\t\tMD5_Update(&md, buf, sizeof buf);+\tMD5_Update(&md, buf, i);+\t+\tn = passwd_len;+\twhile (n)+\t\t{+\t\tMD5_Update(&md, (n & 1) ? \"\\0\" : passwd, 1);+\t\tn >>= 1;+\t\t}+\tMD5_Final(buf, &md);++\tfor (i = 0; i < 1000; i++)+\t\t{+\t\tMD5_CTX md2;++\t\tMD5_Init(&md2);+\t\tMD5_Update(&md2, (i & 1) ? (unsigned char *) passwd : buf,+\t\t                 (i & 1) ?               passwd_len : sizeof buf);+\t\tif (i % 3)+\t\t\tMD5_Update(&md2, salt_out, salt_len);+\t\tif (i % 7)+\t\t\tMD5_Update(&md2, passwd, passwd_len);+\t\tMD5_Update(&md2, (i & 1) ?        buf : (unsigned char *) passwd,+\t\t                 (i & 1) ? sizeof buf : passwd_len);+\t\tMD5_Final(buf, &md2);+\t\t}+\t+\t {+\t\t/* transform buf into output string */+\t+\t\tunsigned char buf_perm[sizeof buf];+\t\tint dest, source;+\t\tchar *output;++\t\t/* silly output permutation */+\t\tfor (dest = 0, source = 0; dest < 14; dest++, source = (source + 6) % 17)+\t\t\tbuf_perm[dest] = buf[source];+\t\tbuf_perm[14] = buf[5];+\t\tbuf_perm[15] = buf[11];+\t\tassert(16 == sizeof buf_perm);+\t\t+\t\toutput = salt_out + salt_len;+\t\tassert(output == out_buf + strlen(out_buf));+\t\t+\t\t*output++ = '$';++\t\tfor (i = 0; i < 15; i += 3)+\t\t\t{+\t\t\t*output++ = cov_2char[buf_perm[i+2] & 0x3f];+\t\t\t*output++ = cov_2char[((buf_perm[i+1] & 0xf) << 2) |+\t\t\t\t                  (buf_perm[i+2] >> 6)];+\t\t\t*output++ = cov_2char[((buf_perm[i] & 3) << 4) |+\t\t\t\t                  (buf_perm[i+1] >> 4)];+\t\t\t*output++ = cov_2char[buf_perm[i] >> 2];+\t\t\t}+\t\tassert(i == 15);+\t\t*output++ = cov_2char[buf_perm[i] & 0x3f];+\t\t*output++ = cov_2char[buf_perm[i] >> 6];+\t\t*output = 0;+\t\tassert(strlen(out_buf) < sizeof(out_buf));+\t }++\treturn out_buf;+\t} #endif+",
            "commit_date": "2000-02-11 16:25:44+00:00",
            "commit_hash": "e6e7b5f3dfbbacf75668d732b7b73a62084b5b27",
            "message": "Implement MD5-based \"apr1\" password hash."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/apps/passwd.c b/apps/passwd.c--- /dev/null+++ b/apps/passwd.c@@ -0,0 +192,1 @@+#endif",
            "commit_date": "2000-02-10 21:50:52+00:00",
            "commit_hash": "bb325c7d6a724f66615965478d670456e1c922d2",
            "message": "'passwd' tool."
        }
    ],
    "git log -L203,207:test/cipherlist_test.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/test/cipherlist_test.c b/test/cipherlist_test.c--- a/test/cipherlist_test.c+++ b/test/cipherlist_test.c@@ -207,7 +205,5 @@ static int test_default_cipherlist_explicit(void) {-    if (fixture == NULL)-        return 0;",
            "commit_date": "2020-08-12 20:24:26+02:00",
            "commit_hash": "06cee80a843cae6bcb2dcba7eab26c963e10f825",
            "message": "testutil: Make SETUP_TEST_FIXTURE return 0 on fixture == NULL\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/11808)\nSETUP_CIPHERLIST_TEST_FIXTURE();\nif (!TEST_true(SSL_CTX_set_cipher_list(fixture->server, \"DEFAULT\"))"
        },
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/test/cipherlist_test.c b/test/cipherlist_test.c--- a/test/cipherlist_test.c+++ b/test/cipherlist_test.c@@ -197,7 +197,7 @@-static int test_default_cipherlist_explicit()+static int test_default_cipherlist_explicit(void) {",
            "commit_date": "2017-08-15 23:39:03+02:00",
            "commit_hash": "31a80694d425bf7f3a0ed5cc2ee775d9418a5490",
            "message": "[Win] Fix some test method signatures ...\nto halves MSVC warnings.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4172)\nSETUP_CIPHERLIST_TEST_FIXTURE();\nif (fixture == NULL)\nreturn 0;\nif (!TEST_true(SSL_CTX_set_cipher_list(fixture->server, \"DEFAULT\"))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/cipherlist_test.c b/test/cipherlist_test.c--- a/test/cipherlist_test.c+++ b/test/cipherlist_test.c@@ -181,6 +192,7 @@ static int test_default_cipherlist_explicit() {-    TEST_check(SSL_CTX_set_cipher_list(fixture.server, \"DEFAULT\"));-    TEST_check(SSL_CTX_set_cipher_list(fixture.client, \"DEFAULT\"));+    if (fixture == NULL)+        return 0;+    if (!TEST_true(SSL_CTX_set_cipher_list(fixture->server, \"DEFAULT\"))",
            "commit_date": "2017-06-22 14:00:55+10:00",
            "commit_hash": "019e47ce564e9d57ed85c4ebe0672518b6a349f5",
            "message": "Remove uses of the TEST_check macro.\nThis macro aborts the test which prevents later tests from executing.  It also\nbypasses the test framework output functionality.\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3750)\nSETUP_CIPHERLIST_TEST_FIXTURE();"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/cipherlist_test.c b/test/cipherlist_test.c--- a/test/cipherlist_test.c+++ b/test/cipherlist_test.c@@ -182,6 +182,6 @@ static int test_default_cipherlist_explicit() {-    OPENSSL_assert(SSL_CTX_set_cipher_list(fixture.server, \"DEFAULT\"));-    OPENSSL_assert(SSL_CTX_set_cipher_list(fixture.client, \"DEFAULT\"));+    TEST_check(SSL_CTX_set_cipher_list(fixture.server, \"DEFAULT\"));+    TEST_check(SSL_CTX_set_cipher_list(fixture.client, \"DEFAULT\"));",
            "commit_date": "2017-04-11 16:16:33-04:00",
            "commit_hash": "e2a29ad6c5f6b42ce71400595cb504cbf8f3646a",
            "message": "Convert x509aux, cipherlist, casttest\nTo new test framework\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3189)\nSETUP_CIPHERLIST_TEST_FIXTURE();"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/test/cipherlist_test.c b/test/cipherlist_test.c--- /dev/null+++ b/test/cipherlist_test.c@@ -0,0 +193,6 @@++static int test_default_cipherlist_explicit()+{+    SETUP_CIPHERLIST_TEST_FIXTURE();+    OPENSSL_assert(SSL_CTX_set_cipher_list(fixture.server, \"DEFAULT\"));+    OPENSSL_assert(SSL_CTX_set_cipher_list(fixture.client, \"DEFAULT\"));",
            "commit_date": "2016-04-06 16:03:06+02:00",
            "commit_hash": "5a22cf96a0a1c34968c0664f99b7ebb7ccf6ed75",
            "message": "Replace cipherlist test\nThe old cipherlist test in ssltest.c only tests the internal order of\nthe cipher table, which is pretty useless.\nReplace this test with a test that catches inadvertent changes to the\ndefault cipherlist.\nFix run_tests.pl to correctly filter tests that have \"list\" in their name.\n(Also includes a small drive-by fix in .gitignore.)\nReviewed-by: Rich Salz <rsalz@openssl.org>"
        }
    ],
    "git log -L4537,4549:crypto/ec/curve25519.c": [
        {
            "author": {
                "email": "Matthias.St.Pierre@ncp-e.com",
                "name": "Dr. Matthias St. Pierre"
            },
            "changes": "diff --git a/crypto/ec/curve25519.c b/crypto/ec/curve25519.c--- a/crypto/ec/curve25519.c+++ b/crypto/ec/curve25519.c@@ -4431,44 +4530,13 @@- * B is the Ed25519 base point (x,4/5) with x positive. */+ */ static void ge_double_scalarmult_vartime(ge_p2 *r, const uint8_t *a,-                                         const ge_p3 *A, const uint8_t *b) {-  signed char aslide[256];-  signed char bslide[256];-  ge_cached Ai[8]; /* A,3A,5A,7A,9A,11A,13A,15A */-  ge_p1p1 t;-  ge_p3 u;-  ge_p3 A2;-  int i;--  slide(aslide, a);-  slide(bslide, b);--  ge_p3_to_cached(&Ai[0], A);-  ge_p3_dbl(&t, A);-  ge_p1p1_to_p3(&A2, &t);-  ge_add(&t, &A2, &Ai[0]);-  ge_p1p1_to_p3(&u, &t);-  ge_p3_to_cached(&Ai[1], &u);-  ge_add(&t, &A2, &Ai[1]);-  ge_p1p1_to_p3(&u, &t);-  ge_p3_to_cached(&Ai[2], &u);-  ge_add(&t, &A2, &Ai[2]);-  ge_p1p1_to_p3(&u, &t);-  ge_p3_to_cached(&Ai[3], &u);-  ge_add(&t, &A2, &Ai[3]);-  ge_p1p1_to_p3(&u, &t);-  ge_p3_to_cached(&Ai[4], &u);-  ge_add(&t, &A2, &Ai[4]);-  ge_p1p1_to_p3(&u, &t);-  ge_p3_to_cached(&Ai[5], &u);-  ge_add(&t, &A2, &Ai[5]);-  ge_p1p1_to_p3(&u, &t);-  ge_p3_to_cached(&Ai[6], &u);-  ge_add(&t, &A2, &Ai[6]);-  ge_p1p1_to_p3(&u, &t);-  ge_p3_to_cached(&Ai[7], &u);--  ge_p2_0(r);--  for (i = 255; i >= 0; --i) {-    if (aslide[i] || bslide[i]) {-      break;+                                         const ge_p3 *A, const uint8_t *b)+{+    signed char aslide[256];+    signed char bslide[256];+    ge_cached Ai[8]; /* A,3A,5A,7A,9A,11A,13A,15A */+    ge_p1p1 t;+    ge_p3 u;+    ge_p3 A2;+    int i;++    slide(aslide, a);",
            "commit_date": "2018-12-03 22:01:18+01:00",
            "commit_hash": "3a17b9a46ecf54a30073534dff04e3223ff98813",
            "message": "curve25519.c: reformat code to follow coding guidelines\nFixes #7698\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/7750)"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/crypto/ec/curve25519.c b/crypto/ec/curve25519.c--- a/crypto/ec/curve25519.c+++ b/crypto/ec/curve25519.c@@ -3366,0 +3692,44 @@+ * B is the Ed25519 base point (x,4/5) with x positive. */+static void ge_double_scalarmult_vartime(ge_p2 *r, const uint8_t *a,+                                         const ge_p3 *A, const uint8_t *b) {+  signed char aslide[256];+  signed char bslide[256];+  ge_cached Ai[8]; /* A,3A,5A,7A,9A,11A,13A,15A */+  ge_p1p1 t;+  ge_p3 u;+  ge_p3 A2;+  int i;++  slide(aslide, a);+  slide(bslide, b);++  ge_p3_to_cached(&Ai[0], A);+  ge_p3_dbl(&t, A);+  ge_p1p1_to_p3(&A2, &t);+  ge_add(&t, &A2, &Ai[0]);+  ge_p1p1_to_p3(&u, &t);+  ge_p3_to_cached(&Ai[1], &u);+  ge_add(&t, &A2, &Ai[1]);+  ge_p1p1_to_p3(&u, &t);+  ge_p3_to_cached(&Ai[2], &u);+  ge_add(&t, &A2, &Ai[2]);+  ge_p1p1_to_p3(&u, &t);+  ge_p3_to_cached(&Ai[3], &u);+  ge_add(&t, &A2, &Ai[3]);+  ge_p1p1_to_p3(&u, &t);+  ge_p3_to_cached(&Ai[4], &u);+  ge_add(&t, &A2, &Ai[4]);+  ge_p1p1_to_p3(&u, &t);+  ge_p3_to_cached(&Ai[5], &u);+  ge_add(&t, &A2, &Ai[5]);+  ge_p1p1_to_p3(&u, &t);+  ge_p3_to_cached(&Ai[6], &u);+  ge_add(&t, &A2, &Ai[6]);+  ge_p1p1_to_p3(&u, &t);+  ge_p3_to_cached(&Ai[7], &u);++  ge_p2_0(r);++  for (i = 255; i >= 0; --i) {+    if (aslide[i] || bslide[i]) {+      break;",
            "commit_date": "2017-04-04 22:56:41+01:00",
            "commit_hash": "06c6d05faea05ced44a580c5a2f8bf38a4f3017a",
            "message": "Add Ed25519 algorithm.\nReinstate Ed25519 algorithm to curv25519.c this is largely just a copy of\nthe code from BoringSSL with some adjustments so it compiles under OpenSSL.\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3503)"
        }
    ],
    "git log -L158,179:test/ectest.c": [
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -159,22 +158,22 @@ static int prime_field_tests(void) {-# ifndef OPENSSL_NO_DEPRECATED_3_0+#ifndef OPENSSL_NO_DEPRECATED_3_0-# endif+#endif",
            "commit_date": "2021-01-20 12:59:53+01:00",
            "commit_hash": "f377e58fde1a7e6b29067c48df7d3c04fdaeba38",
            "message": "Disable the test-ec completely when building with no-ec\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13139)\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *scalar3 = NULL;\nEC_GROUP *group = NULL;\nEC_POINT *P = NULL, *Q = NULL, *R = NULL;\nBIGNUM *x = NULL, *y = NULL, *z = NULL, *yplusone = NULL;\nconst EC_POINT *points[4];\nconst BIGNUM *scalars[4];\nunsigned char buf[100];\nsize_t len, r = 0;\nint k;\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_true(BN_hex2bn(&p, \"17\"))\n|| !TEST_true(BN_hex2bn(&a, \"1\"))"
        },
        {
            "author": {
                "email": "bbrumley@gmail.com",
                "name": "Billy Brumley"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -159,24 +159,22 @@ static int prime_field_tests(void) {-    EC_GROUP *group = NULL, *tmp = NULL;-    EC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL,-             *P_256 = NULL, *P_384 = NULL, *P_521 = NULL;+    EC_GROUP *group = NULL; # ifndef OPENSSL_NO_DEPRECATED_3_0 # endif",
            "commit_date": "2020-05-27 13:30:04+03:00",
            "commit_hash": "23ccae80bd58adfe89e3e345414684eb82bdb531",
            "message": "Move EC_METHOD to internal-only\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/11928)\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *scalar3 = NULL;\nEC_POINT *P = NULL, *Q = NULL, *R = NULL;\nBIGNUM *x = NULL, *y = NULL, *z = NULL, *yplusone = NULL;\nconst EC_POINT *points[4];\nconst BIGNUM *scalars[4];\nunsigned char buf[100];\nsize_t len, r = 0;\nint k;\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_true(BN_hex2bn(&p, \"17\"))\n|| !TEST_true(BN_hex2bn(&a, \"1\"))"
        },
        {
            "author": {
                "email": "bbrumley@gmail.com",
                "name": "Billy Brumley"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -145,22 +156,24 @@ static int prime_field_tests(void) {+# ifndef OPENSSL_NO_DEPRECATED_3_0+# endif",
            "commit_date": "2020-05-13 07:33:59+03:00",
            "commit_hash": "4fcd15c18ad6b5523a389863d3e5628d44db6eb4",
            "message": "deprecate EC_POINTs_mul function\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/11807)\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *scalar3 = NULL;\nEC_GROUP *group = NULL, *tmp = NULL;\nEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL,\n*P_256 = NULL, *P_384 = NULL, *P_521 = NULL;\nEC_POINT *P = NULL, *Q = NULL, *R = NULL;\nBIGNUM *x = NULL, *y = NULL, *z = NULL, *yplusone = NULL;\nconst EC_POINT *points[4];\nconst BIGNUM *scalars[4];\nunsigned char buf[100];\nsize_t len, r = 0;\nint k;\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_true(BN_hex2bn(&p, \"17\"))\n|| !TEST_true(BN_hex2bn(&a, \"1\"))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -151,22 +151,22 @@ static int prime_field_tests(void) {-    size_t i, len, r = 0;+    size_t len, r = 0;",
            "commit_date": "2017-06-12 10:01:17+10:00",
            "commit_hash": "3791646202bb4da21992b0aecae253d394507a9e",
            "message": "Add output routines to allow consistent formatting of memory, strings\nand bignums.  These have been refactored into their own file, along with\ntheir error displays.  The formatting follows the output format used\non error, except that bignums of sixty four bits or less are displayed\nin a more compact one line form.\nAdded a TEST_note function for producing output without file and line\ninformation.\nUpdate the three tests that call BN_print so they use the new test\ninfrastructure instead.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3655)\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *scalar3 = NULL;\nEC_GROUP *group = NULL, *tmp = NULL;\nEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL,\n*P_256 = NULL, *P_384 = NULL, *P_521 = NULL;\nEC_POINT *P = NULL, *Q = NULL, *R = NULL;\nBIGNUM *x = NULL, *y = NULL, *z = NULL, *yplusone = NULL;\nconst EC_POINT *points[4];\nconst BIGNUM *scalars[4];\nunsigned char buf[100];\nint k;\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_true(BN_hex2bn(&p, \"17\"))\n|| !TEST_true(BN_hex2bn(&a, \"1\"))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -192,74 +151,22 @@-static void prime_field_tests(void)+static int prime_field_tests(void) {-    BIGNUM *p, *a, *b;-    EC_GROUP *group;-    EC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 =-        NULL, *P_384 = NULL, *P_521 = NULL;-    EC_POINT *P, *Q, *R;-    BIGNUM *x, *y, *z, *yplusone;+    BIGNUM *p = NULL, *a = NULL, *b = NULL, *scalar3 = NULL;+    EC_GROUP *group = NULL, *tmp = NULL;+    EC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL,+             *P_256 = NULL, *P_384 = NULL, *P_521 = NULL;+    EC_POINT *P = NULL, *Q = NULL, *R = NULL;+    BIGNUM *x = NULL, *y = NULL, *z = NULL, *yplusone = NULL;+    const EC_POINT *points[4];+    const BIGNUM *scalars[4];-    size_t i, len;+    size_t i, len, r = 0;-    ctx = BN_CTX_new();-    if (!ctx)-        ABORT;--    p = BN_new();-    a = BN_new();-    b = BN_new();-    if (!p || !a || !b)-        ABORT;--    if (!BN_hex2bn(&p, \"17\"))-        ABORT;-    if (!BN_hex2bn(&a, \"1\"))-        ABORT;-    if (!BN_hex2bn(&b, \"1\"))-        ABORT;--    group = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use-                                                 * EC_GROUP_new_curve_GFp so-                                                 * that the library gets to-                                                 * choose the EC_METHOD */-    if (!group)-        ABORT;--    if (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx))-        ABORT;--    {-        EC_GROUP *tmp;-        tmp = EC_GROUP_new(EC_GROUP_method_of(group));-        if (!tmp)-            ABORT;-        if (!EC_GROUP_copy(tmp, group))-            ABORT;-        EC_GROUP_free(group);-        group = tmp;-    }--    if (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx))-        ABORT;--    fprintf(stdout,-            \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\");-    BN_print_fp(stdout, p);-    fprintf(stdout, \")\\n     a = 0x\");-    BN_print_fp(stdout, a);-    fprintf(stdout, \"\\n     b = 0x\");-    BN_print_fp(stdout, b);-    fprintf(stdout, \"\\n\");--    P = EC_POINT_new(group);-    Q = EC_POINT_new(group);-    R = EC_POINT_new(group);-    if (!P || !Q || !R)-        ABORT;--    if (!EC_POINT_set_to_infinity(group, P))-        ABORT;-    if (!EC_POINT_is_at_infinity(group, P))-        ABORT;+    if (!TEST_ptr(ctx = BN_CTX_new())+        || !TEST_ptr(p = BN_new())+        || !TEST_ptr(a = BN_new())+        || !TEST_ptr(b = BN_new())+        || !TEST_true(BN_hex2bn(&p, \"17\"))+        || !TEST_true(BN_hex2bn(&a, \"1\"))",
            "commit_date": "2017-04-28 14:06:11+10:00",
            "commit_hash": "2db85ac97a5dda90249f5e630e7b29c4196fc397",
            "message": "Conversion of the EC tests to use the framework.\nSome refactoring done as well.\nThe prime_field_tests() function needs splitting and refactoring still.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3340)\nBN_CTX *ctx = NULL;\nunsigned char buf[100];\nint k;"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -195,74 +195,74 @@ static void prime_field_tests(void) {-    BIGNUM *x, *y, *z;+    BIGNUM *x, *y, *z, *yplusone;",
            "commit_date": "2016-06-03 14:42:04+02:00",
            "commit_hash": "1e2012b7ff4a5f12273446b281775faa5c8a1858",
            "message": "RT 4242: reject invalid EC point coordinates\nWe already test in EC_POINT_oct2point that points are on the curve. To\nbe on the safe side, move this check to\nEC_POINT_set_affine_coordinates_* so as to also check point coordinates\nreceived through some other method.\nWe do not check projective coordinates, though, as\n- it's unlikely that applications would be receiving this primarily\ninternal representation from untrusted sources, and\n- it's possible that the projective setters are used in a setting where\nperformance matters.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nBN_CTX *ctx = NULL;\nBIGNUM *p, *a, *b;\nEC_GROUP *group;\nEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 =\nNULL, *P_384 = NULL, *P_521 = NULL;\nEC_POINT *P, *Q, *R;\nunsigned char buf[100];\nsize_t i, len;\nint k;\nctx = BN_CTX_new();\nif (!ctx)\nABORT;\np = BN_new();\na = BN_new();\nb = BN_new();\nif (!p || !a || !b)\nABORT;\nif (!BN_hex2bn(&p, \"17\"))\nABORT;\nif (!BN_hex2bn(&a, \"1\"))\nABORT;\nif (!BN_hex2bn(&b, \"1\"))\nABORT;\ngroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use\n* EC_GROUP_new_curve_GFp so\n* that the library gets to\n* choose the EC_METHOD */\nif (!group)\nABORT;\nif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx))\nABORT;\n{\nEC_GROUP *tmp;\ntmp = EC_GROUP_new(EC_GROUP_method_of(group));\nif (!tmp)\nABORT;\nif (!EC_GROUP_copy(tmp, group))\nABORT;\nEC_GROUP_free(group);\ngroup = tmp;\n}\nif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx))\nABORT;\nfprintf(stdout,\n\"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\");\nBN_print_fp(stdout, p);\nfprintf(stdout, \")\\n     a = 0x\");\nBN_print_fp(stdout, a);\nfprintf(stdout, \"\\n     b = 0x\");\nBN_print_fp(stdout, b);\nfprintf(stdout, \"\\n\");\nP = EC_POINT_new(group);\nQ = EC_POINT_new(group);\nR = EC_POINT_new(group);\nif (!P || !Q || !R)\nABORT;\nif (!EC_POINT_set_to_infinity(group, P))\nABORT;\nif (!EC_POINT_is_at_infinity(group, P))\nABORT;"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -228,76 +228,74 @@ static void prime_field_tests(void) {-# if 1                          /* optional */-# endif",
            "commit_date": "2015-02-06 10:54:20-05:00",
            "commit_hash": "6f91b017bbb7140f816721141ac156d1b828a6b3",
            "message": "Live code cleanup: remove #if 1 stuff\nFor code bracketed by \"#if 1\" then remove the alternate\n\"#else .. #endif\" lines.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nBN_CTX *ctx = NULL;\nBIGNUM *p, *a, *b;\nEC_GROUP *group;\nEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 =\nNULL, *P_384 = NULL, *P_521 = NULL;\nEC_POINT *P, *Q, *R;\nBIGNUM *x, *y, *z;\nunsigned char buf[100];\nsize_t i, len;\nint k;\nctx = BN_CTX_new();\nif (!ctx)\nABORT;\np = BN_new();\na = BN_new();\nb = BN_new();\nif (!p || !a || !b)\nABORT;\nif (!BN_hex2bn(&p, \"17\"))\nABORT;\nif (!BN_hex2bn(&a, \"1\"))\nABORT;\nif (!BN_hex2bn(&b, \"1\"))\nABORT;\ngroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use\n* EC_GROUP_new_curve_GFp so\n* that the library gets to\n* choose the EC_METHOD */\nif (!group)\nABORT;\nif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx))\nABORT;\n{\nEC_GROUP *tmp;\ntmp = EC_GROUP_new(EC_GROUP_method_of(group));\nif (!tmp)\nABORT;\nif (!EC_GROUP_copy(tmp, group))\nABORT;\nEC_GROUP_free(group);\ngroup = tmp;\n}\nif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx))\nABORT;\nfprintf(stdout,\n\"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\");\nBN_print_fp(stdout, p);\nfprintf(stdout, \")\\n     a = 0x\");\nBN_print_fp(stdout, a);\nfprintf(stdout, \"\\n     b = 0x\");\nBN_print_fp(stdout, b);\nfprintf(stdout, \"\\n\");\nP = EC_POINT_new(group);\nQ = EC_POINT_new(group);\nR = EC_POINT_new(group);\nif (!P || !Q || !R)\nABORT;\nif (!EC_POINT_set_to_infinity(group, P))\nABORT;\nif (!EC_POINT_is_at_infinity(group, P))\nABORT;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -271,496 +315,76 @@ static void prime_field_tests(void)-\t{-\tBN_CTX *ctx = NULL;-\tBIGNUM *p, *a, *b;-\tEC_GROUP *group;-\tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL;-\tEC_POINT *P, *Q, *R;-\tBIGNUM *x, *y, *z;-\tunsigned char buf[100];-\tsize_t i, len;-\tint k;-\t-#if 1 /* optional */-\tctx = BN_CTX_new();-\tif (!ctx) ABORT;-#endif--\tp = BN_new();-\ta = BN_new();-\tb = BN_new();-\tif (!p || !a || !b) ABORT;--\tif (!BN_hex2bn(&p, \"17\")) ABORT;-\tif (!BN_hex2bn(&a, \"1\")) ABORT;-\tif (!BN_hex2bn(&b, \"1\")) ABORT;-\t-\tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp-\t                                             * so that the library gets to choose the EC_METHOD */-\tif (!group) ABORT;--\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\t{-\t\tEC_GROUP *tmp;-\t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group));-\t\tif (!tmp) ABORT;-\t\tif (!EC_GROUP_copy(tmp, group)) ABORT;-\t\tEC_GROUP_free(group);-\t\tgroup = tmp;-\t}-\t-\tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT;--\tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\");-\tBN_print_fp(stdout, p);-\tfprintf(stdout, \")\\n     a = 0x\");-\tBN_print_fp(stdout, a);-\tfprintf(stdout, \"\\n     b = 0x\");-\tBN_print_fp(stdout, b);-\tfprintf(stdout, \"\\n\");--\tP = EC_POINT_new(group);-\tQ = EC_POINT_new(group);-\tR = EC_POINT_new(group);-\tif (!P || !Q || !R) ABORT;-\t-\tif (!EC_POINT_set_to_infinity(group, P)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\tbuf[0] = 0;-\tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT;--\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\tx = BN_new();-\ty = BN_new();-\tz = BN_new();-\tif (!x || !y || !z) ABORT;--\tif (!BN_hex2bn(&x, \"D\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, Q, ctx))-\t\t{-\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT;-\t\tfprintf(stderr, \"Point is not on curve: x = 0x\");-\t\tBN_print_fp(stderr, x);-\t\tfprintf(stderr, \", y = 0x\");-\t\tBN_print_fp(stderr, y);-\t\tfprintf(stderr, \"\\n\");-\t\tABORT;-\t\t}--\tfprintf(stdout, \"A cyclic subgroup:\\n\");-\tk = 100;-\tdo-\t\t{-\t\tif (k-- == 0) ABORT;--\t\tif (EC_POINT_is_at_infinity(group, P))-\t\t\tfprintf(stdout, \"     point at infinity\\n\");-\t\telse-\t\t\t{-\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;--\t\t\tfprintf(stdout, \"     x = 0x\");-\t\t\tBN_print_fp(stdout, x);-\t\t\tfprintf(stdout, \", y = 0x\");-\t\t\tBN_print_fp(stdout, y);-\t\t\tfprintf(stdout, \"\\n\");-\t\t\t}-\t\t-\t\tif (!EC_POINT_copy(R, P)) ABORT;-\t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;--#if 0 /* optional */-\t\t{-\t\t\tEC_POINT *points[3];-\t\t-\t\t\tpoints[0] = R;-\t\t\tpoints[1] = Q;-\t\t\tpoints[2] = P;-\t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT;-\t\t}-#endif--\t\t}-\twhile (!EC_POINT_is_at_infinity(group, P));--\tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx);-\tif (len == 0) ABORT;-\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;-\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \");-\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);-\t-\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx);-\tif (len == 0) ABORT;-\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;-\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \");-\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);-\t-\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx);-\tif (len == 0) ABORT;-\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;-\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \");-\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);-\t-\tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT;-\tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \", Y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \", Z = 0x\");-\tBN_print_fp(stdout, z);-\tfprintf(stdout, \"\\n\");--\tif (!EC_POINT_invert(group, P, ctx)) ABORT;-\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;---\t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000)-\t * -- not a NIST curve, but commonly used */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT;-\tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT;-\tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;--\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 160) ABORT;-\tfprintf(stdout, \" ok\\n\");-\t-\tgroup_order_tests(group);--\tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_160, group)) ABORT;---\t/* Curve P-192 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;--\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 192) ABORT;-\tfprintf(stdout, \" ok\\n\");-\t-\tgroup_order_tests(group);--\tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_192, group)) ABORT;---\t/* Curve P-224 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT;-\tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;-\t-\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 224) ABORT;-\tfprintf(stdout, \" ok\\n\");-\t-\tgroup_order_tests(group);--\tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_224, group)) ABORT;---\t/* Curve P-256 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\"-\t\t\"84F3B9CAC2FC632551\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;-\t-\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 256) ABORT;-\tfprintf(stdout, \" ok\\n\");-\t-\tgroup_order_tests(group);--\tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_256, group)) ABORT;---\t/* Curve P-384 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\"-\t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\"-\t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\"-\t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;-\t-\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 384) ABORT;-\tfprintf(stdout, \" ok\\n\");--\tgroup_order_tests(group);--\tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_384, group)) ABORT;---\t/* Curve P-521 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\"-\t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\"-\t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\"-\t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\"-\t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\"-\t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\"-\t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\"-\t\t\"7086A272C24088BE94769FD16650\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;-\t-\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 521) ABORT;-\tfprintf(stdout, \" ok\\n\");-- \tgroup_order_tests(group);--\tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_521, group)) ABORT;---\t/* more tests using the last curve */--\tif (!EC_POINT_copy(Q, P)) ABORT;-\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;-\tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */--\tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT;-\tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */--\t{-\t\tconst EC_POINT *points[4];-\t\tconst BIGNUM *scalars[4];-\t\tBIGNUM *scalar3;-\t-\t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;-\t\tpoints[0] = Q;-\t\tpoints[1] = Q;-\t\tpoints[2] = Q;-\t\tpoints[3] = Q;--\t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\t\tif (!BN_add(y, z, BN_value_one())) ABORT;-\t\tif (BN_is_odd(y)) ABORT;-\t\tif (!BN_rshift1(y, y)) ABORT;-\t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */-\t\tscalars[1] = y;--\t\tfprintf(stdout, \"combined multiplication ...\");-\t\tfflush(stdout);--\t\t/* z is still the group order */-\t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT;-\t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT;-\t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;-\t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT;--\t\tfprintf(stdout, \".\");-\t\tfflush(stdout);--\t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT;-\t\tif (!BN_add(z, z, y)) ABORT;-\t\tBN_set_negative(z, 1);-\t\tscalars[0] = y;-\t\tscalars[1] = z; /* z = -(order + y) */--\t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT;-\t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\t\tfprintf(stdout, \".\");-\t\tfflush(stdout);--\t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT;-\t\tif (!BN_add(z, x, y)) ABORT;-\t\tBN_set_negative(z, 1);-\t\tscalars[0] = x;-\t\tscalars[1] = y;-\t\tscalars[2] = z; /* z = -(x+y) */--\t\tscalar3 = BN_new();-\t\tif(!scalar3) ABORT;-\t\tBN_zero(scalar3);-\t\tscalars[3] = scalar3;--\t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT;-\t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\t\tfprintf(stdout, \" ok\\n\\n\");--\t\tBN_free(scalar3);-\t}---#if 0-\ttimings(P_160, TIMING_BASE_PT, ctx);-\ttimings(P_160, TIMING_RAND_PT, ctx);-\ttimings(P_160, TIMING_SIMUL, ctx);-\ttimings(P_192, TIMING_BASE_PT, ctx);-\ttimings(P_192, TIMING_RAND_PT, ctx);-\ttimings(P_192, TIMING_SIMUL, ctx);-\ttimings(P_224, TIMING_BASE_PT, ctx);-\ttimings(P_224, TIMING_RAND_PT, ctx);-\ttimings(P_224, TIMING_SIMUL, ctx);-\ttimings(P_256, TIMING_BASE_PT, ctx);-\ttimings(P_256, TIMING_RAND_PT, ctx);-\ttimings(P_256, TIMING_SIMUL, ctx);-\ttimings(P_384, TIMING_BASE_PT, ctx);-\ttimings(P_384, TIMING_RAND_PT, ctx);-\ttimings(P_384, TIMING_SIMUL, ctx);-\ttimings(P_521, TIMING_BASE_PT, ctx);-\ttimings(P_521, TIMING_RAND_PT, ctx);-\ttimings(P_521, TIMING_SIMUL, ctx);-#endif---\tif (ctx)-\t\tBN_CTX_free(ctx);-\tBN_free(p); BN_free(a);\tBN_free(b);-\tEC_GROUP_free(group);-\tEC_POINT_free(P);-\tEC_POINT_free(Q);-\tEC_POINT_free(R);-\tBN_free(x); BN_free(y); BN_free(z);--\tif (P_160) EC_GROUP_free(P_160);-\tif (P_192) EC_GROUP_free(P_192);-\tif (P_224) EC_GROUP_free(P_224);-\tif (P_256) EC_GROUP_free(P_256);-\tif (P_384) EC_GROUP_free(P_384);-\tif (P_521) EC_GROUP_free(P_521);--\t}+{+    BN_CTX *ctx = NULL;+    BIGNUM *p, *a, *b;+    EC_GROUP *group;+    EC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 =+        NULL, *P_384 = NULL, *P_521 = NULL;+    EC_POINT *P, *Q, *R;+    BIGNUM *x, *y, *z;+    unsigned char buf[100];+    size_t i, len;+    int k;++# if 1                          /* optional */+    ctx = BN_CTX_new();+    if (!ctx)+        ABORT;+# endif++    p = BN_new();+    a = BN_new();+    b = BN_new();+    if (!p || !a || !b)+        ABORT;++    if (!BN_hex2bn(&p, \"17\"))+        ABORT;+    if (!BN_hex2bn(&a, \"1\"))+        ABORT;+    if (!BN_hex2bn(&b, \"1\"))+        ABORT;++    group = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use+                                                 * EC_GROUP_new_curve_GFp so+                                                 * that the library gets to+                                                 * choose the EC_METHOD */+    if (!group)+        ABORT;++    if (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx))+        ABORT;++    {+        EC_GROUP *tmp;+        tmp = EC_GROUP_new(EC_GROUP_method_of(group));+        if (!tmp)+            ABORT;+        if (!EC_GROUP_copy(tmp, group))+            ABORT;+        EC_GROUP_free(group);+        group = tmp;+    }++    if (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx))+        ABORT;++    fprintf(stdout,+            \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\");+    BN_print_fp(stdout, p);+    fprintf(stdout, \")\\n     a = 0x\");+    BN_print_fp(stdout, a);+    fprintf(stdout, \"\\n     b = 0x\");+    BN_print_fp(stdout, b);+    fprintf(stdout, \"\\n\");++    P = EC_POINT_new(group);+    Q = EC_POINT_new(group);+    R = EC_POINT_new(group);+    if (!P || !Q || !R)+        ABORT;++    if (!EC_POINT_set_to_infinity(group, P))+        ABORT;+    if (!EC_POINT_is_at_infinity(group, P))+        ABORT;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -273,495 +273,496 @@ static void prime_field_tests(void) \t{ \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\");  \tgroup_order_tests(group); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[4]; \t\tconst BIGNUM *scalars[4];-\t\tBIGNUM scalar3;+\t\tBIGNUM *scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tpoints[3] = Q; \t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */-\t\tBN_init(&scalar3);-\t\tBN_zero(&scalar3);-\t\tscalars[3] = &scalar3;+\t\tscalar3 = BN_new();+\t\tif(!scalar3) ABORT;+\t\tBN_zero(scalar3);+\t\tscalars[3] = scalar3; \t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\");-\t\tBN_free(&scalar3);+\t\tBN_free(scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2014-10-28 22:58:56+00:00",
            "commit_hash": "5784a52145d0062d42724d4d0fab3b4c82de35ee",
            "message": "Implement internally opaque bn access from ec\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -236,495 +236,495 @@ static void prime_field_tests(void)-\t{\t+\t{ \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\");  \tgroup_order_tests(group); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[4]; \t\tconst BIGNUM *scalars[4]; \t\tBIGNUM scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tpoints[3] = Q; \t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tBN_init(&scalar3); \t\tBN_zero(&scalar3); \t\tscalars[3] = &scalar3; \t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t\tBN_free(&scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2011-10-18 19:43:16+00:00",
            "commit_hash": "3e00b4c9db42818c621f609e70569c7d9ae85717",
            "message": "Improve optional 64-bit NIST-P224 implementation, and add NIST-P256 and\nNIST-P521. (Now -DEC_NISTP_64_GCC_128 enables all three of these;\n-DEC_NISTP224_64_GCC_128 no longer works.)\nSubmitted by: Google Inc."
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -236,495 +236,495 @@-static void prime_field_tests()+static void prime_field_tests(void) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\");  \tgroup_order_tests(group); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[4]; \t\tconst BIGNUM *scalars[4]; \t\tBIGNUM scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tpoints[3] = Q; \t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tBN_init(&scalar3); \t\tBN_zero(&scalar3); \t\tscalars[3] = &scalar3; \t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t\tBN_free(&scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2011-01-09 17:50:06+00:00",
            "commit_hash": "c13d7c02968c17a7c5eb8dca1ace6a916be0de3a",
            "message": "Fix warning."
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -236,495 +236,495 @@-void prime_field_tests()+static void prime_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\");  \tgroup_order_tests(group); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[4]; \t\tconst BIGNUM *scalars[4]; \t\tBIGNUM scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tpoints[3] = Q; \t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tBN_init(&scalar3); \t\tBN_zero(&scalar3); \t\tscalars[3] = &scalar3; \t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t\tBN_free(&scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2010-09-05 16:34:49+00:00",
            "commit_hash": "5df2a2497a3e1ad7d5a386bbe34d3be9eb3a0ba3",
            "message": "Fix warnings."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -198,553 +235,495 @@+ void prime_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \");+\tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \");+\tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \");+\tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\");-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");+\tgroup_order_tests(group); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\");-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");+\tgroup_order_tests(group); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\");-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");+\tgroup_order_tests(group); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\");-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");+\tgroup_order_tests(group); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\");-\t-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");++\tgroup_order_tests(group); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\");-\t-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");++ \tgroup_order_tests(group); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[4]; \t\tconst BIGNUM *scalars[4]; \t\tBIGNUM scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tpoints[3] = Q;+\t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tBN_init(&scalar3); \t\tBN_zero(&scalar3); \t\tscalars[3] = &scalar3; \t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t\tBN_free(&scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2010-08-26 14:29:55+00:00",
            "commit_hash": "04daec862ced4e5e3921724b7a59c432fa9cbab3",
            "message": "New 64-bit optimized implementation EC_GFp_nistp224_method().\nThis will only be compiled in if explicitly requested\n(#ifdef EC_NISTP224_64_GCC_128).\nSubmitted by: Emilia Kasper (Google)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -198,545 +198,553 @@ void prime_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{-\t\tconst EC_POINT *points[3];-\t\tconst BIGNUM *scalars[3];+\t\tconst EC_POINT *points[4];+\t\tconst BIGNUM *scalars[4];+\t\tBIGNUM scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q;+\t\tpoints[3] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */-\t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT;+\t\tBN_init(&scalar3);+\t\tBN_zero(&scalar3);+\t\tscalars[3] = &scalar3;++\t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\");++\t\tBN_free(&scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2007-05-22 09:47:43+00:00",
            "commit_hash": "19f6c524bf78e37ab27cbc53d36655ca709b9675",
            "message": "Fix crypto/ec/ec_mult.c to work properly with scalars of value 0"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -198,545 +198,545 @@ void prime_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT;-\t\tif (!EC_GROUP_copy(tmp, group));+\t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2005-08-28 22:49:57+00:00",
            "commit_hash": "8215e7a93897347a97de87b3d26fe84cc8a5b05d",
            "message": "fix warnings when building openssl with the following compiler options:\n-Wmissing-prototypes -Wcomment -Wformat -Wimplicit -Wmain -Wmultichar\n-Wswitch -Wshadow -Wtrigraphs -Werror -Wchar-subscripts\n-Wstrict-prototypes -Wreturn-type -Wpointer-arith  -W -Wunused\n-Wno-unused-parameter -Wuninitialized"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -193,545 +193,545 @@ void prime_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT;-\t\tBN_set_sign(z, 1);+\t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT;-\t\tBN_set_sign(z, 1);+\t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2005-04-22 20:02:44+00:00",
            "commit_hash": "ff22e913a3fbeb025e612828859102aa1a3effaa",
            "message": "- use BN_set_negative and BN_is_negative instead of BN_set_sign\nand BN_get_sign\n- implement BN_set_negative as a function\n- always use \"#define BN_is_zero(a) ((a)->top == 0)\""
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -179,490 +191,545 @@ void prime_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group;-\tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL;+\tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;+\t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000)+\t * -- not a NIST curve, but commonly used */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT;+\tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT;+\tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;++\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 160) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t+\tfprintf(stdout, \"verify group order ...\");+\tfflush(stdout);+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \" ok\\n\");++\tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_160, group)) ABORT;++ \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_sign(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_sign(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0-\ttimings(P_192, 0, ctx);-\ttimings(P_192, 1, ctx);-\ttimings(P_224, 0, ctx);-\ttimings(P_224, 1, ctx);-\ttimings(P_256, 0, ctx);-\ttimings(P_256, 1, ctx);-\ttimings(P_384, 0, ctx);-\ttimings(P_384, 1, ctx);-\ttimings(P_521, 0, ctx);-\ttimings(P_521, 1, ctx);+\ttimings(P_160, TIMING_BASE_PT, ctx);+\ttimings(P_160, TIMING_RAND_PT, ctx);+\ttimings(P_160, TIMING_SIMUL, ctx);+\ttimings(P_192, TIMING_BASE_PT, ctx);+\ttimings(P_192, TIMING_RAND_PT, ctx);+\ttimings(P_192, TIMING_SIMUL, ctx);+\ttimings(P_224, TIMING_BASE_PT, ctx);+\ttimings(P_224, TIMING_RAND_PT, ctx);+\ttimings(P_224, TIMING_SIMUL, ctx);+\ttimings(P_256, TIMING_BASE_PT, ctx);+\ttimings(P_256, TIMING_RAND_PT, ctx);+\ttimings(P_256, TIMING_SIMUL, ctx);+\ttimings(P_384, TIMING_BASE_PT, ctx);+\ttimings(P_384, TIMING_RAND_PT, ctx);+\ttimings(P_384, TIMING_SIMUL, ctx);+\ttimings(P_521, TIMING_BASE_PT, ctx);+\ttimings(P_521, TIMING_RAND_PT, ctx);+\ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z);+\tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2003-07-22 10:39:10+00:00",
            "commit_hash": "652ae06badda3a8964f650ce1713e335257548d9",
            "message": "add test for secp160r1\nadd code for kP+lQ timings\nSubmitted by: Douglas Stebila <douglas.stebila@sun.com>\nReviewed by: Bodo Moeller"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -177,490 +177,490 @@ void prime_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_sign(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_sign(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2002-12-08 05:24:31+00:00",
            "commit_hash": "e9224c717711eefb30038c9b37c69795dda93c9a",
            "message": "This is a first-cut at improving the callback mechanisms used in\nkey-generation and prime-checking functions. Rather than explicitly passing\ncallback functions and caller-defined context data for the callbacks, a new\nstructure BN_GENCB is defined that encapsulates this; a pointer to the\nstructure is passed to all such functions instead.\nThis wrapper structure allows the encapsulation of \"old\" and \"new\" style\ncallbacks - \"new\" callbacks return a boolean result on the understanding\nthat returning FALSE should terminate keygen/primality processing.  The\nBN_GENCB abstraction will allow future callback modifications without\nneeding to break binary compatibility nor change the API function\nprototypes. The new API functions have been given names ending in \"_ex\" and\nthe old functions are implemented as wrappers to the new ones.  The\nOPENSSL_NO_DEPRECATED symbol has been introduced so that, if defined,\ndeclaration of the older functions will be skipped. NB: Some\nopenssl-internal code will stick with the older callbacks for now, so\nappropriate \"#undef\" logic will be put in place - this is in case the user\nis *building* openssl (rather than *including* its headers) with this\nsymbol defined.\nThere is another change in the new _ex functions; the key-generation\nfunctions do not return key structures but operate on structures passed by\nthe caller, the return value is a boolean. This will allow for a smoother\ntransition to having key-generation as \"virtual function\" in the various\n***_METHOD tables."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -170,490 +170,490 @@ void prime_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT;-\t\tz->neg = 1;+\t\tBN_set_sign(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT;-\t\tz->neg = 1;+\t\tBN_set_sign(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2002-11-04 13:17:22+00:00",
            "commit_hash": "b53e44e57259b2b015c54de8ecbcf4e06be23298",
            "message": "implement and use new macros BN_get_sign(), BN_set_sign()\nSubmitted by: Nils Larsch"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -143,483 +177,490 @@-int main(int argc, char *argv[])+void prime_field_tests() \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k;-\t/* enable memory leak checking unless explicitly disabled */-\tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\"))))-\t\t{-\t\tCRYPTO_malloc_debug_init();-\t\tCRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);-\t\t}-\telse-\t\t{-\t\t/* OPENSSL_DEBUG_MEMORY=off */-\t\tCRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0);-\t\t}-\tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);-\tERR_load_crypto_strings();- #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;++\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 192) ABORT;+\tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;+\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 224) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;+\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 256) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;+\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 384) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;+\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 521) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);+\t}",
            "commit_date": "2002-08-02 13:42:24+00:00",
            "commit_hash": "7793f30e09c104b209206608a20f2088b1b635fd",
            "message": "add support for elliptic curves over binary fields\nSubmitted by: Duglas Stebila <douglas.stebila@sun.com>,\nSheueling Chang <sheueling.chang@sun.com>\n(CHANGES entries by Bodo Moeller)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -143,478 +143,483 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init();-\t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);+\t\tCRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);+\t\t}+\telse+\t\t{+\t\t/* OPENSSL_DEBUG_MEMORY=off */+\t\tCRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2002-02-14 14:41:13+00:00",
            "commit_hash": "8f06b003736c957c6e693d3b5dd1393f91a530cd",
            "message": "make it possible to disable memory checking for timings"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -143,478 +143,478 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t}-#if 1+#if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-12-17 19:26:43+00:00",
            "commit_hash": "1226c472b7f6f1b211b306eb3ac937f546573dd3",
            "message": "oops"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -143,478 +143,478 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t}-#if 0+#if 1 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-12-17 19:22:23+00:00",
            "commit_hash": "4d7072f4b5b536c080854eba4b0092d80adf4d37",
            "message": "remove redundant ERR_load_... declarations"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -143,478 +143,478 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT;-\t\tif (!BN_copy(z, y)) ABORT;+\t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y;-\t\tscalars[1] = z; /* z = -y */+\t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-11-16 06:22:05+00:00",
            "commit_hash": "752938daabf4279b6983721f3af0c94889b82eed",
            "message": "use a more interesting test case"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -143,478 +143,478 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y;-\t\tfprintf(stdout, \"simultaneous multiplication ...\");+\t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-07-10 11:41:29+00:00",
            "commit_hash": "9c10b2c8d314db4efe3be8d1439411563bb0a5c0",
            "message": "For consistency with the terminology used in my SAC2001 paper, avoid\nthe term \"simultaneous multiplication\" (which -- acording to the\npaper, at least -- applies only to certain methods which we don't use\nhere)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -141,474 +141,478 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len;+\tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\");+\tk = 100; \tdo \t\t{+\t\tif (k-- == 0) ABORT;+ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-15 11:31:37+00:00",
            "commit_hash": "63c43dcc5953a98c14fef2e381bb159ede883a5c",
            "message": "avoid infinite loop"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -141,474 +141,474 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-12 07:26:23+00:00",
            "commit_hash": "194dd04699f03af4cf7f7f88ecf31f243a19552b",
            "message": "Rename function EC_GROUP_precompute to EC_GROUP_precompute_mult,\nwhich indicate its purpose more clearly."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -141,468 +141,474 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len;+\t/* enable memory leak checking unless explicitly disabled */+\tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\"))))+\t\t{+\t\tCRYPTO_malloc_debug_init();+\t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);+\t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 14:49:46+00:00",
            "commit_hash": "10654d3a745a314e9961e62bc25f4a9fbb4a15b3",
            "message": "Forcibly enable memory leak checking during \"make test\""
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -141,468 +141,468 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t}-#if 1+#if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 12:30:52+00:00",
            "commit_hash": "6017e604f8367050d377af766e4242564675f774",
            "message": "Timings are not supposed to be enabled by default ..."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -146,433 +141,468 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");+\tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");-\t+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \" ok\\n\");+ \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");-\t+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \" ok\\n\");+ \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");-\t+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \" ok\\n\");+ \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");+\tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{-\t\tEC_POINT *points[2];-\t\tBIGNUM *scalars[2];+\t\tconst EC_POINT *points[3];+\t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;+\t\tpoints[0] = Q;+\t\tpoints[1] = Q;+\t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT;--\t\tpoints[0] = Q;-\t\tpoints[1] = Q; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1;--\t\tpoints[0] = Q;-\t\tpoints[1] = Q; \t\tscalars[0] = y;-\t\tscalars[1] = z;+\t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;+\t\tfprintf(stdout, \".\");+\t\tfflush(stdout);++\t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT;+\t\tif (!BN_add(z, x, y)) ABORT;+\t\tz->neg = 1;+\t\tscalars[0] = x;+\t\tscalars[1] = y;+\t\tscalars[2] = z; /* z = -(x+y) */++\t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT;+\t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;+ \t\tfprintf(stdout, \" ok\\n\\n\"); \t}-#if 0+#if 1 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 12:27:24+00:00",
            "commit_hash": "3837491174ececd6ff1b0dcdda754443f89a7699",
            "message": "Add functions EC_POINT_mul and EC_GROUP_precompute.\nThe latter does nothing for now, but its existence means\nthat applications can request precomputation when appropriate."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -146,418 +146,433 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tEC_POINT *points[2]; \t\tBIGNUM *scalars[2]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y;-\t\tfprintf(stdout, \"simultaneous multiplication ... \");+\t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT;-\t\tfprintf(stdout, \"ok\\n\\n\");+\t\tfprintf(stdout, \".\");+\t\tfflush(stdout);++\t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT;+\t\tif (!BN_copy(z, y)) ABORT;+\t\tz->neg = 1;++\t\tpoints[0] = Q;+\t\tpoints[1] = Q;+\t\tscalars[0] = y;+\t\tscalars[1] = z;++\t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT;+\t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;++\t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 08:44:50+00:00",
            "commit_hash": "86a921af06f52d1b16fbc8a76d8f0ff1950d1c8a",
            "message": "handle negative scalars correctly when doing point multiplication"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -146,412 +146,418 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tEC_POINT *points[2]; \t\tBIGNUM *scalars[2]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ... \");+\t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \"ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 08:27:11+00:00",
            "commit_hash": "616df356332246c891fb1a650fef54ee211cafd3",
            "message": "use fflush"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -146,404 +146,412 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tEC_POINT *points[2]; \t\tBIGNUM *scalars[2]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ... \"); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \"ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx);+\ttimings(P_224, 0, ctx);+\ttimings(P_224, 1, ctx);+\ttimings(P_256, 0, ctx);+\ttimings(P_256, 1, ctx);+\ttimings(P_384, 0, ctx);+\ttimings(P_384, 1, ctx);+\ttimings(P_521, 0, ctx);+\ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-10 23:49:06+00:00",
            "commit_hash": "e44fcedadf77c9d4d44b636d69e7927de5b2df14",
            "message": "Change timing output: We don't have \"exponents\" here, curves are\nconsidered additive"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -74,144 +146,404 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group;+\tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings();-#if 0 /* optional */+#if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT;-\tgroup = EC_GROUP_new(EC_GFp_mont_method());+\tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp+\t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT;+ \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\t{+\t\tEC_GROUP *tmp;+\t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group));+\t\tif (!tmp) ABORT;+\t\tif (!EC_GROUP_copy(tmp, group));+\t\tEC_GROUP_free(group);+\t\tgroup = tmp;+\t}+\t \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */-\t\tif (!EC_POINT_make_affine(group, P, ctx)) ABORT;+\t\t{+\t\t\tEC_POINT *points[3];+\t\t+\t\t\tpoints[0] = R;+\t\t\tpoints[1] = Q;+\t\t\tpoints[2] = P;+\t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT;+\t\t} #endif+ \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;-\t/* ... */++\t/* Curve P-192 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");++\tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_192, group)) ABORT;+++\t/* Curve P-224 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT;+\tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");+\t+\tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_224, group)) ABORT;+++\t/* Curve P-256 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\"+\t\t\"84F3B9CAC2FC632551\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");+\t+\tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_256, group)) ABORT;+++\t/* Curve P-384 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\"+\t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\"+\t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\"+\t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");+\t+\tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_384, group)) ABORT;+++\t/* Curve P-521 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\"+\t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\"+\t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\"+\t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\"+\t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\"+\t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\"+\t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\"+\t\t\"7086A272C24088BE94769FD16650\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");++\tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_521, group)) ABORT;+++\t/* more tests using the last curve */++\tif (!EC_POINT_copy(Q, P)) ABORT;+\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;+\tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */++\tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT;+\tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */++\t{+\t\tEC_POINT *points[2];+\t\tBIGNUM *scalars[2];+\t+\t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;++\t\tif (!BN_add(y, z, BN_value_one())) ABORT;+\t\tif (BN_is_odd(y)) ABORT;+\t\tif (!BN_rshift1(y, y)) ABORT;++\t\tpoints[0] = Q;+\t\tpoints[1] = Q;+\t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */+\t\tscalars[1] = y;++\t\tfprintf(stdout, \"simultaneous multiplication ... \");++\t\t/* z is still the group order */+\t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT;+\t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT;+\t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;+\t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT;++\t\tfprintf(stdout, \"ok\\n\\n\");+\t}+++#if 0+\ttimings(P_192, 0, ctx);+\ttimings(P_192, 1, ctx);+#endif+ \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z);+\tif (P_192) EC_GROUP_free(P_192);+\tif (P_224) EC_GROUP_free(P_224);+\tif (P_256) EC_GROUP_free(P_256);+\tif (P_384) EC_GROUP_free(P_384);+\tif (P_521) EC_GROUP_free(P_521);+",
            "commit_date": "2001-03-10 23:18:35+00:00",
            "commit_hash": "48fe4d6233ac2d60745742a27f820dd88bc6689d",
            "message": "More EC stuff, including EC_POINTs_mul() for simultaneous scalar\nmultiplication of an arbitrary number of points."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -74,144 +74,144 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 0 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT;-\tif (!BN_hex2bn(&p, \"D\")) ABORT;-\tif (!BN_hex2bn(&a, \"7\")) ABORT;-\tif (!BN_hex2bn(&b, \"C\")) ABORT;+\tif (!BN_hex2bn(&p, \"17\")) ABORT;+\tif (!BN_hex2bn(&a, \"1\")) ABORT;+\tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT;-\tif (!BN_hex2bn(&x, \"C\")) ABORT;+\tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\tif (!EC_POINT_make_affine(group, P, ctx)) ABORT; #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* ... */ \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z);",
            "commit_date": "2001-03-08 22:52:49+00:00",
            "commit_hash": "42909e39681bcbaaada696c901bbff472d71dbe2",
            "message": "Fix ec_GFp_simple_cmp.\nUse example group from Annex I of X9.62 in ectest.c."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -74,139 +74,144 @@ int main(int argc, char *argv[]) \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 0 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"D\")) ABORT; \tif (!BN_hex2bn(&a, \"7\")) ABORT; \tif (!BN_hex2bn(&b, \"C\")) ABORT;-\tgroup = EC_GROUP_new_curve_GFp(p, a, b, NULL);+\tgroup = EC_GROUP_new(EC_GFp_mont_method()); \tif (!group) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;+\tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"C\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{-\t\tfprintf(stderr, \"Point is not on curve, x = 0x\");+\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT;+\t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x);+\t\tfprintf(stderr, \", y = 0x\");+\t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\tif (!EC_POINT_make_affine(group, P, ctx)) ABORT; #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* ... */ \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z);",
            "commit_date": "2001-03-08 20:55:16+00:00",
            "commit_hash": "156e85578d180313c27e51d0bf186aa8650c49e1",
            "message": "Implement EC_GFp_mont_method."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -70,11 +74,139 @@ int main(int argc, char *argv[]) \t{\t+\tBN_CTX *ctx = NULL;+\tBIGNUM *p, *a, *b; \tEC_GROUP *group;-+\tEC_POINT *P, *Q, *R;+\tBIGNUM *x, *y, *z;+\tunsigned char buf[100];+\tsize_t i, len;+\t+\tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings();-#if 0-\tgroup = EC_GROUP_new(NULL);+#if 0 /* optional */+\tctx = BN_CTX_new();+\tif (!ctx) ABORT;+#endif++\tp = BN_new();+\ta = BN_new();+\tb = BN_new();+\tif (!p || !a || !b) ABORT;++\tif (!BN_hex2bn(&p, \"D\")) ABORT;+\tif (!BN_hex2bn(&a, \"7\")) ABORT;+\tif (!BN_hex2bn(&b, \"C\")) ABORT;+\t+\tgroup = EC_GROUP_new_curve_GFp(p, a, b, NULL); \tif (!group) ABORT;++\tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\");+\tBN_print_fp(stdout, p);+\tfprintf(stdout, \")\\n     a = 0x\");+\tBN_print_fp(stdout, a);+\tfprintf(stdout, \"\\n     b = 0x\");+\tBN_print_fp(stdout, b);+\tfprintf(stdout, \"\\n\");++\tP = EC_POINT_new(group);+\tQ = EC_POINT_new(group);+\tR = EC_POINT_new(group);+\tif (!P || !Q || !R) ABORT;+\t+\tif (!EC_POINT_set_to_infinity(group, P)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;++\tbuf[0] = 0;+\tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT;++\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;++\tx = BN_new();+\ty = BN_new();+\tz = BN_new();+\tif (!x || !y || !z) ABORT;++\tif (!BN_hex2bn(&x, \"C\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, Q, ctx))+\t\t{+\t\tfprintf(stderr, \"Point is not on curve, x = 0x\");+\t\tBN_print_fp(stderr, x);+\t\tfprintf(stderr, \"\\n\");+\t\tABORT;+\t\t}++\tfprintf(stdout, \"A cyclic subgroup:\\n\");+\tdo+\t\t{+\t\tif (EC_POINT_is_at_infinity(group, P))+\t\t\tfprintf(stdout, \"     point at infinity\\n\");+\t\telse+\t\t\t{+\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;++\t\t\tfprintf(stdout, \"     x = 0x\");+\t\t\tBN_print_fp(stdout, x);+\t\t\tfprintf(stdout, \", y = 0x\");+\t\t\tBN_print_fp(stdout, y);+\t\t\tfprintf(stdout, \"\\n\");+\t\t\t}+\t\t+\t\tif (!EC_POINT_copy(R, P)) ABORT;+\t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;++#if 0 /* optional */+\t\tif (!EC_POINT_make_affine(group, P, ctx)) ABORT; #endif+\t\t}+\twhile (!EC_POINT_is_at_infinity(group, P));++\tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;+\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx);+\tif (len == 0) ABORT;+\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;+\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;+\tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \");+\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);+\t+\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx);+\tif (len == 0) ABORT;+\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;+\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;+\tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \");+\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);+\t+\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx);+\tif (len == 0) ABORT;+\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;+\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;+\tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \");+\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);+\t+\tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT;+\tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \", Y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \", Z = 0x\");+\tBN_print_fp(stdout, z);+\tfprintf(stdout, \"\\n\");++\tif (!EC_POINT_invert(group, P, ctx)) ABORT;+\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;++\t/* ... */++\tif (ctx)+\t\tBN_CTX_free(ctx);+\tBN_free(p); BN_free(a);\tBN_free(b);+\tEC_GROUP_free(group);+\tEC_POINT_free(P);+\tEC_POINT_free(Q);+\tEC_POINT_free(R);+\tBN_free(x); BN_free(y); BN_free(z);+",
            "commit_date": "2001-03-08 19:14:52+00:00",
            "commit_hash": "bb62a8b0c57c88ec189389f07250dee9c87d0681",
            "message": "More method functions for elliptic curves,\nand an ectest.c that actually tests something."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -58,0 +70,11 @@+int main(int argc, char *argv[])+\t{\t+\tEC_GROUP *group;++\tERR_load_crypto_strings();++#if 0+\tgroup = EC_GROUP_new(NULL);+\tif (!group) ABORT;+#endif+",
            "commit_date": "2001-03-08 11:59:48+00:00",
            "commit_hash": "adfe54b7beb931fa0a717fc2831bada8b4f4fa16",
            "message": "Integrate ectest.c (which does not yet do anything)."
        }
    ],
    "git log -L2962,2973:test/bntest.c": [
        {
            "author": {
                "email": "bernd.edlinger@hotmail.de",
                "name": "Bernd Edlinger"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -2487,0 +2696,12 @@++static int test_mod_exp(int i)+{+    const MOD_EXP_TEST *test = &ModExpTests[i];+    int res = 0;+    BIGNUM* result = NULL;+    BIGNUM *base = NULL, *exponent = NULL, *modulo = NULL;+    char *s = NULL;++    if (!TEST_ptr(result = BN_new())+            || !TEST_true(BN_dec2bn(&base, test->base))+            || !TEST_true(BN_dec2bn(&exponent, test->exp))",
            "commit_date": "2019-12-04 22:38:19+01:00",
            "commit_hash": "18d42d8d56352b81510d87dd12d1ac93d1d408d3",
            "message": "Add a test case for rsaz_512_sqr overflow handling\n[extended tests]\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/10574)"
        }
    ],
    "git log -L400,427:test/test_test.c": [
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/test_test.c b/test/test_test.c--- a/test/test_test.c+++ b/test/test_test.c@@ -376,1 +379,28 @@+static int test_long_bignum(void)+{+    int r;+    BIGNUM *a = NULL, *b = NULL, *c = NULL, *d = NULL;+    const char as[] = \"1234567890123456789012345678901234567890123456789012\"+                      \"1234567890123456789012345678901234567890123456789012\"+                      \"1234567890123456789012345678901234567890123456789012\"+                      \"1234567890123456789012345678901234567890123456789012\"+                      \"1234567890123456789012345678901234567890123456789012\"+                      \"1234567890123456789012345678901234567890123456789012\"+                      \"FFFFFF\";+    const char bs[] = \"1234567890123456789012345678901234567890123456789012\"+                      \"1234567890123456789012345678901234567890123456789013\"+                      \"987657\";+    const char cs[] = \"-\"        /* 64 characters plus sign */+                      \"123456789012345678901234567890\"+                      \"123456789012345678901234567890\"+                      \"ABCD\";+    const char ds[] = \"-\"        /* 63 characters plus sign */+                      \"23456789A123456789B123456789C\"+                      \"123456789D123456789E123456789F\"+                      \"ABCD\";++    r = TEST_true(BN_hex2bn(&a, as))+        && TEST_true(BN_hex2bn(&b, bs))+        && TEST_true(BN_hex2bn(&c, cs))+        && TEST_true(BN_hex2bn(&d, ds))",
            "commit_date": "2017-05-15 08:49:36+10:00",
            "commit_hash": "ffbaf06ade6dab6a0805a24087cf2e84c5db8d43",
            "message": "Reformat the output of BIGNUMS where test cases fail.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Andy Polyakov <appro@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3465)"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/test_test.c b/test/test_test.c--- a/test/test_test.c+++ b/test/test_test.c@@ -281,0 +307,1 @@+",
            "commit_date": "2017-05-02 14:46:02+10:00",
            "commit_hash": "516decaef31a13e5bf1b6f855dc0fefe23d7eed9",
            "message": "Test framework output improvement.\nFormat the test failure output more nicely.\nMore vertical space is used to make things a little clearer.  Tests are expected\nto pass so this doesn't impact the normal case.\nStrings and memory comparisons highlight differences.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3357)"
        }
    ],
    "git log -L1987,1993:test/bntest.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1837,6 +1967,7 @@+ static int test_dec2bn(void) {",
            "commit_date": "2021-11-25 18:00:16+01:00",
            "commit_hash": "5288303da96084b41b062d99eb37177fb4cf471e",
            "message": "TEST: Add a test of the new BN_signed set of functions in test/bntest.c\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/17139)\nBIGNUM *bn = NULL;\nint st = 0;\nif (!TEST_int_eq(parsedecBN(&bn, \"0\"), 1)"
        },
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1506,6 +1506,6 @@-static int test_dec2bn()+static int test_dec2bn(void) {",
            "commit_date": "2017-08-15 23:39:03+02:00",
            "commit_hash": "31a80694d425bf7f3a0ed5cc2ee775d9418a5490",
            "message": "[Win] Fix some test method signatures ...\nto halves MSVC warnings.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4172)\nBIGNUM *bn = NULL;\nint st = 0;\nif (!TEST_int_eq(parsedecBN(&bn, \"0\"), 1)"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1614,8 +1535,6 @@ static int test_dec2bn() {-    int ret = parsedecBN(&bn, \"0\");-    if (ret != 1 || !BN_is_zero(bn) || BN_is_negative(bn)) {-        fprintf(stderr, \"BN_dec2bn(0) gave a bad result.\\n\");+    if (!TEST_int_eq(parsedecBN(&bn, \"0\"), 1)",
            "commit_date": "2017-04-26 12:39:46-04:00",
            "commit_hash": "30bea14be6bbf77ed60acb9bd1befeb51d4c4b10",
            "message": "Convert bntest to TEST_ framework\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3265)\nBIGNUM *bn = NULL;\nint st = 0;"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1650,13 +1527,8 @@-    char c = '*';--    if (p == 0)-        c = '.';-    if (p == 1)-        c = '+';-    if (p == 2)-        c = '*';-    if (p == 3)-        c = '\\n';-    putc(c, stderr);-    fflush(stderr);-    return 1;+static int test_dec2bn()+{+    BIGNUM *bn = NULL;+    int st = 0;++    int ret = parsedecBN(&bn, \"0\");+    if (ret != 1 || !BN_is_zero(bn) || BN_is_negative(bn)) {+        fprintf(stderr, \"BN_dec2bn(0) gave a bad result.\\n\");",
            "commit_date": "2016-11-28 12:26:05-05:00",
            "commit_hash": "8d1ebff41c75e4eebc7d5cc5a561a1bab6b50e70",
            "message": "Make bntest be (mostly) file-based.\nTest suite used from boring, written by David Benjamin.\nTest driver converted from C++ to C.\nAdded a Perl program to check the testsuite file.\nExtensive review feedback incorporated (thanks folks).\nReviewed-by: Emilia K\u00e4sper <emilia@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -1784,11 +1713,13 @@-\t{-\tchar c='*';--\tif (p == 0) c='.';-\tif (p == 1) c='+';-\tif (p == 2) c='*';-\tif (p == 3) c='\\n';-\tputc(c, stderr);-\tfflush(stderr);-\treturn 1;-\t}+    char c = '*';++    if (p == 0)+        c = '.';+    if (p == 1)+        c = '+';+    if (p == 2)+        c = '*';+    if (p == 3)+        c = '\\n';+    putc(c, stderr);+    fflush(stderr);+    return 1;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -1506,12 +1506,11 @@ \t{ \tchar c='*'; \tif (p == 0) c='.'; \tif (p == 1) c='+'; \tif (p == 2) c='*'; \tif (p == 3) c='\\n'; \tputc(c, stderr); \tfflush(stderr);-\t(void)n;-\t(void)arg;+\treturn 1; \t}",
            "commit_date": "2003-10-29 04:14:08+00:00",
            "commit_hash": "2aaec9cced89edfdc8375b38a130fa1c35a98025",
            "message": "Update any code that was using deprecated functions so that everything builds\nand links with OPENSSL_NO_DEPRECATED defined."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -903,0 +904,12 @@+\t{+\tchar c='*';++\tif (p == 0) c='.';+\tif (p == 1) c='+';+\tif (p == 2) c='*';+\tif (p == 3) c='\\n';+\tputc(c, stderr);+\tfflush(stderr);+\t(void)n;+\t(void)arg;+\t}",
            "commit_date": "2000-11-29 11:06:50+00:00",
            "commit_hash": "bdec3c5323c7a726814257ec9b43fcd259f4e206",
            "message": "Implement BN_kronecker test.\nModify \"CHANGES\" entry for BN_mod_inverse (it's not just avoiding BN_div\nthat increases performance, avoiding BN_mul also helps)"
        }
    ],
    "git log -L1086,1096:test/ectest.c": [
        {
            "author": {
                "email": "tb@openbsd.org",
                "name": "Theo Buehler"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1086,0 +1086,11 @@++static int hybrid_point_encoding_test(void)+{+    BIGNUM *x = NULL, *y = NULL;+    EC_GROUP *group = NULL;+    EC_POINT *point = NULL;+    unsigned char *buf = NULL;+    size_t len;+    int r = 0;++    if (!TEST_true(BN_dec2bn(&x, \"0\"))",
            "commit_date": "2021-05-01 13:09:10+02:00",
            "commit_hash": "e70abb8b4cb3b6259812137f72efa100797bca22",
            "message": "Test oct2point for hybrid point encoding of (0, y)\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15108)"
        }
    ],
    "git log -L198,215:test/asn1_decode_test.c": [
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/asn1_decode_test.c b/test/asn1_decode_test.c--- a/test/asn1_decode_test.c+++ b/test/asn1_decode_test.c@@ -197,1 +198,18 @@+static int test_reuse_asn1_object(void)+{+    static unsigned char cn_der[] = { 0x06, 0x03, 0x55, 0x04, 0x06 };+    static unsigned char oid_der[] = {+        0x06, 0x06, 0x2a, 0x03, 0x04, 0x05, 0x06, 0x07+    };+    int ret = 0;+    ASN1_OBJECT *obj;+    unsigned char const *p = oid_der;++    /* Create an object that owns dynamically allocated 'sn' and 'ln' fields */++    if (!TEST_ptr(obj = ASN1_OBJECT_create(NID_undef, cn_der, sizeof(cn_der),+                                           \"C\", \"countryName\")))+        goto err;+    /* reuse obj - this should not leak sn and ln */+    if (!TEST_ptr(d2i_ASN1_OBJECT(&obj, &p, sizeof(oid_der))))",
            "commit_date": "2021-04-21 13:49:29+10:00",
            "commit_hash": "e466dc3646bc15fa928366a2c64ed987daab5b2c",
            "message": "Test that we don't have a memory leak in d2i_ASN1_OBJECT.\nFixes #14667\nReworked test supplied by @smcpeak into a unit test.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14938)\n(cherry picked from commit 7c65179ad95d0f6f598ee82e763fce2567fe5802)"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/asn1_decode_test.c b/test/asn1_decode_test.c--- a/test/asn1_decode_test.c+++ b/test/asn1_decode_test.c@@ -163,0 +197,1 @@+",
            "commit_date": "2020-11-30 14:46:47+00:00",
            "commit_hash": "22b88fc9c0e22545401c0b34d24843883ea73fec",
            "message": "Add a test for encoding/decoding using an invalid ASN.1 Template\nIf you have a CHOICE type that it must use explicit tagging - otherwise\nthe template is invalid. We add tests for this.\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>"
        }
    ],
    "git log -L790,802:test/ectest.c": [
        {
            "author": {
                "email": "bbrumley@gmail.com",
                "name": "Billy Brumley"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -808,12 +822,13 @@+# endif",
            "commit_date": "2020-05-13 07:33:59+03:00",
            "commit_hash": "4fcd15c18ad6b5523a389863d3e5628d44db6eb4",
            "message": "deprecate EC_POINTs_mul function\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/11807)\nstruct c2_curve_test *const test = char2_curve_tests + n;\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_ptr(x = BN_new())\n|| !TEST_ptr(y = BN_new())\n|| !TEST_ptr(z = BN_new())\n|| !TEST_ptr(yplusone = BN_new())\n|| !TEST_true(BN_hex2bn(&p, test->p))\n|| !TEST_true(BN_hex2bn(&a, test->a))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -797,3 +860,12 @@-        const EC_POINT *points[4];-        const BIGNUM *scalars[4];-        BIGNUM *scalar3;+    struct c2_curve_test *const test = char2_curve_tests + n;++    if (!TEST_ptr(ctx = BN_CTX_new())+        || !TEST_ptr(p = BN_new())+        || !TEST_ptr(a = BN_new())+        || !TEST_ptr(b = BN_new())+        || !TEST_ptr(x = BN_new())+        || !TEST_ptr(y = BN_new())+        || !TEST_ptr(z = BN_new())+        || !TEST_ptr(yplusone = BN_new())+        || !TEST_true(BN_hex2bn(&p, test->p))+        || !TEST_true(BN_hex2bn(&a, test->a))",
            "commit_date": "2017-04-28 14:06:11+10:00",
            "commit_hash": "2db85ac97a5dda90249f5e630e7b29c4196fc397",
            "message": "Conversion of the EC tests to use the framework.\nSome refactoring done as well.\nThe prime_field_tests() function needs splitting and refactoring still.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3340)"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -273,494 +876,3 @@-\t{-\tBN_CTX *ctx = NULL;-\tBIGNUM *p, *a, *b;-\tEC_GROUP *group;-\tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL;-\tEC_POINT *P, *Q, *R;-\tBIGNUM *x, *y, *z;-\tunsigned char buf[100];-\tsize_t i, len;-\tint k;-\t-#if 1 /* optional */-\tctx = BN_CTX_new();-\tif (!ctx) ABORT;-#endif--\tp = BN_new();-\ta = BN_new();-\tb = BN_new();-\tif (!p || !a || !b) ABORT;--\tif (!BN_hex2bn(&p, \"17\")) ABORT;-\tif (!BN_hex2bn(&a, \"1\")) ABORT;-\tif (!BN_hex2bn(&b, \"1\")) ABORT;-\t-\tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp-\t                                             * so that the library gets to choose the EC_METHOD */-\tif (!group) ABORT;--\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\t{-\t\tEC_GROUP *tmp;-\t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group));-\t\tif (!tmp) ABORT;-\t\tif (!EC_GROUP_copy(tmp, group)) ABORT;-\t\tEC_GROUP_free(group);-\t\tgroup = tmp;-\t}-\t-\tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT;--\tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\");-\tBN_print_fp(stdout, p);-\tfprintf(stdout, \")\\n     a = 0x\");-\tBN_print_fp(stdout, a);-\tfprintf(stdout, \"\\n     b = 0x\");-\tBN_print_fp(stdout, b);-\tfprintf(stdout, \"\\n\");--\tP = EC_POINT_new(group);-\tQ = EC_POINT_new(group);-\tR = EC_POINT_new(group);-\tif (!P || !Q || !R) ABORT;-\t-\tif (!EC_POINT_set_to_infinity(group, P)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\tbuf[0] = 0;-\tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT;--\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\tx = BN_new();-\ty = BN_new();-\tz = BN_new();-\tif (!x || !y || !z) ABORT;--\tif (!BN_hex2bn(&x, \"D\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, Q, ctx))-\t\t{-\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT;-\t\tfprintf(stderr, \"Point is not on curve: x = 0x\");-\t\tBN_print_fp(stderr, x);-\t\tfprintf(stderr, \", y = 0x\");-\t\tBN_print_fp(stderr, y);-\t\tfprintf(stderr, \"\\n\");-\t\tABORT;-\t\t}--\tfprintf(stdout, \"A cyclic subgroup:\\n\");-\tk = 100;-\tdo-\t\t{-\t\tif (k-- == 0) ABORT;--\t\tif (EC_POINT_is_at_infinity(group, P))-\t\t\tfprintf(stdout, \"     point at infinity\\n\");-\t\telse-\t\t\t{-\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;--\t\t\tfprintf(stdout, \"     x = 0x\");-\t\t\tBN_print_fp(stdout, x);-\t\t\tfprintf(stdout, \", y = 0x\");-\t\t\tBN_print_fp(stdout, y);-\t\t\tfprintf(stdout, \"\\n\");-\t\t\t}-\t\t-\t\tif (!EC_POINT_copy(R, P)) ABORT;-\t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;--#if 0 /* optional */-\t\t{-\t\t\tEC_POINT *points[3];-\t\t-\t\t\tpoints[0] = R;-\t\t\tpoints[1] = Q;-\t\t\tpoints[2] = P;-\t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT;-\t\t}-#endif--\t\t}-\twhile (!EC_POINT_is_at_infinity(group, P));--\tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx);-\tif (len == 0) ABORT;-\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;-\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \");-\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);-\t-\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx);-\tif (len == 0) ABORT;-\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;-\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \");-\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);-\t-\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx);-\tif (len == 0) ABORT;-\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;-\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \");-\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);-\t-\tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT;-\tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \", Y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \", Z = 0x\");-\tBN_print_fp(stdout, z);-\tfprintf(stdout, \"\\n\");--\tif (!EC_POINT_invert(group, P, ctx)) ABORT;-\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;---\t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000)-\t * -- not a NIST curve, but commonly used */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT;-\tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT;-\tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;--\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 160) ABORT;-\tfprintf(stdout, \" ok\\n\");-\t-\tgroup_order_tests(group);--\tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_160, group)) ABORT;---\t/* Curve P-192 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;--\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 192) ABORT;-\tfprintf(stdout, \" ok\\n\");-\t-\tgroup_order_tests(group);--\tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_192, group)) ABORT;---\t/* Curve P-224 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT;-\tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;-\t-\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 224) ABORT;-\tfprintf(stdout, \" ok\\n\");-\t-\tgroup_order_tests(group);--\tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_224, group)) ABORT;---\t/* Curve P-256 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\"-\t\t\"84F3B9CAC2FC632551\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;-\t-\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 256) ABORT;-\tfprintf(stdout, \" ok\\n\");-\t-\tgroup_order_tests(group);--\tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_256, group)) ABORT;---\t/* Curve P-384 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\"-\t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\"-\t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\"-\t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;-\t-\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 384) ABORT;-\tfprintf(stdout, \" ok\\n\");--\tgroup_order_tests(group);--\tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_384, group)) ABORT;---\t/* Curve P-521 (FIPS PUB 186-2, App. 6) */-\t-\tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT;-\tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\"-\t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\"-\t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;--\tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\"-\t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\"-\t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT;-\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"-\t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\"-\t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT;-\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;--\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;-\tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\");-\tBN_print_fp(stdout, x);-\tfprintf(stdout, \"\\n     y = 0x\");-\tBN_print_fp(stdout, y);-\tfprintf(stdout, \"\\n\");-\t/* G_y value taken from the standard: */-\tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\"-\t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\"-\t\t\"7086A272C24088BE94769FD16650\")) ABORT;-\tif (0 != BN_cmp(y, z)) ABORT;-\t-\tfprintf(stdout, \"verify degree ...\");-\tif (EC_GROUP_get_degree(group) != 521) ABORT;-\tfprintf(stdout, \" ok\\n\");-- \tgroup_order_tests(group);--\tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;-\tif (!EC_GROUP_copy(P_521, group)) ABORT;---\t/* more tests using the last curve */--\tif (!EC_POINT_copy(Q, P)) ABORT;-\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;-\tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT;-\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;-\tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */--\tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT;-\tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */--\t{-\t\tconst EC_POINT *points[4];-\t\tconst BIGNUM *scalars[4];-\t\tBIGNUM *scalar3;-\t-\t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;-\t\tpoints[0] = Q;-\t\tpoints[1] = Q;-\t\tpoints[2] = Q;-\t\tpoints[3] = Q;--\t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\t\tif (!BN_add(y, z, BN_value_one())) ABORT;-\t\tif (BN_is_odd(y)) ABORT;-\t\tif (!BN_rshift1(y, y)) ABORT;-\t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */-\t\tscalars[1] = y;--\t\tfprintf(stdout, \"combined multiplication ...\");-\t\tfflush(stdout);--\t\t/* z is still the group order */-\t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT;-\t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT;-\t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;-\t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT;--\t\tfprintf(stdout, \".\");-\t\tfflush(stdout);--\t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT;-\t\tif (!BN_add(z, z, y)) ABORT;-\t\tBN_set_negative(z, 1);-\t\tscalars[0] = y;-\t\tscalars[1] = z; /* z = -(order + y) */--\t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT;-\t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\t\tfprintf(stdout, \".\");-\t\tfflush(stdout);--\t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT;-\t\tif (!BN_add(z, x, y)) ABORT;-\t\tBN_set_negative(z, 1);-\t\tscalars[0] = x;-\t\tscalars[1] = y;-\t\tscalars[2] = z; /* z = -(x+y) */--\t\tscalar3 = BN_new();-\t\tif(!scalar3) ABORT;-\t\tBN_zero(scalar3);-\t\tscalars[3] = scalar3;--\t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT;-\t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;--\t\tfprintf(stdout, \" ok\\n\\n\");--\t\tBN_free(scalar3);-\t}---#if 0-\ttimings(P_160, TIMING_BASE_PT, ctx);-\ttimings(P_160, TIMING_RAND_PT, ctx);-\ttimings(P_160, TIMING_SIMUL, ctx);-\ttimings(P_192, TIMING_BASE_PT, ctx);-\ttimings(P_192, TIMING_RAND_PT, ctx);-\ttimings(P_192, TIMING_SIMUL, ctx);-\ttimings(P_224, TIMING_BASE_PT, ctx);-\ttimings(P_224, TIMING_RAND_PT, ctx);-\ttimings(P_224, TIMING_SIMUL, ctx);-\ttimings(P_256, TIMING_BASE_PT, ctx);-\ttimings(P_256, TIMING_RAND_PT, ctx);-\ttimings(P_256, TIMING_SIMUL, ctx);-\ttimings(P_384, TIMING_BASE_PT, ctx);-\ttimings(P_384, TIMING_RAND_PT, ctx);-\ttimings(P_384, TIMING_SIMUL, ctx);-\ttimings(P_521, TIMING_BASE_PT, ctx);-\ttimings(P_521, TIMING_RAND_PT, ctx);-\ttimings(P_521, TIMING_SIMUL, ctx);-#endif---\tif (ctx)-\t\tBN_CTX_free(ctx);-\tBN_free(p); BN_free(a);\tBN_free(b);-\tEC_GROUP_free(group);-\tEC_POINT_free(P);-\tEC_POINT_free(Q);-\tEC_POINT_free(R);-\tBN_free(x); BN_free(y); BN_free(z);--\tif (P_160) EC_GROUP_free(P_160);-\tif (P_192) EC_GROUP_free(P_192);-\tif (P_224) EC_GROUP_free(P_224);-\tif (P_256) EC_GROUP_free(P_256);-\tif (P_384) EC_GROUP_free(P_384);-\tif (P_521) EC_GROUP_free(P_521);--\t}+        const EC_POINT *points[4];+        const BIGNUM *scalars[4];+        BIGNUM *scalar3;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -275,493 +275,494 @@ \t{ \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\");  \tgroup_order_tests(group); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[4]; \t\tconst BIGNUM *scalars[4];-\t\tBIGNUM scalar3;+\t\tBIGNUM *scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tpoints[3] = Q; \t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */-\t\tBN_init(&scalar3);-\t\tBN_zero(&scalar3);-\t\tscalars[3] = &scalar3;+\t\tscalar3 = BN_new();+\t\tif(!scalar3) ABORT;+\t\tBN_zero(scalar3);+\t\tscalars[3] = scalar3; \t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\");-\t\tBN_free(&scalar3);+\t\tBN_free(scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2014-10-28 22:58:56+00:00",
            "commit_hash": "5784a52145d0062d42724d4d0fab3b4c82de35ee",
            "message": "Implement internally opaque bn access from ec\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -238,493 +238,493 @@-\t{\t+\t{ \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tgroup_order_tests(group); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\");  \tgroup_order_tests(group); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[4]; \t\tconst BIGNUM *scalars[4]; \t\tBIGNUM scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tpoints[3] = Q; \t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tBN_init(&scalar3); \t\tBN_zero(&scalar3); \t\tscalars[3] = &scalar3; \t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t\tBN_free(&scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2011-10-18 19:43:16+00:00",
            "commit_hash": "3e00b4c9db42818c621f609e70569c7d9ae85717",
            "message": "Improve optional 64-bit NIST-P224 implementation, and add NIST-P256 and\nNIST-P521. (Now -DEC_NISTP_64_GCC_128 enables all three of these;\n-DEC_NISTP224_64_GCC_128 no longer works.)\nSubmitted by: Google Inc."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -199,552 +237,493 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \");+\tfprintf(stdout, \"Generator as octet string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \");+\tfprintf(stdout, \"\\nGenerator as octet string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;-\tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \");+\tfprintf(stdout, \"\\nGenerator as octet string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\");-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");+\tgroup_order_tests(group); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\");-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");+\tgroup_order_tests(group); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\");-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");+\tgroup_order_tests(group); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\");-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");+\tgroup_order_tests(group); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\");-\t-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");++\tgroup_order_tests(group); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\");-\t-\tfprintf(stdout, \"verify group order ...\");-\tfflush(stdout);-\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \".\");-\tfflush(stdout);-\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;-\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;-\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \" ok\\n\");++ \tgroup_order_tests(group); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[4]; \t\tconst BIGNUM *scalars[4]; \t\tBIGNUM scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tpoints[3] = Q;+\t\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tBN_init(&scalar3); \t\tBN_zero(&scalar3); \t\tscalars[3] = &scalar3; \t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t\tBN_free(&scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2010-08-26 14:29:55+00:00",
            "commit_hash": "04daec862ced4e5e3921724b7a59c432fa9cbab3",
            "message": "New 64-bit optimized implementation EC_GFp_nistp224_method().\nThis will only be compiled in if explicitly requested\n(#ifdef EC_NISTP224_64_GCC_128).\nSubmitted by: Emilia Kasper (Google)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -199,544 +199,552 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{-\t\tconst EC_POINT *points[3];-\t\tconst BIGNUM *scalars[3];+\t\tconst EC_POINT *points[4];+\t\tconst BIGNUM *scalars[4];+\t\tBIGNUM scalar3; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q;+\t\tpoints[3] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */-\t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT;+\t\tBN_init(&scalar3);+\t\tBN_zero(&scalar3);+\t\tscalars[3] = &scalar3;++\t\tif (!EC_POINTs_mul(group, P, NULL, 4, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\");++\t\tBN_free(&scalar3); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2007-05-22 09:47:43+00:00",
            "commit_hash": "19f6c524bf78e37ab27cbc53d36655ca709b9675",
            "message": "Fix crypto/ec/ec_mult.c to work properly with scalars of value 0"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -199,544 +199,544 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT;-\t\tif (!EC_GROUP_copy(tmp, group));+\t\tif (!EC_GROUP_copy(tmp, group)) ABORT; \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2005-08-28 22:49:57+00:00",
            "commit_hash": "8215e7a93897347a97de87b3d26fe84cc8a5b05d",
            "message": "fix warnings when building openssl with the following compiler options:\n-Wmissing-prototypes -Wcomment -Wformat -Wimplicit -Wmain -Wmultichar\n-Wswitch -Wshadow -Wtrigraphs -Werror -Wchar-subscripts\n-Wstrict-prototypes -Wreturn-type -Wpointer-arith  -W -Wunused\n-Wno-unused-parameter -Wuninitialized"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -194,544 +194,544 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000) \t * -- not a NIST curve, but commonly used */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT; \tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 160) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_160, group)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT;-\t\tBN_set_sign(z, 1);+\t\tBN_set_negative(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT;-\t\tBN_set_sign(z, 1);+\t\tBN_set_negative(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_160, TIMING_BASE_PT, ctx); \ttimings(P_160, TIMING_RAND_PT, ctx); \ttimings(P_160, TIMING_SIMUL, ctx); \ttimings(P_192, TIMING_BASE_PT, ctx); \ttimings(P_192, TIMING_RAND_PT, ctx); \ttimings(P_192, TIMING_SIMUL, ctx); \ttimings(P_224, TIMING_BASE_PT, ctx); \ttimings(P_224, TIMING_RAND_PT, ctx); \ttimings(P_224, TIMING_SIMUL, ctx); \ttimings(P_256, TIMING_BASE_PT, ctx); \ttimings(P_256, TIMING_RAND_PT, ctx); \ttimings(P_256, TIMING_SIMUL, ctx); \ttimings(P_384, TIMING_BASE_PT, ctx); \ttimings(P_384, TIMING_RAND_PT, ctx); \ttimings(P_384, TIMING_SIMUL, ctx); \ttimings(P_521, TIMING_BASE_PT, ctx); \ttimings(P_521, TIMING_RAND_PT, ctx); \ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2005-04-22 20:02:44+00:00",
            "commit_hash": "ff22e913a3fbeb025e612828859102aa1a3effaa",
            "message": "- use BN_set_negative and BN_is_negative instead of BN_set_sign\nand BN_get_sign\n- implement BN_set_negative as a function\n- always use \"#define BN_is_zero(a) ((a)->top == 0)\""
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -180,489 +192,544 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group;-\tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL;+\tEC_GROUP *P_160 = NULL, *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;+\t/* Curve secp160r1 (Certicom Research SEC 2 Version 1.0, section 2.4.2, 2000)+\t * -- not a NIST curve, but commonly used */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\")) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"4A96B5688EF573284664698968C38BB913CBFC82\")) ABORT;+\tif (!BN_hex2bn(&y, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT;+\tif (!EC_POINT_set_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"0100000000000000000001F4C8F927AED3CA752257\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nSEC2 curve secp160r1 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"23a628553168947d59dcc912042351377ac5fb32\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;++\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 160) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t+\tfprintf(stdout, \"verify group order ...\");+\tfflush(stdout);+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \" ok\\n\");++\tif (!(P_160 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_160, group)) ABORT;++ \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_sign(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_sign(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0-\ttimings(P_192, 0, ctx);-\ttimings(P_192, 1, ctx);-\ttimings(P_224, 0, ctx);-\ttimings(P_224, 1, ctx);-\ttimings(P_256, 0, ctx);-\ttimings(P_256, 1, ctx);-\ttimings(P_384, 0, ctx);-\ttimings(P_384, 1, ctx);-\ttimings(P_521, 0, ctx);-\ttimings(P_521, 1, ctx);+\ttimings(P_160, TIMING_BASE_PT, ctx);+\ttimings(P_160, TIMING_RAND_PT, ctx);+\ttimings(P_160, TIMING_SIMUL, ctx);+\ttimings(P_192, TIMING_BASE_PT, ctx);+\ttimings(P_192, TIMING_RAND_PT, ctx);+\ttimings(P_192, TIMING_SIMUL, ctx);+\ttimings(P_224, TIMING_BASE_PT, ctx);+\ttimings(P_224, TIMING_RAND_PT, ctx);+\ttimings(P_224, TIMING_SIMUL, ctx);+\ttimings(P_256, TIMING_BASE_PT, ctx);+\ttimings(P_256, TIMING_RAND_PT, ctx);+\ttimings(P_256, TIMING_SIMUL, ctx);+\ttimings(P_384, TIMING_BASE_PT, ctx);+\ttimings(P_384, TIMING_RAND_PT, ctx);+\ttimings(P_384, TIMING_SIMUL, ctx);+\ttimings(P_521, TIMING_BASE_PT, ctx);+\ttimings(P_521, TIMING_RAND_PT, ctx);+\ttimings(P_521, TIMING_SIMUL, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z);+\tif (P_160) EC_GROUP_free(P_160); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2003-07-22 10:39:10+00:00",
            "commit_hash": "652ae06badda3a8964f650ce1713e335257548d9",
            "message": "add test for secp160r1\nadd code for kP+lQ timings\nSubmitted by: Douglas Stebila <douglas.stebila@sun.com>\nReviewed by: Bodo Moeller"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -178,489 +178,489 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;-\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tBN_set_sign(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tBN_set_sign(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2002-12-08 05:24:31+00:00",
            "commit_hash": "e9224c717711eefb30038c9b37c69795dda93c9a",
            "message": "This is a first-cut at improving the callback mechanisms used in\nkey-generation and prime-checking functions. Rather than explicitly passing\ncallback functions and caller-defined context data for the callbacks, a new\nstructure BN_GENCB is defined that encapsulates this; a pointer to the\nstructure is passed to all such functions instead.\nThis wrapper structure allows the encapsulation of \"old\" and \"new\" style\ncallbacks - \"new\" callbacks return a boolean result on the understanding\nthat returning FALSE should terminate keygen/primality processing.  The\nBN_GENCB abstraction will allow future callback modifications without\nneeding to break binary compatibility nor change the API function\nprototypes. The new API functions have been given names ending in \"_ex\" and\nthe old functions are implemented as wrappers to the new ones.  The\nOPENSSL_NO_DEPRECATED symbol has been introduced so that, if defined,\ndeclaration of the older functions will be skipped. NB: Some\nopenssl-internal code will stick with the older callbacks for now, so\nappropriate \"#undef\" logic will be put in place - this is in case the user\nis *building* openssl (rather than *including* its headers) with this\nsymbol defined.\nThere is another change in the new _ex functions; the key-generation\nfunctions do not return key structures but operate on structures passed by\nthe caller, the return value is a boolean. This will allow for a smoother\ntransition to having key-generation as \"virtual function\" in the various\n***_METHOD tables."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -171,489 +171,489 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 192) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 224) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 256) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 384) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify degree ...\"); \tif (EC_GROUP_get_degree(group) != 521) ABORT; \tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT;-\t\tz->neg = 1;+\t\tBN_set_sign(z, 1); \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT;-\t\tz->neg = 1;+\t\tBN_set_sign(z, 1); \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521); \t}",
            "commit_date": "2002-11-04 13:17:22+00:00",
            "commit_hash": "b53e44e57259b2b015c54de8ecbcf4e06be23298",
            "message": "implement and use new macros BN_get_sign(), BN_set_sign()\nSubmitted by: Nils Larsch"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -144,482 +178,489 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k;-\t/* enable memory leak checking unless explicitly disabled */-\tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\"))))-\t\t{-\t\tCRYPTO_malloc_debug_init();-\t\tCRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);-\t\t}-\telse-\t\t{-\t\t/* OPENSSL_DEBUG_MEMORY=off */-\t\tCRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0);-\t\t}-\tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON);-\tERR_load_crypto_strings();- #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;++\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 192) ABORT;+\tfprintf(stdout, \" ok\\n\"); \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;+\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 224) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;+\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 256) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;+\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 384) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;+\tfprintf(stdout, \"verify degree ...\");+\tif (EC_GROUP_get_degree(group) != 521) ABORT;+\tfprintf(stdout, \" ok\\n\");+\t \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);+\t}",
            "commit_date": "2002-08-02 13:42:24+00:00",
            "commit_hash": "7793f30e09c104b209206608a20f2088b1b635fd",
            "message": "add support for elliptic curves over binary fields\nSubmitted by: Duglas Stebila <douglas.stebila@sun.com>,\nSheueling Chang <sheueling.chang@sun.com>\n(CHANGES entries by Bodo Moeller)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -144,477 +144,482 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init();-\t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);+\t\tCRYPTO_set_mem_debug_options(V_CRYPTO_MDEBUG_ALL);+\t\t}+\telse+\t\t{+\t\t/* OPENSSL_DEBUG_MEMORY=off */+\t\tCRYPTO_set_mem_debug_functions(0, 0, 0, 0, 0); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2002-02-14 14:41:13+00:00",
            "commit_hash": "8f06b003736c957c6e693d3b5dd1393f91a530cd",
            "message": "make it possible to disable memory checking for timings"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -144,477 +144,477 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t}-#if 1+#if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-12-17 19:26:43+00:00",
            "commit_hash": "1226c472b7f6f1b211b306eb3ac937f546573dd3",
            "message": "oops"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -144,477 +144,477 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t}-#if 0+#if 1 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-12-17 19:22:23+00:00",
            "commit_hash": "4d7072f4b5b536c080854eba4b0092d80adf4d37",
            "message": "remove redundant ERR_load_... declarations"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -144,477 +144,477 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT;-\t\tif (!BN_copy(z, y)) ABORT;+\t\tif (!BN_add(z, z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y;-\t\tscalars[1] = z; /* z = -y */+\t\tscalars[1] = z; /* z = -(order + y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-11-16 06:22:05+00:00",
            "commit_hash": "752938daabf4279b6983721f3af0c94889b82eed",
            "message": "use a more interesting test case"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -144,477 +144,477 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tk = 100; \tdo \t\t{ \t\tif (k-- == 0) ABORT; \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y;-\t\tfprintf(stdout, \"simultaneous multiplication ...\");+\t\tfprintf(stdout, \"combined multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-07-10 11:41:29+00:00",
            "commit_hash": "9c10b2c8d314db4efe3be8d1439411563bb0a5c0",
            "message": "For consistency with the terminology used in my SAC2001 paper, avoid\nthe term \"simultaneous multiplication\" (which -- acording to the\npaper, at least -- applies only to certain methods which we don't use\nhere)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -142,473 +142,477 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len;+\tint k; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\");+\tk = 100; \tdo \t\t{+\t\tif (k-- == 0) ABORT;+ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-15 11:31:37+00:00",
            "commit_hash": "63c43dcc5953a98c14fef2e381bb159ede883a5c",
            "message": "avoid infinite loop"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -142,473 +142,473 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \t/* enable memory leak checking unless explicitly disabled */ \tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\")))) \t\t{ \t\tCRYPTO_malloc_debug_init(); \t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL); \t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout);-\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-12 07:26:23+00:00",
            "commit_hash": "194dd04699f03af4cf7f7f88ecf31f243a19552b",
            "message": "Rename function EC_GROUP_precompute to EC_GROUP_precompute_mult,\nwhich indicate its purpose more clearly."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -142,467 +142,473 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len;+\t/* enable memory leak checking unless explicitly disabled */+\tif (!((getenv(\"OPENSSL_DEBUG_MEMORY\") != NULL) && (0 == strcmp(getenv(\"OPENSSL_DEBUG_MEMORY\"), \"off\"))))+\t\t{+\t\tCRYPTO_malloc_debug_init();+\t\tCRYPTO_dbg_set_options(V_CRYPTO_MDEBUG_ALL);+\t\t} \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 14:49:46+00:00",
            "commit_hash": "10654d3a745a314e9961e62bc25f4a9fbb4a15b3",
            "message": "Forcibly enable memory leak checking during \"make test\""
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -142,467 +142,467 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \".\"); \tfflush(stdout); \tif (!EC_GROUP_precompute(group, ctx)) ABORT; \tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tconst EC_POINT *points[3]; \t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = y; \t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT; \t\tif (!BN_add(z, x, y)) ABORT; \t\tz->neg = 1; \t\tscalars[0] = x; \t\tscalars[1] = y; \t\tscalars[2] = z; /* z = -(x+y) */ \t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \t\tfprintf(stdout, \" ok\\n\\n\"); \t}-#if 1+#if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 12:30:52+00:00",
            "commit_hash": "6017e604f8367050d377af766e4242564675f774",
            "message": "Timings are not supposed to be enabled by default ..."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -147,432 +142,467 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");+\tfprintf(stdout, \" ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");-\t+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \" ok\\n\");+ \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");-\t+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \" ok\\n\");+ \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");-\t+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \" ok\\n\");+ \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT;-\tfprintf(stdout, \"verify group order ... \");+\tfprintf(stdout, \"verify group order ...\"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;-\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \".\");+\tfflush(stdout);+\tif (!EC_GROUP_precompute(group, ctx)) ABORT;+\tif (!EC_POINT_mul(group, Q, z, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;-\tfprintf(stdout, \"ok\\n\");+\tfprintf(stdout, \" ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{-\t\tEC_POINT *points[2];-\t\tBIGNUM *scalars[2];+\t\tconst EC_POINT *points[3];+\t\tconst BIGNUM *scalars[3]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;+\t\tpoints[0] = Q;+\t\tpoints[1] = Q;+\t\tpoints[2] = Q; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT;--\t\tpoints[0] = Q;-\t\tpoints[1] = Q; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT; \t\tif (!BN_copy(z, y)) ABORT; \t\tz->neg = 1;--\t\tpoints[0] = Q;-\t\tpoints[1] = Q; \t\tscalars[0] = y;-\t\tscalars[1] = z;+\t\tscalars[1] = z; /* z = -y */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;+\t\tfprintf(stdout, \".\");+\t\tfflush(stdout);++\t\tif (!BN_pseudo_rand(x, BN_num_bits(y) - 1, 0, 0)) ABORT;+\t\tif (!BN_add(z, x, y)) ABORT;+\t\tz->neg = 1;+\t\tscalars[0] = x;+\t\tscalars[1] = y;+\t\tscalars[2] = z; /* z = -(x+y) */++\t\tif (!EC_POINTs_mul(group, P, NULL, 3, points, scalars, ctx)) ABORT;+\t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;+ \t\tfprintf(stdout, \" ok\\n\\n\"); \t}-#if 0+#if 1 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 12:27:24+00:00",
            "commit_hash": "3837491174ececd6ff1b0dcdda754443f89a7699",
            "message": "Add functions EC_POINT_mul and EC_GROUP_precompute.\nThe latter does nothing for now, but its existence means\nthat applications can request precomputation when appropriate."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -147,417 +147,432 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tEC_POINT *points[2]; \t\tBIGNUM *scalars[2]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y;-\t\tfprintf(stdout, \"simultaneous multiplication ... \");+\t\tfprintf(stdout, \"simultaneous multiplication ...\"); \t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT;-\t\tfprintf(stdout, \"ok\\n\\n\");+\t\tfprintf(stdout, \".\");+\t\tfflush(stdout);++\t\tif (!BN_pseudo_rand(y, BN_num_bits(y), 0, 0)) ABORT;+\t\tif (!BN_copy(z, y)) ABORT;+\t\tz->neg = 1;++\t\tpoints[0] = Q;+\t\tpoints[1] = Q;+\t\tscalars[0] = y;+\t\tscalars[1] = z;++\t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT;+\t\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;++\t\tfprintf(stdout, \" ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 08:44:50+00:00",
            "commit_hash": "86a921af06f52d1b16fbc8a76d8f0ff1950d1c8a",
            "message": "handle negative scalars correctly when doing point multiplication"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -147,411 +147,417 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \");+\tfflush(stdout); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tEC_POINT *points[2]; \t\tBIGNUM *scalars[2]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ... \");+\t\tfflush(stdout); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \"ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx); \ttimings(P_224, 0, ctx); \ttimings(P_224, 1, ctx); \ttimings(P_256, 0, ctx); \ttimings(P_256, 1, ctx); \ttimings(P_384, 0, ctx); \ttimings(P_384, 1, ctx); \ttimings(P_521, 0, ctx); \ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-11 08:27:11+00:00",
            "commit_hash": "616df356332246c891fb1a650fef54ee211cafd3",
            "message": "use fflush"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -147,403 +147,411 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp \t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \t{ \t\tEC_GROUP *tmp; \t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group)); \t\tif (!tmp) ABORT; \t\tif (!EC_GROUP_copy(tmp, group)); \t\tEC_GROUP_free(group); \t\tgroup = tmp; \t} \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\t{ \t\t\tEC_POINT *points[3]; \t\t\tpoints[0] = R; \t\t\tpoints[1] = Q; \t\t\tpoints[2] = P; \t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT; \t\t} #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* Curve P-192 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_192, group)) ABORT; \t/* Curve P-224 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_224, group)) ABORT; \t/* Curve P-256 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\" \t\t\"84F3B9CAC2FC632551\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_256, group)) ABORT; \t/* Curve P-384 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\" \t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\" \t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\" \t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_384, group)) ABORT; \t/* Curve P-521 (FIPS PUB 186-2, App. 6) */ \tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT; \tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT; \tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\" \t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\" \t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\" \t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\" \t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\" \t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\" \t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT; \tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT; \tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \"\\n     y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \"\\n\"); \t/* G_y value taken from the standard: */ \tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\" \t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\" \t\t\"7086A272C24088BE94769FD16650\")) ABORT; \tif (0 != BN_cmp(y, z)) ABORT; \tfprintf(stdout, \"verify group order ... \"); \tif (!EC_GROUP_get_order(group, z, ctx)) ABORT; \tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, Q)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT; \tif (!EC_GROUP_copy(P_521, group)) ABORT; \t/* more tests using the last curve */ \tif (!EC_POINT_copy(Q, P)) ABORT; \tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT; \tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */ \tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT; \tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */ \t{ \t\tEC_POINT *points[2]; \t\tBIGNUM *scalars[2]; \t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT; \t\tif (!BN_add(y, z, BN_value_one())) ABORT; \t\tif (BN_is_odd(y)) ABORT; \t\tif (!BN_rshift1(y, y)) ABORT; \t\tpoints[0] = Q; \t\tpoints[1] = Q; \t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */ \t\tscalars[1] = y; \t\tfprintf(stdout, \"simultaneous multiplication ... \"); \t\t/* z is still the group order */ \t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT; \t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT; \t\tfprintf(stdout, \"ok\\n\\n\"); \t} #if 0 \ttimings(P_192, 0, ctx); \ttimings(P_192, 1, ctx);+\ttimings(P_224, 0, ctx);+\ttimings(P_224, 1, ctx);+\ttimings(P_256, 0, ctx);+\ttimings(P_256, 1, ctx);+\ttimings(P_384, 0, ctx);+\ttimings(P_384, 1, ctx);+\ttimings(P_521, 0, ctx);+\ttimings(P_521, 1, ctx); #endif \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z); \tif (P_192) EC_GROUP_free(P_192); \tif (P_224) EC_GROUP_free(P_224); \tif (P_256) EC_GROUP_free(P_256); \tif (P_384) EC_GROUP_free(P_384); \tif (P_521) EC_GROUP_free(P_521);",
            "commit_date": "2001-03-10 23:49:06+00:00",
            "commit_hash": "e44fcedadf77c9d4d44b636d69e7927de5b2df14",
            "message": "Change timing output: We don't have \"exponents\" here, curves are\nconsidered additive"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -75,143 +147,403 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group;+\tEC_GROUP *P_192 = NULL, *P_224 = NULL, *P_256 = NULL, *P_384 = NULL, *P_521 = NULL; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings();-#if 0 /* optional */+#if 1 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"17\")) ABORT; \tif (!BN_hex2bn(&a, \"1\")) ABORT; \tif (!BN_hex2bn(&b, \"1\")) ABORT;-\tgroup = EC_GROUP_new(EC_GFp_mont_method());+\tgroup = EC_GROUP_new(EC_GFp_mont_method()); /* applications should use EC_GROUP_new_curve_GFp+\t                                             * so that the library gets to choose the EC_METHOD */ \tif (!group) ABORT;+ \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\t{+\t\tEC_GROUP *tmp;+\t\ttmp = EC_GROUP_new(EC_GROUP_method_of(group));+\t\tif (!tmp) ABORT;+\t\tif (!EC_GROUP_copy(tmp, group));+\t\tEC_GROUP_free(group);+\t\tgroup = tmp;+\t}+\t \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */-\t\tif (!EC_POINT_make_affine(group, P, ctx)) ABORT;+\t\t{+\t\t\tEC_POINT *points[3];+\t\t+\t\t\tpoints[0] = R;+\t\t\tpoints[1] = Q;+\t\t\tpoints[2] = P;+\t\t\tif (!EC_POINTs_make_affine(group, 2, points, ctx)) ABORT;+\t\t} #endif+ \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;-\t/* ... */++\t/* Curve P-192 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-192 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");++\tif (!(P_192 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_192, group)) ABORT;+++\t/* Curve P-224 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT;+\tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-224 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");+\t+\tif (!(P_224 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_224, group)) ABORT;+++\t/* Curve P-256 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E\"+\t\t\"84F3B9CAC2FC632551\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-256 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");+\t+\tif (!(P_256 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_256, group)) ABORT;+++\t/* Curve P-384 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141\"+\t\t\"120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B\"+\t\t\"9859F741E082542A385502F25DBF55296C3A545E3872760AB7\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 1, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-384 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A14\"+\t\t\"7CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");+\t+\tif (!(P_384 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_384, group)) ABORT;+++\t/* Curve P-521 (FIPS PUB 186-2, App. 6) */+\t+\tif (!BN_hex2bn(&p, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF\")) ABORT;+\tif (1 != BN_is_prime(p, BN_prime_checks, 0, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFC\")) ABORT;+\tif (!BN_hex2bn(&b, \"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B\"+\t\t\"315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573\"+\t\t\"DF883D2C34F1EF451FD46B503F00\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;++\tif (!BN_hex2bn(&x, \"C6858E06B70404E9CD9E3ECB662395B4429C648139053F\"+\t\t\"B521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B\"+\t\t\"3C1856A429BF97E7E31C2E5BD66\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, P, x, 0, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!BN_hex2bn(&z, \"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+\t\t\"FFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5\"+\t\t\"C9B8899C47AEBB6FB71E91386409\")) ABORT;+\tif (!EC_GROUP_set_generator(group, P, z, BN_value_one())) ABORT;++\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;+\tfprintf(stdout, \"\\nNIST curve P-521 -- Generator:\\n     x = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \"\\n     y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \"\\n\");+\t/* G_y value taken from the standard: */+\tif (!BN_hex2bn(&z, \"11839296A789A3BC0045C8A5FB42C7D1BD998F54449579\"+\t\t\"B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C\"+\t\t\"7086A272C24088BE94769FD16650\")) ABORT;+\tif (0 != BN_cmp(y, z)) ABORT;+\t+\tfprintf(stdout, \"verify group order ... \");+\tif (!EC_GROUP_get_order(group, z, ctx)) ABORT;+\tif (!EC_POINTs_mul(group, Q, z, 0, NULL, NULL, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, Q)) ABORT;+\tfprintf(stdout, \"ok\\n\");++\tif (!(P_521 = EC_GROUP_new(EC_GROUP_method_of(group)))) ABORT;+\tif (!EC_GROUP_copy(P_521, group)) ABORT;+++\t/* more tests using the last curve */++\tif (!EC_POINT_copy(Q, P)) ABORT;+\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;+\tif (!EC_POINT_dbl(group, P, P, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, P, ctx)) ABORT;+\tif (!EC_POINT_invert(group, Q, ctx)) ABORT; /* P = -2Q */++\tif (!EC_POINT_add(group, R, P, Q, ctx)) ABORT;+\tif (!EC_POINT_add(group, R, R, Q, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, R)) ABORT; /* R = P + 2Q */++\t{+\t\tEC_POINT *points[2];+\t\tBIGNUM *scalars[2];+\t+\t\tif (EC_POINT_is_at_infinity(group, Q)) ABORT;++\t\tif (!BN_add(y, z, BN_value_one())) ABORT;+\t\tif (BN_is_odd(y)) ABORT;+\t\tif (!BN_rshift1(y, y)) ABORT;++\t\tpoints[0] = Q;+\t\tpoints[1] = Q;+\t\tscalars[0] = y; /* (group order + 1)/2,  so  y*Q + y*Q = Q */+\t\tscalars[1] = y;++\t\tfprintf(stdout, \"simultaneous multiplication ... \");++\t\t/* z is still the group order */+\t\tif (!EC_POINTs_mul(group, P, NULL, 2, points, scalars, ctx)) ABORT;+\t\tif (!EC_POINTs_mul(group, R, z, 2, points, scalars, ctx)) ABORT;+\t\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;+\t\tif (0 != EC_POINT_cmp(group, R, Q, ctx)) ABORT;++\t\tfprintf(stdout, \"ok\\n\\n\");+\t}+++#if 0+\ttimings(P_192, 0, ctx);+\ttimings(P_192, 1, ctx);+#endif+ \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z);+\tif (P_192) EC_GROUP_free(P_192);+\tif (P_224) EC_GROUP_free(P_224);+\tif (P_256) EC_GROUP_free(P_256);+\tif (P_384) EC_GROUP_free(P_384);+\tif (P_521) EC_GROUP_free(P_521);+",
            "commit_date": "2001-03-10 23:18:35+00:00",
            "commit_hash": "48fe4d6233ac2d60745742a27f820dd88bc6689d",
            "message": "More EC stuff, including EC_POINTs_mul() for simultaneous scalar\nmultiplication of an arbitrary number of points."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -75,143 +75,143 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 0 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT;-\tif (!BN_hex2bn(&p, \"D\")) ABORT;-\tif (!BN_hex2bn(&a, \"7\")) ABORT;-\tif (!BN_hex2bn(&b, \"C\")) ABORT;+\tif (!BN_hex2bn(&p, \"17\")) ABORT;+\tif (!BN_hex2bn(&a, \"1\")) ABORT;+\tif (!BN_hex2bn(&b, \"1\")) ABORT; \tgroup = EC_GROUP_new(EC_GFp_mont_method()); \tif (!group) ABORT; \tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT; \tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT;-\tif (!BN_hex2bn(&x, \"C\")) ABORT;+\tif (!BN_hex2bn(&x, \"D\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{ \t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT; \t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x); \t\tfprintf(stderr, \", y = 0x\"); \t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\tif (!EC_POINT_make_affine(group, P, ctx)) ABORT; #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* ... */ \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z);",
            "commit_date": "2001-03-08 22:52:49+00:00",
            "commit_hash": "42909e39681bcbaaada696c901bbff472d71dbe2",
            "message": "Fix ec_GFp_simple_cmp.\nUse example group from Annex I of X9.62 in ectest.c."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -75,138 +75,143 @@ \t{\t \tBN_CTX *ctx = NULL; \tBIGNUM *p, *a, *b; \tEC_GROUP *group; \tEC_POINT *P, *Q, *R; \tBIGNUM *x, *y, *z; \tunsigned char buf[100]; \tsize_t i, len; \tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings(); #if 0 /* optional */ \tctx = BN_CTX_new(); \tif (!ctx) ABORT; #endif \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tif (!p || !a || !b) ABORT; \tif (!BN_hex2bn(&p, \"D\")) ABORT; \tif (!BN_hex2bn(&a, \"7\")) ABORT; \tif (!BN_hex2bn(&b, \"C\")) ABORT;-\tgroup = EC_GROUP_new_curve_GFp(p, a, b, NULL);+\tgroup = EC_GROUP_new(EC_GFp_mont_method()); \tif (!group) ABORT;+\tif (!EC_GROUP_set_curve_GFp(group, p, a, b, ctx)) ABORT;+\tif (!EC_GROUP_get_curve_GFp(group, p, a, b, ctx)) ABORT; \tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\"); \tBN_print_fp(stdout, p); \tfprintf(stdout, \")\\n     a = 0x\"); \tBN_print_fp(stdout, a); \tfprintf(stdout, \"\\n     b = 0x\"); \tBN_print_fp(stdout, b); \tfprintf(stdout, \"\\n\"); \tP = EC_POINT_new(group); \tQ = EC_POINT_new(group); \tR = EC_POINT_new(group); \tif (!P || !Q || !R) ABORT; \tif (!EC_POINT_set_to_infinity(group, P)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tbuf[0] = 0; \tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT; \tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tx = BN_new(); \ty = BN_new(); \tz = BN_new(); \tif (!x || !y || !z) ABORT; \tif (!BN_hex2bn(&x, \"C\")) ABORT; \tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT; \tif (!EC_POINT_is_on_curve(group, Q, ctx)) \t\t{-\t\tfprintf(stderr, \"Point is not on curve, x = 0x\");+\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, Q, x, y, ctx)) ABORT;+\t\tfprintf(stderr, \"Point is not on curve: x = 0x\"); \t\tBN_print_fp(stderr, x);+\t\tfprintf(stderr, \", y = 0x\");+\t\tBN_print_fp(stderr, y); \t\tfprintf(stderr, \"\\n\"); \t\tABORT; \t\t} \tfprintf(stdout, \"A cyclic subgroup:\\n\"); \tdo \t\t{ \t\tif (EC_POINT_is_at_infinity(group, P)) \t\t\tfprintf(stdout, \"     point at infinity\\n\"); \t\telse \t\t\t{ \t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT; \t\t\tfprintf(stdout, \"     x = 0x\"); \t\t\tBN_print_fp(stdout, x); \t\t\tfprintf(stdout, \", y = 0x\"); \t\t\tBN_print_fp(stdout, y); \t\t\tfprintf(stdout, \"\\n\"); \t\t\t} \t\tif (!EC_POINT_copy(R, P)) ABORT; \t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT; #if 0 /* optional */ \t\tif (!EC_POINT_make_affine(group, P, ctx)) ABORT; #endif \t\t} \twhile (!EC_POINT_is_at_infinity(group, P)); \tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT; \tif (!EC_POINT_is_at_infinity(group, P)) ABORT; \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx); \tif (len == 0) ABORT; \tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT; \tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \"); \tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]); \tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT; \tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\"); \tBN_print_fp(stdout, x); \tfprintf(stdout, \", Y = 0x\"); \tBN_print_fp(stdout, y); \tfprintf(stdout, \", Z = 0x\"); \tBN_print_fp(stdout, z); \tfprintf(stdout, \"\\n\"); \tif (!EC_POINT_invert(group, P, ctx)) ABORT; \tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT; \t/* ... */ \tif (ctx) \t\tBN_CTX_free(ctx); \tBN_free(p); BN_free(a);\tBN_free(b); \tEC_GROUP_free(group); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(R); \tBN_free(x); BN_free(y); BN_free(z);",
            "commit_date": "2001-03-08 20:55:16+00:00",
            "commit_hash": "156e85578d180313c27e51d0bf186aa8650c49e1",
            "message": "Implement EC_GFp_mont_method."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -71,10 +75,138 @@ \t{\t+\tBN_CTX *ctx = NULL;+\tBIGNUM *p, *a, *b; \tEC_GROUP *group;-+\tEC_POINT *P, *Q, *R;+\tBIGNUM *x, *y, *z;+\tunsigned char buf[100];+\tsize_t i, len;+\t+\tCRYPTO_mem_ctrl(CRYPTO_MEM_CHECK_ON); \tERR_load_crypto_strings();-#if 0-\tgroup = EC_GROUP_new(NULL);+#if 0 /* optional */+\tctx = BN_CTX_new();+\tif (!ctx) ABORT;+#endif++\tp = BN_new();+\ta = BN_new();+\tb = BN_new();+\tif (!p || !a || !b) ABORT;++\tif (!BN_hex2bn(&p, \"D\")) ABORT;+\tif (!BN_hex2bn(&a, \"7\")) ABORT;+\tif (!BN_hex2bn(&b, \"C\")) ABORT;+\t+\tgroup = EC_GROUP_new_curve_GFp(p, a, b, NULL); \tif (!group) ABORT;++\tfprintf(stdout, \"Curve defined by Weierstrass equation\\n     y^2 = x^3 + a*x + b  (mod 0x\");+\tBN_print_fp(stdout, p);+\tfprintf(stdout, \")\\n     a = 0x\");+\tBN_print_fp(stdout, a);+\tfprintf(stdout, \"\\n     b = 0x\");+\tBN_print_fp(stdout, b);+\tfprintf(stdout, \"\\n\");++\tP = EC_POINT_new(group);+\tQ = EC_POINT_new(group);+\tR = EC_POINT_new(group);+\tif (!P || !Q || !R) ABORT;+\t+\tif (!EC_POINT_set_to_infinity(group, P)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;++\tbuf[0] = 0;+\tif (!EC_POINT_oct2point(group, Q, buf, 1, ctx)) ABORT;++\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;++\tx = BN_new();+\ty = BN_new();+\tz = BN_new();+\tif (!x || !y || !z) ABORT;++\tif (!BN_hex2bn(&x, \"C\")) ABORT;+\tif (!EC_POINT_set_compressed_coordinates_GFp(group, Q, x, 1, ctx)) ABORT;+\tif (!EC_POINT_is_on_curve(group, Q, ctx))+\t\t{+\t\tfprintf(stderr, \"Point is not on curve, x = 0x\");+\t\tBN_print_fp(stderr, x);+\t\tfprintf(stderr, \"\\n\");+\t\tABORT;+\t\t}++\tfprintf(stdout, \"A cyclic subgroup:\\n\");+\tdo+\t\t{+\t\tif (EC_POINT_is_at_infinity(group, P))+\t\t\tfprintf(stdout, \"     point at infinity\\n\");+\t\telse+\t\t\t{+\t\t\tif (!EC_POINT_get_affine_coordinates_GFp(group, P, x, y, ctx)) ABORT;++\t\t\tfprintf(stdout, \"     x = 0x\");+\t\t\tBN_print_fp(stdout, x);+\t\t\tfprintf(stdout, \", y = 0x\");+\t\t\tBN_print_fp(stdout, y);+\t\t\tfprintf(stdout, \"\\n\");+\t\t\t}+\t\t+\t\tif (!EC_POINT_copy(R, P)) ABORT;+\t\tif (!EC_POINT_add(group, P, P, Q, ctx)) ABORT;++#if 0 /* optional */+\t\tif (!EC_POINT_make_affine(group, P, ctx)) ABORT; #endif+\t\t}+\twhile (!EC_POINT_is_at_infinity(group, P));++\tif (!EC_POINT_add(group, P, Q, R, ctx)) ABORT;+\tif (!EC_POINT_is_at_infinity(group, P)) ABORT;+\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_COMPRESSED, buf, sizeof buf, ctx);+\tif (len == 0) ABORT;+\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;+\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;+\tfprintf(stdout, \"Generator as octect string, compressed form:\\n     \");+\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);+\t+\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_UNCOMPRESSED, buf, sizeof buf, ctx);+\tif (len == 0) ABORT;+\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;+\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;+\tfprintf(stdout, \"\\nGenerator as octect string, uncompressed form:\\n     \");+\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);+\t+\tlen = EC_POINT_point2oct(group, Q, POINT_CONVERSION_HYBRID, buf, sizeof buf, ctx);+\tif (len == 0) ABORT;+\tif (!EC_POINT_oct2point(group, P, buf, len, ctx)) ABORT;+\tif (0 != EC_POINT_cmp(group, P, Q, ctx)) ABORT;+\tfprintf(stdout, \"\\nGenerator as octect string, hybrid form:\\n     \");+\tfor (i = 0; i < len; i++) fprintf(stdout, \"%02X\", buf[i]);+\t+\tif (!EC_POINT_get_Jprojective_coordinates_GFp(group, R, x, y, z, ctx)) ABORT;+\tfprintf(stdout, \"\\nA representation of the inverse of that generator in\\nJacobian projective coordinates:\\n     X = 0x\");+\tBN_print_fp(stdout, x);+\tfprintf(stdout, \", Y = 0x\");+\tBN_print_fp(stdout, y);+\tfprintf(stdout, \", Z = 0x\");+\tBN_print_fp(stdout, z);+\tfprintf(stdout, \"\\n\");++\tif (!EC_POINT_invert(group, P, ctx)) ABORT;+\tif (0 != EC_POINT_cmp(group, P, R, ctx)) ABORT;++\t/* ... */++\tif (ctx)+\t\tBN_CTX_free(ctx);+\tBN_free(p); BN_free(a);\tBN_free(b);+\tEC_GROUP_free(group);+\tEC_POINT_free(P);+\tEC_POINT_free(Q);+\tEC_POINT_free(R);+\tBN_free(x); BN_free(y); BN_free(z);+",
            "commit_date": "2001-03-08 19:14:52+00:00",
            "commit_hash": "bb62a8b0c57c88ec189389f07250dee9c87d0681",
            "message": "More method functions for elliptic curves,\nand an ectest.c that actually tests something."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -58,0 +71,10 @@+\t{\t+\tEC_GROUP *group;++\tERR_load_crypto_strings();++#if 0+\tgroup = EC_GROUP_new(NULL);+\tif (!group) ABORT;+#endif+",
            "commit_date": "2001-03-08 11:59:48+00:00",
            "commit_hash": "adfe54b7beb931fa0a717fc2831bada8b4f4fa16",
            "message": "Integrate ectest.c (which does not yet do anything)."
        }
    ],
    "git log -L2056,2062:test/bntest.c": [
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1574,7 +1574,7 @@-static int test_hex2bn()+static int test_hex2bn(void) {",
            "commit_date": "2017-08-15 23:39:03+02:00",
            "commit_hash": "31a80694d425bf7f3a0ed5cc2ee775d9418a5490",
            "message": "[Win] Fix some test method signatures ...\nto halves MSVC warnings.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4172)\nBIGNUM *bn = NULL;\nint st = 0;\nif (!TEST_int_eq(parseBN(&bn, \"0\"), 1)"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1659,9 +1574,7 @@ static int test_hex2bn() {-    int ret, st = 0;+    int st = 0;-    ret = parseBN(&bn, \"0\");-    if (ret != 1 || !BN_is_zero(bn) || BN_is_negative(bn)) {-        fprintf(stderr, \"BN_hex2bn(0) gave a bad result.\\n\");+    if (!TEST_int_eq(parseBN(&bn, \"0\"), 1)",
            "commit_date": "2017-04-26 12:39:46-04:00",
            "commit_hash": "30bea14be6bbf77ed60acb9bd1befeb51d4c4b10",
            "message": "Convert bntest to TEST_ framework\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3265)\nBIGNUM *bn = NULL;"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/bntest.c b/test/bntest.c--- a/test/bntest.c+++ b/test/bntest.c@@ -1650,13 +1572,9 @@-    char c = '*';--    if (p == 0)-        c = '.';-    if (p == 1)-        c = '+';-    if (p == 2)-        c = '*';-    if (p == 3)-        c = '\\n';-    putc(c, stderr);-    fflush(stderr);-    return 1;++static int test_hex2bn()+{+    BIGNUM *bn = NULL;+    int ret, st = 0;++    ret = parseBN(&bn, \"0\");+    if (ret != 1 || !BN_is_zero(bn) || BN_is_negative(bn)) {+        fprintf(stderr, \"BN_hex2bn(0) gave a bad result.\\n\");",
            "commit_date": "2016-11-28 12:26:05-05:00",
            "commit_hash": "8d1ebff41c75e4eebc7d5cc5a561a1bab6b50e70",
            "message": "Make bntest be (mostly) file-based.\nTest suite used from boring, written by David Benjamin.\nTest driver converted from C++ to C.\nAdded a Perl program to check the testsuite file.\nExtensive review feedback incorporated (thanks folks).\nReviewed-by: Emilia K\u00e4sper <emilia@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -1784,11 +1713,13 @@-\t{-\tchar c='*';--\tif (p == 0) c='.';-\tif (p == 1) c='+';-\tif (p == 2) c='*';-\tif (p == 3) c='\\n';-\tputc(c, stderr);-\tfflush(stderr);-\treturn 1;-\t}+    char c = '*';++    if (p == 0)+        c = '.';+    if (p == 1)+        c = '+';+    if (p == 2)+        c = '*';+    if (p == 3)+        c = '\\n';+    putc(c, stderr);+    fflush(stderr);+    return 1;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -1506,12 +1506,11 @@ \t{ \tchar c='*'; \tif (p == 0) c='.'; \tif (p == 1) c='+'; \tif (p == 2) c='*'; \tif (p == 3) c='\\n'; \tputc(c, stderr); \tfflush(stderr);-\t(void)n;-\t(void)arg;+\treturn 1; \t}",
            "commit_date": "2003-10-29 04:14:08+00:00",
            "commit_hash": "2aaec9cced89edfdc8375b38a130fa1c35a98025",
            "message": "Update any code that was using deprecated functions so that everything builds\nand links with OPENSSL_NO_DEPRECATED defined."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bntest.c b/crypto/bn/bntest.c--- a/crypto/bn/bntest.c+++ b/crypto/bn/bntest.c@@ -903,0 +904,12 @@+\t{+\tchar c='*';++\tif (p == 0) c='.';+\tif (p == 1) c='+';+\tif (p == 2) c='*';+\tif (p == 3) c='\\n';+\tputc(c, stderr);+\tfflush(stderr);+\t(void)n;+\t(void)arg;+\t}",
            "commit_date": "2000-11-29 11:06:50+00:00",
            "commit_hash": "bdec3c5323c7a726814257ec9b43fcd259f4e206",
            "message": "Implement BN_kronecker test.\nModify \"CHANGES\" entry for BN_mod_inverse (it's not just avoiding BN_div\nthat increases performance, avoiding BN_mul also helps)"
        }
    ],
    "git log -L1169,1186:test/ectest.c": [
        {
            "author": {
                "email": "dasraf9@gmail.com",
                "name": "David Asraf"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1161,1 +1161,18 @@+static int group_field_test(void)+{+    int r = 1;+    BIGNUM *secp521r1_field = NULL;+    BIGNUM *sect163r2_field = NULL;+    EC_GROUP *secp521r1_group = NULL;+    EC_GROUP *sect163r2_group = NULL;++    BN_hex2bn(&secp521r1_field,+                \"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+                \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+                \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+                \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\"+                \"FFFF\");+++    BN_hex2bn(&sect163r2_field,",
            "commit_date": "2019-02-07 11:51:39+02:00",
            "commit_hash": "fa1f03061037cbdac5369849a885c1191a2550d9",
            "message": "Add  EC_GROUP_get0_field\nNew function to return internal pointer for field.\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/8195)"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1253,141 +1581,1 @@-\t{-\tEC_builtin_curve *curves = NULL;-\tsize_t crv_len = 0, n = 0;-\tint    ok = 1;--\tcrv_len = EC_get_builtin_curves(NULL, 0);--\tcurves = OPENSSL_malloc(sizeof(EC_builtin_curve) * crv_len);--\tif (curves == NULL)-\t\treturn;--\tif (!EC_get_builtin_curves(curves, crv_len))-\t\t{-\t\tOPENSSL_free(curves);-\t\treturn;-\t\t}--\tfprintf(stdout, \"testing internal curves: \");-\t\t-\tfor (n = 0; n < crv_len; n++)-\t\t{-\t\tEC_GROUP *group = NULL;-\t\tint nid = curves[n].nid;-\t\tif ((group = EC_GROUP_new_by_curve_name(nid)) == NULL)-\t\t\t{-\t\t\tok = 0;-\t\t\tfprintf(stdout, \"\\nEC_GROUP_new_curve_name() failed with\"-\t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid));-\t\t\t/* try next curve */-\t\t\tcontinue;-\t\t\t}-\t\tif (!EC_GROUP_check(group, NULL))-\t\t\t{-\t\t\tok = 0;-\t\t\tfprintf(stdout, \"\\nEC_GROUP_check() failed with\"-\t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid));-\t\t\tEC_GROUP_free(group);-\t\t\t/* try the next curve */-\t\t\tcontinue;-\t\t\t}-\t\tfprintf(stdout, \".\");-\t\tfflush(stdout);-\t\tEC_GROUP_free(group);-\t\t}-\tif (ok)-\t\tfprintf(stdout, \" ok\\n\\n\");-\telse-\t\t{-\t\tfprintf(stdout, \" failed\\n\\n\");-\t\tABORT;-\t\t}-\tOPENSSL_free(curves);-\treturn;-\t}--#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128-/* nistp_test_params contains magic numbers for testing our optimized- * implementations of several NIST curves with characteristic > 3. */-struct nistp_test_params-\t{-\tconst EC_METHOD* (*meth) ();-\tint degree;-\t/* Qx, Qy and D are taken from-\t * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/ECDSA_Prime.pdf-\t * Otherwise, values are standard curve parameters from FIPS 180-3 */-\tconst char *p, *a, *b, *Qx, *Qy, *Gx, *Gy, *order, *d;-\t};--static const struct nistp_test_params nistp_tests_params[] =-\t{-\t\t{-\t\t/* P-224 */-\t\tEC_GFp_nistp224_method,-\t\t224,-\t\t/* p */-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\",-\t\t/* a */-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\",-\t\t/* b */-\t\t\"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\",-\t\t/* Qx */-\t\t\"E84FB0B8E7000CB657D7973CF6B42ED78B301674276DF744AF130B3E\",-\t\t/* Qy */-\t\t\"4376675C6FC5612C21A0FF2D2A89D2987DF7A2BC52183B5982298555\",-\t\t/* Gx */-\t\t\"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\",-\t\t/* Gy */-\t\t\"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\",-\t\t/* order */-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\",-\t\t/* d */-\t\t\"3F0C488E987C80BE0FEE521F8D90BE6034EC69AE11CA72AA777481E8\",-\t\t},-\t\t{-\t\t/* P-256 */-\t\tEC_GFp_nistp256_method,-\t\t256,-\t\t/* p */-\t\t\"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff\",-\t\t/* a */-\t\t\"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc\",-\t\t/* b */-\t\t\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\",-\t\t/* Qx */-\t\t\"b7e08afdfe94bad3f1dc8c734798ba1c62b3a0ad1e9ea2a38201cd0889bc7a19\",-\t\t/* Qy */-\t\t\"3603f747959dbf7a4bb226e41928729063adc7ae43529e61b563bbc606cc5e09\",-\t\t/* Gx */-\t\t\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\",-\t\t/* Gy */-\t\t\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\",-\t\t/* order */-\t\t\"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\",-\t\t/* d */-\t\t\"c477f9f65c22cce20657faa5b2d1d8122336f851a508a1ed04e479c34985bf96\",-\t\t},-\t\t{-\t\t/* P-521 */-\t\tEC_GFp_nistp521_method,-\t\t521,-\t\t/* p */-\t\t\"1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",-\t\t/* a */-\t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\",-\t\t/* b */-\t\t\"051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\",-\t\t/* Qx */-\t\t\"0098e91eef9a68452822309c52fab453f5f117c1da8ed796b255e9ab8f6410cca16e59df403a6bdc6ca467a37056b1e54b3005d8ac030decfeb68df18b171885d5c4\",-\t\t/* Qy */-\t\t\"0164350c321aecfc1cca1ba4364c9b15656150b4b78d6a48d7d28e7f31985ef17be8554376b72900712c4b83ad668327231526e313f5f092999a4632fd50d946bc2e\",-\t\t/* Gx */-\t\t\"c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\",-\t\t/* Gy */-\t\t\"11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\",-\t\t/* order */-\t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409\",-\t\t/* d */-\t\t\"0100085f47b8e1b8b11b7eb33028c0b2888e304bfc98501955b45bba1478dc184eeedf09b86a5f7c21994406072787205e69a63709fe35aa93ba333514b24f961722\",-\t\t},-\t};+",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1253,114 +1253,141 @@ \t{ \tEC_builtin_curve *curves = NULL; \tsize_t crv_len = 0, n = 0; \tint    ok = 1; \tcrv_len = EC_get_builtin_curves(NULL, 0); \tcurves = OPENSSL_malloc(sizeof(EC_builtin_curve) * crv_len); \tif (curves == NULL) \t\treturn; \tif (!EC_get_builtin_curves(curves, crv_len)) \t\t{ \t\tOPENSSL_free(curves); \t\treturn; \t\t} \tfprintf(stdout, \"testing internal curves: \"); \tfor (n = 0; n < crv_len; n++) \t\t{ \t\tEC_GROUP *group = NULL; \t\tint nid = curves[n].nid; \t\tif ((group = EC_GROUP_new_by_curve_name(nid)) == NULL) \t\t\t{ \t\t\tok = 0; \t\t\tfprintf(stdout, \"\\nEC_GROUP_new_curve_name() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\t/* try next curve */ \t\t\tcontinue; \t\t\t} \t\tif (!EC_GROUP_check(group, NULL)) \t\t\t{ \t\t\tok = 0; \t\t\tfprintf(stdout, \"\\nEC_GROUP_check() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\tEC_GROUP_free(group); \t\t\t/* try the next curve */ \t\t\tcontinue; \t\t\t} \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tEC_GROUP_free(group); \t\t} \tif (ok) \t\tfprintf(stdout, \" ok\\n\\n\"); \telse \t\t{ \t\tfprintf(stdout, \" failed\\n\\n\"); \t\tABORT; \t\t} \tOPENSSL_free(curves); \treturn; \t} #ifndef OPENSSL_NO_EC_NISTP_64_GCC_128 /* nistp_test_params contains magic numbers for testing our optimized  * implementations of several NIST curves with characteristic > 3. */ struct nistp_test_params \t{ \tconst EC_METHOD* (*meth) (); \tint degree; \t/* Qx, Qy and D are taken from \t * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/ECDSA_Prime.pdf \t * Otherwise, values are standard curve parameters from FIPS 180-3 */ \tconst char *p, *a, *b, *Qx, *Qy, *Gx, *Gy, *order, *d; \t}; static const struct nistp_test_params nistp_tests_params[] = \t{ \t\t{ \t\t/* P-224 */ \t\tEC_GFp_nistp224_method, \t\t224,-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\", /* p */-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\", /* a */-\t\t\"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\", /* b */-\t\t\"E84FB0B8E7000CB657D7973CF6B42ED78B301674276DF744AF130B3E\", /* Qx */-\t\t\"4376675C6FC5612C21A0FF2D2A89D2987DF7A2BC52183B5982298555\", /* Qy */-\t\t\"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\", /* Gx */-\t\t\"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\", /* Gy */-\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\", /* order */-\t\t\"3F0C488E987C80BE0FEE521F8D90BE6034EC69AE11CA72AA777481E8\", /* d */+\t\t/* p */+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\",+\t\t/* a */+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\",+\t\t/* b */+\t\t\"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\",+\t\t/* Qx */+\t\t\"E84FB0B8E7000CB657D7973CF6B42ED78B301674276DF744AF130B3E\",+\t\t/* Qy */+\t\t\"4376675C6FC5612C21A0FF2D2A89D2987DF7A2BC52183B5982298555\",+\t\t/* Gx */+\t\t\"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\",+\t\t/* Gy */+\t\t\"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\",+\t\t/* order */+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\",+\t\t/* d */+\t\t\"3F0C488E987C80BE0FEE521F8D90BE6034EC69AE11CA72AA777481E8\", \t\t}, \t\t{ \t\t/* P-256 */ \t\tEC_GFp_nistp256_method, \t\t256,-\t\t\"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff\", /* p */-\t\t\"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc\", /* a */-\t\t\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", /* b */-\t\t\"b7e08afdfe94bad3f1dc8c734798ba1c62b3a0ad1e9ea2a38201cd0889bc7a19\", /* Qx */-\t\t\"3603f747959dbf7a4bb226e41928729063adc7ae43529e61b563bbc606cc5e09\", /* Qy */-\t\t\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", /* Gx */-\t\t\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\", /* Gy */-\t\t\"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\", /* order */-\t\t\"c477f9f65c22cce20657faa5b2d1d8122336f851a508a1ed04e479c34985bf96\", /* d */+\t\t/* p */+\t\t\"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff\",+\t\t/* a */+\t\t\"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc\",+\t\t/* b */+\t\t\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\",+\t\t/* Qx */+\t\t\"b7e08afdfe94bad3f1dc8c734798ba1c62b3a0ad1e9ea2a38201cd0889bc7a19\",+\t\t/* Qy */+\t\t\"3603f747959dbf7a4bb226e41928729063adc7ae43529e61b563bbc606cc5e09\",+\t\t/* Gx */+\t\t\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\",+\t\t/* Gy */+\t\t\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\",+\t\t/* order */+\t\t\"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\",+\t\t/* d */+\t\t\"c477f9f65c22cce20657faa5b2d1d8122336f851a508a1ed04e479c34985bf96\", \t\t}, \t\t{ \t\t/* P-521 */ \t\tEC_GFp_nistp521_method, \t\t521,-\t\t\"1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", /* p */-\t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\", /* a */-\t\t\"051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\", /* b */-\t\t\"0098e91eef9a68452822309c52fab453f5f117c1da8ed796b255e9ab8f6410cca16e59df403a6bdc6ca467a37056b1e54b3005d8ac030decfeb68df18b171885d5c4\", /* Qx */-\t\t\"0164350c321aecfc1cca1ba4364c9b15656150b4b78d6a48d7d28e7f31985ef17be8554376b72900712c4b83ad668327231526e313f5f092999a4632fd50d946bc2e\", /* Qy */-\t\t\"c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\", /* Gx */-\t\t\"11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\", /* Gy */-\t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409\", /* order */-\t\t\"0100085f47b8e1b8b11b7eb33028c0b2888e304bfc98501955b45bba1478dc184eeedf09b86a5f7c21994406072787205e69a63709fe35aa93ba333514b24f961722\", /* d */+\t\t/* p */+\t\t\"1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\",+\t\t/* a */+\t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\",+\t\t/* b */+\t\t\"051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\",+\t\t/* Qx */+\t\t\"0098e91eef9a68452822309c52fab453f5f117c1da8ed796b255e9ab8f6410cca16e59df403a6bdc6ca467a37056b1e54b3005d8ac030decfeb68df18b171885d5c4\",+\t\t/* Qy */+\t\t\"0164350c321aecfc1cca1ba4364c9b15656150b4b78d6a48d7d28e7f31985ef17be8554376b72900712c4b83ad668327231526e313f5f092999a4632fd50d946bc2e\",+\t\t/* Gx */+\t\t\"c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\",+\t\t/* Gy */+\t\t\"11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\",+\t\t/* order */+\t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409\",+\t\t/* d */+\t\t\"0100085f47b8e1b8b11b7eb33028c0b2888e304bfc98501955b45bba1478dc184eeedf09b86a5f7c21994406072787205e69a63709fe35aa93ba333514b24f961722\", \t\t}, \t};",
            "commit_date": "2015-01-21 12:19:08+00:00",
            "commit_hash": "b853717fc42e52dece0e362f49fb783e698ef320",
            "message": "Fix strange formatting by indent\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1217,114 +1218,114 @@ \t{ \tEC_builtin_curve *curves = NULL; \tsize_t crv_len = 0, n = 0; \tint    ok = 1; \tcrv_len = EC_get_builtin_curves(NULL, 0); \tcurves = OPENSSL_malloc(sizeof(EC_builtin_curve) * crv_len); \tif (curves == NULL) \t\treturn; \tif (!EC_get_builtin_curves(curves, crv_len)) \t\t{ \t\tOPENSSL_free(curves); \t\treturn; \t\t} \tfprintf(stdout, \"testing internal curves: \"); \tfor (n = 0; n < crv_len; n++) \t\t{ \t\tEC_GROUP *group = NULL; \t\tint nid = curves[n].nid; \t\tif ((group = EC_GROUP_new_by_curve_name(nid)) == NULL) \t\t\t{ \t\t\tok = 0; \t\t\tfprintf(stdout, \"\\nEC_GROUP_new_curve_name() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\t/* try next curve */ \t\t\tcontinue; \t\t\t} \t\tif (!EC_GROUP_check(group, NULL)) \t\t\t{ \t\t\tok = 0; \t\t\tfprintf(stdout, \"\\nEC_GROUP_check() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\tEC_GROUP_free(group); \t\t\t/* try the next curve */ \t\t\tcontinue; \t\t\t} \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tEC_GROUP_free(group); \t\t} \tif (ok) \t\tfprintf(stdout, \" ok\\n\\n\"); \telse \t\t{ \t\tfprintf(stdout, \" failed\\n\\n\"); \t\tABORT; \t\t} \tOPENSSL_free(curves); \treturn; \t}-#ifdef EC_NISTP_64_GCC_128+#ifndef OPENSSL_NO_EC_NISTP_64_GCC_128 /* nistp_test_params contains magic numbers for testing our optimized  * implementations of several NIST curves with characteristic > 3. */ struct nistp_test_params \t{ \tconst EC_METHOD* (*meth) (); \tint degree; \t/* Qx, Qy and D are taken from \t * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/ECDSA_Prime.pdf \t * Otherwise, values are standard curve parameters from FIPS 180-3 */ \tconst char *p, *a, *b, *Qx, *Qy, *Gx, *Gy, *order, *d; \t}; static const struct nistp_test_params nistp_tests_params[] = \t{ \t\t{ \t\t/* P-224 */ \t\tEC_GFp_nistp224_method, \t\t224, \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\", /* p */ \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\", /* a */ \t\t\"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\", /* b */ \t\t\"E84FB0B8E7000CB657D7973CF6B42ED78B301674276DF744AF130B3E\", /* Qx */ \t\t\"4376675C6FC5612C21A0FF2D2A89D2987DF7A2BC52183B5982298555\", /* Qy */ \t\t\"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\", /* Gx */ \t\t\"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\", /* Gy */ \t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\", /* order */ \t\t\"3F0C488E987C80BE0FEE521F8D90BE6034EC69AE11CA72AA777481E8\", /* d */ \t\t}, \t\t{ \t\t/* P-256 */ \t\tEC_GFp_nistp256_method, \t\t256, \t\t\"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff\", /* p */ \t\t\"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc\", /* a */ \t\t\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", /* b */ \t\t\"b7e08afdfe94bad3f1dc8c734798ba1c62b3a0ad1e9ea2a38201cd0889bc7a19\", /* Qx */ \t\t\"3603f747959dbf7a4bb226e41928729063adc7ae43529e61b563bbc606cc5e09\", /* Qy */ \t\t\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", /* Gx */ \t\t\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\", /* Gy */ \t\t\"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\", /* order */ \t\t\"c477f9f65c22cce20657faa5b2d1d8122336f851a508a1ed04e479c34985bf96\", /* d */ \t\t}, \t\t{ \t\t/* P-521 */ \t\tEC_GFp_nistp521_method, \t\t521, \t\t\"1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", /* p */ \t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\", /* a */ \t\t\"051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\", /* b */ \t\t\"0098e91eef9a68452822309c52fab453f5f117c1da8ed796b255e9ab8f6410cca16e59df403a6bdc6ca467a37056b1e54b3005d8ac030decfeb68df18b171885d5c4\", /* Qx */ \t\t\"0164350c321aecfc1cca1ba4364c9b15656150b4b78d6a48d7d28e7f31985ef17be8554376b72900712c4b83ad668327231526e313f5f092999a4632fd50d946bc2e\", /* Qy */ \t\t\"c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\", /* Gx */ \t\t\"11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\", /* Gy */ \t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409\", /* order */ \t\t\"0100085f47b8e1b8b11b7eb33028c0b2888e304bfc98501955b45bba1478dc184eeedf09b86a5f7c21994406072787205e69a63709fe35aa93ba333514b24f961722\", /* d */ \t\t}, \t};",
            "commit_date": "2011-10-19 08:59:53+00:00",
            "commit_hash": "e0d6132b8c2803f62a492b3d5fcdaee046292dbb",
            "message": "Fix warnings.\nAlso, use the common Configure mechanism for enabling/disabling the 64-bit ECC code."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1217,55 +1217,114 @@ \t{ \tEC_builtin_curve *curves = NULL; \tsize_t crv_len = 0, n = 0; \tint    ok = 1; \tcrv_len = EC_get_builtin_curves(NULL, 0); \tcurves = OPENSSL_malloc(sizeof(EC_builtin_curve) * crv_len); \tif (curves == NULL) \t\treturn; \tif (!EC_get_builtin_curves(curves, crv_len)) \t\t{ \t\tOPENSSL_free(curves); \t\treturn; \t\t} \tfprintf(stdout, \"testing internal curves: \"); \tfor (n = 0; n < crv_len; n++) \t\t{ \t\tEC_GROUP *group = NULL; \t\tint nid = curves[n].nid; \t\tif ((group = EC_GROUP_new_by_curve_name(nid)) == NULL) \t\t\t{ \t\t\tok = 0; \t\t\tfprintf(stdout, \"\\nEC_GROUP_new_curve_name() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\t/* try next curve */ \t\t\tcontinue; \t\t\t} \t\tif (!EC_GROUP_check(group, NULL)) \t\t\t{ \t\t\tok = 0; \t\t\tfprintf(stdout, \"\\nEC_GROUP_check() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\tEC_GROUP_free(group); \t\t\t/* try the next curve */ \t\t\tcontinue; \t\t\t} \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tEC_GROUP_free(group); \t\t} \tif (ok) \t\tfprintf(stdout, \" ok\\n\\n\"); \telse+\t\t{ \t\tfprintf(stdout, \" failed\\n\\n\");+\t\tABORT;+\t\t} \tOPENSSL_free(curves); \treturn; \t}-#ifdef EC_NISTP224_64_GCC_128-void nistp224_test()+#ifdef EC_NISTP_64_GCC_128+/* nistp_test_params contains magic numbers for testing our optimized+ * implementations of several NIST curves with characteristic > 3. */+struct nistp_test_params+\t{+\tconst EC_METHOD* (*meth) ();+\tint degree;+\t/* Qx, Qy and D are taken from+\t * http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/ECDSA_Prime.pdf+\t * Otherwise, values are standard curve parameters from FIPS 180-3 */+\tconst char *p, *a, *b, *Qx, *Qy, *Gx, *Gy, *order, *d;+\t};++static const struct nistp_test_params nistp_tests_params[] =+\t{+\t\t{+\t\t/* P-224 */+\t\tEC_GFp_nistp224_method,+\t\t224,+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\", /* p */+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\", /* a */+\t\t\"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\", /* b */+\t\t\"E84FB0B8E7000CB657D7973CF6B42ED78B301674276DF744AF130B3E\", /* Qx */+\t\t\"4376675C6FC5612C21A0FF2D2A89D2987DF7A2BC52183B5982298555\", /* Qy */+\t\t\"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\", /* Gx */+\t\t\"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\", /* Gy */+\t\t\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\", /* order */+\t\t\"3F0C488E987C80BE0FEE521F8D90BE6034EC69AE11CA72AA777481E8\", /* d */+\t\t},+\t\t{+\t\t/* P-256 */+\t\tEC_GFp_nistp256_method,+\t\t256,+\t\t\"ffffffff00000001000000000000000000000000ffffffffffffffffffffffff\", /* p */+\t\t\"ffffffff00000001000000000000000000000000fffffffffffffffffffffffc\", /* a */+\t\t\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", /* b */+\t\t\"b7e08afdfe94bad3f1dc8c734798ba1c62b3a0ad1e9ea2a38201cd0889bc7a19\", /* Qx */+\t\t\"3603f747959dbf7a4bb226e41928729063adc7ae43529e61b563bbc606cc5e09\", /* Qy */+\t\t\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", /* Gx */+\t\t\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\", /* Gy */+\t\t\"ffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\", /* order */+\t\t\"c477f9f65c22cce20657faa5b2d1d8122336f851a508a1ed04e479c34985bf96\", /* d */+\t\t},+\t\t{+\t\t/* P-521 */+\t\tEC_GFp_nistp521_method,+\t\t521,+\t\t\"1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", /* p */+\t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\", /* a */+\t\t\"051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\", /* b */+\t\t\"0098e91eef9a68452822309c52fab453f5f117c1da8ed796b255e9ab8f6410cca16e59df403a6bdc6ca467a37056b1e54b3005d8ac030decfeb68df18b171885d5c4\", /* Qx */+\t\t\"0164350c321aecfc1cca1ba4364c9b15656150b4b78d6a48d7d28e7f31985ef17be8554376b72900712c4b83ad668327231526e313f5f092999a4632fd50d946bc2e\", /* Qy */+\t\t\"c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\", /* Gx */+\t\t\"11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\", /* Gy */+\t\t\"1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409\", /* order */+\t\t\"0100085f47b8e1b8b11b7eb33028c0b2888e304bfc98501955b45bba1478dc184eeedf09b86a5f7c21994406072787205e69a63709fe35aa93ba333514b24f961722\", /* d */+\t\t},+\t};",
            "commit_date": "2011-10-18 19:43:16+00:00",
            "commit_hash": "3e00b4c9db42818c621f609e70569c7d9ae85717",
            "message": "Improve optional 64-bit NIST-P224 implementation, and add NIST-P256 and\nNIST-P521. (Now -DEC_NISTP_64_GCC_128 enables all three of these;\n-DEC_NISTP224_64_GCC_128 no longer works.)\nSubmitted by: Google Inc."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1244,53 +1214,55 @@ \t{ \tEC_builtin_curve *curves = NULL; \tsize_t crv_len = 0, n = 0; \tint    ok = 1; \tcrv_len = EC_get_builtin_curves(NULL, 0); \tcurves = OPENSSL_malloc(sizeof(EC_builtin_curve) * crv_len); \tif (curves == NULL) \t\treturn; \tif (!EC_get_builtin_curves(curves, crv_len)) \t\t{ \t\tOPENSSL_free(curves); \t\treturn; \t\t} \tfprintf(stdout, \"testing internal curves: \"); \tfor (n = 0; n < crv_len; n++) \t\t{ \t\tEC_GROUP *group = NULL; \t\tint nid = curves[n].nid; \t\tif ((group = EC_GROUP_new_by_curve_name(nid)) == NULL) \t\t\t{ \t\t\tok = 0; \t\t\tfprintf(stdout, \"\\nEC_GROUP_new_curve_name() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\t/* try next curve */ \t\t\tcontinue; \t\t\t} \t\tif (!EC_GROUP_check(group, NULL)) \t\t\t{ \t\t\tok = 0; \t\t\tfprintf(stdout, \"\\nEC_GROUP_check() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\tEC_GROUP_free(group); \t\t\t/* try the next curve */ \t\t\tcontinue; \t\t\t} \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tEC_GROUP_free(group); \t\t} \tif (ok)-\t\tfprintf(stdout, \" ok\\n\");+\t\tfprintf(stdout, \" ok\\n\\n\"); \telse-\t\tfprintf(stdout, \" failed\\n\");+\t\tfprintf(stdout, \" failed\\n\\n\"); \tOPENSSL_free(curves); \treturn; \t}+#ifdef EC_NISTP224_64_GCC_128+void nistp224_test()",
            "commit_date": "2010-08-26 14:29:55+00:00",
            "commit_hash": "04daec862ced4e5e3921724b7a59c432fa9cbab3",
            "message": "New 64-bit optimized implementation EC_GFp_nistp224_method().\nThis will only be compiled in if explicitly requested\n(#ifdef EC_NISTP224_64_GCC_128).\nSubmitted by: Emilia Kasper (Google)"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1231,53 +1231,53 @@ \t{ \tEC_builtin_curve *curves = NULL; \tsize_t crv_len = 0, n = 0; \tint    ok = 1; \tcrv_len = EC_get_builtin_curves(NULL, 0); \tcurves = OPENSSL_malloc(sizeof(EC_builtin_curve) * crv_len); \tif (curves == NULL) \t\treturn; \tif (!EC_get_builtin_curves(curves, crv_len)) \t\t{ \t\tOPENSSL_free(curves); \t\treturn; \t\t} \tfprintf(stdout, \"testing internal curves: \"); \tfor (n = 0; n < crv_len; n++) \t\t{ \t\tEC_GROUP *group = NULL; \t\tint nid = curves[n].nid;-\t\tif ((group = EC_GROUP_new_by_nid(nid)) == NULL)+\t\tif ((group = EC_GROUP_new_by_curve_name(nid)) == NULL) \t\t\t{ \t\t\tok = 0;-\t\t\tfprintf(stdout, \"\\nEC_GROUP_new_by_nid() failed with\"+\t\t\tfprintf(stdout, \"\\nEC_GROUP_new_curve_name() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\t/* try next curve */ \t\t\tcontinue; \t\t\t} \t\tif (!EC_GROUP_check(group, NULL)) \t\t\t{ \t\t\tok = 0; \t\t\tfprintf(stdout, \"\\nEC_GROUP_check() failed with\" \t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid)); \t\t\tEC_GROUP_free(group); \t\t\t/* try the next curve */ \t\t\tcontinue; \t\t\t} \t\tfprintf(stdout, \".\"); \t\tfflush(stdout); \t\tEC_GROUP_free(group); \t\t} \tif (ok) \t\tfprintf(stdout, \" ok\\n\"); \telse \t\tfprintf(stdout, \" failed\\n\"); \tOPENSSL_free(curves); \treturn; \t}",
            "commit_date": "2005-05-10 11:37:47+00:00",
            "commit_hash": "8b15c740180725e3e1e71ff619151840cdec46a5",
            "message": "give EC_GROUP_new_by_nid a more meanigful name:\nEC_GROUP_new_by_nid -> EC_GROUP_new_by_curve_name"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1142,0 +1145,53 @@+\t{+\tEC_builtin_curve *curves = NULL;+\tsize_t crv_len = 0, n = 0;+\tint    ok = 1;++\tcrv_len = EC_get_builtin_curves(NULL, 0);++\tcurves = OPENSSL_malloc(sizeof(EC_builtin_curve) * crv_len);++\tif (curves == NULL)+\t\treturn;++\tif (!EC_get_builtin_curves(curves, crv_len))+\t\t{+\t\tOPENSSL_free(curves);+\t\treturn;+\t\t}++\tfprintf(stdout, \"testing internal curves: \");+\t\t+\tfor (n = 0; n < crv_len; n++)+\t\t{+\t\tEC_GROUP *group = NULL;+\t\tint nid = curves[n].nid;+\t\tif ((group = EC_GROUP_new_by_nid(nid)) == NULL)+\t\t\t{+\t\t\tok = 0;+\t\t\tfprintf(stdout, \"\\nEC_GROUP_new_by_nid() failed with\"+\t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid));+\t\t\t/* try next curve */+\t\t\tcontinue;+\t\t\t}+\t\tif (!EC_GROUP_check(group, NULL))+\t\t\t{+\t\t\tok = 0;+\t\t\tfprintf(stdout, \"\\nEC_GROUP_check() failed with\"+\t\t\t\t\" curve %s\\n\", OBJ_nid2sn(nid));+\t\t\tEC_GROUP_free(group);+\t\t\t/* try the next curve */+\t\t\tcontinue;+\t\t\t}+\t\tfprintf(stdout, \".\");+\t\tfflush(stdout);+\t\tEC_GROUP_free(group);+\t\t}+\tif (ok)+\t\tfprintf(stdout, \" ok\\n\");+\telse+\t\tfprintf(stdout, \" failed\\n\");+\tOPENSSL_free(curves);+\treturn;+\t}+",
            "commit_date": "2002-11-11 10:25:12+00:00",
            "commit_hash": "d742bd882e7b9c124c56a97f4c0d86e34a8b3ec5",
            "message": "do tests with all built-in curves\nSubmitted by: Nils Larsch"
        }
    ],
    "git log -L97,107:test/params_test.c": [
        {
            "author": {
                "email": "pauli@openssl.org",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- a/test/params_test.c+++ b/test/params_test.c@@ -97,8 +97,11 @@ static void *init_object(void) {-    struct object_st *obj = OPENSSL_zalloc(sizeof(*obj));+    struct object_st *obj;++    if (!TEST_ptr(obj = OPENSSL_zalloc(sizeof(*obj))))+        return NULL;",
            "commit_date": "2021-06-25 12:57:53+10:00",
            "commit_hash": "f06c5547605b1e400f95eafb77a42947e4d50b78",
            "message": "test: check for NULL returns better\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/15910)\nobj->p1 = p1_init;\nobj->p2 = p2_init;\nif (!TEST_true(BN_hex2bn(&obj->p3, p3_init)))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/params_test.c b/test/params_test.c--- /dev/null+++ b/test/params_test.c@@ -0,0 +86,8 @@++static void *init_object(void)+{+    struct object_st *obj = OPENSSL_zalloc(sizeof(*obj));++    obj->p1 = p1_init;+    obj->p2 = p2_init;+    if (!TEST_true(BN_hex2bn(&obj->p3, p3_init)))",
            "commit_date": "2019-03-04 17:22:45+01:00",
            "commit_hash": "9ad41d246f43d410ab4805e09786a88d56371908",
            "message": "test/params_test.c: Add \"real world\" parameter testing\ntest/params_test.c is a program that tries to mimic how a provider and\nan application would or could handle OSSL_PARAM arrays.\nFor the moment, this program tests a very raw way of handling\nOSSL_PARAM arrays.  It is, however, written in a way that will\nhopefully make it possible to extend with other methods as APIs arise,\nand to set up test cases where a \"provider\" handles the array one way\nwhile the \"application\" handles it another way.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8396)"
        }
    ],
    "git log -L332,339:test/bftest.c": [
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/bftest.c b/test/bftest.c--- a/test/bftest.c+++ b/test/bftest.c@@ -339,8 +339,8 @@ static int test_bf_set_key(int n) {-    int i, ret = 1;+    int ret = 1;",
            "commit_date": "2017-04-12 11:56:45+10:00",
            "commit_hash": "0bf3c66c9d5cfc4dc7b0eee326ac3554956d7aa3",
            "message": "Remove unused variable. Thanks @pauli-oracle\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3177)\nBF_KEY key;\nunsigned char out[8];\nBF_set_key(&key, n+1, key_test);"
        },
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/bftest.c b/test/bftest.c--- a/test/bftest.c+++ b/test/bftest.c@@ -349,8 +339,8 @@-    /* ECB Mode */-    for (n = 0; n < NUM_TESTS; n++) {-        BF_set_key(&key, 8, ecb_data[n]);+static int test_bf_set_key(int n)+{+    int i, ret = 1;+    BF_KEY key;+    unsigned char out[8];-        BF_ecb_encrypt(&(plain_data[n][0]), out, &key, BF_ENCRYPT);-        if (!TEST_mem_eq(&(cipher_data[n][0]), 8, out, 8))-            ret = 0;+    BF_set_key(&key, n+1, key_test);",
            "commit_date": "2017-04-12 11:03:29+10:00",
            "commit_hash": "56bf5c55cd7d751390e92aad2b2bd9cc031b1e43",
            "message": "Code review. Split tests up\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3177)"
        },
        {
            "author": {
                "email": "jon.spillett@oracle.com",
                "name": "Jon Spillett"
            },
            "changes": "diff --git a/test/bftest.c b/test/bftest.c--- a/test/bftest.c+++ b/test/bftest.c@@ -361,19 +349,8 @@-    printf(\"testing blowfish in ecb mode\\n\");-+    /* ECB Mode */-        if (memcmp(&(cipher_data[n][0]), out, 8) != 0) {-            printf(\"BF_ecb_encrypt blowfish error encrypting\\n\");-            printf(\"got     :\");-            for (i = 0; i < 8; i++)-                printf(\"%02X \", out[i]);-            printf(\"\\n\");-            printf(\"expected:\");-            for (i = 0; i < 8; i++)-                printf(\"%02X \", cipher_data[n][i]);-            err = 1;-            printf(\"\\n\");-        }+        if (!TEST_mem_eq(&(cipher_data[n][0]), 8, out, 8))+            ret = 0;",
            "commit_date": "2017-04-11 14:31:28+10:00",
            "commit_hash": "70e1acd786511724e3680790f358d1fc4756a49b",
            "message": "Convert blowfish tests to new framework\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3177)\nfor (n = 0; n < NUM_TESTS; n++) {\nBF_set_key(&key, 8, ecb_data[n]);\nBF_ecb_encrypt(&(plain_data[n][0]), out, &key, BF_ENCRYPT);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -356,184 +415,19 @@-\t{-\tunsigned char cbc_in[40],cbc_out[40],iv[8];-\tint i,n,err=0;-\tBF_KEY key;-\tBF_LONG data[2]; -\tunsigned char out[8]; -\tBF_LONG len;--#ifdef CHARSET_EBCDIC-\tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data));-#endif--\tprintf(\"testing blowfish in raw ecb mode\\n\");-\tfor (n=0; n<2; n++)-\t\t{-#ifdef CHARSET_EBCDIC-\t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n]));-#endif-\t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]);--\t\tdata[0]=bf_plain[n][0];-\t\tdata[1]=bf_plain[n][1];-\t\tBF_encrypt(data,&key);-\t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_encrypt error encrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]);-\t\t\terr=1;-\t\t\tprintf(\"\\n\");-\t\t\t}--\t\tBF_decrypt(&(data[0]),&key);-\t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_encrypt error decrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]);-\t\t\tprintf(\"\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish in ecb mode\\n\");--\tfor (n=0; n<NUM_TESTS; n++)-\t\t{-\t\tBF_set_key(&key,8,ecb_data[n]);--\t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT);-\t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",out[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",cipher_data[n][i]);-\t\t\terr=1;-\t\t\tprintf(\"\\n\");-\t\t\t}--\t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT);-\t\tif (memcmp(&(plain_data[n][0]),out,8) != 0)-\t\t\t{-\t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\");-\t\t\tprintf(\"got     :\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",out[i]);-\t\t\tprintf(\"\\n\");-\t\t\tprintf(\"expected:\");-\t\t\tfor (i=0; i<8; i++)-\t\t\t\tprintf(\"%02X \",plain_data[n][i]);-\t\t\tprintf(\"\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish set_key\\n\");-\tfor (n=1; n<KEY_TEST_NUM; n++)-\t\t{-\t\tBF_set_key(&key,n,key_test);-\t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);-\t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */-\t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0)-\t\t\t{-\t\t\tprintf(\"blowfish setkey error\\n\");-\t\t\terr=1;-\t\t\t}-\t\t}--\tprintf(\"testing blowfish in cbc mode\\n\");-\tlen=strlen(cbc_data)+1;--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,sizeof cbc_in);-\tmemset(cbc_out,0,sizeof cbc_out);-\tmemcpy(iv,cbc_iv,sizeof iv);-\tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len,-\t\t&key,iv,BF_ENCRYPT);-\tif (memcmp(cbc_out,cbc_ok,32) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_cbc_encrypt encrypt error\\n\");-\t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tmemcpy(iv,cbc_iv,8);-\tBF_cbc_encrypt(cbc_out,cbc_in,len,-\t\t&key,iv,BF_DECRYPT);-\tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)-\t\t{-\t\tprintf(\"BF_cbc_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\tprintf(\"testing blowfish in cfb64 mode\\n\");--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);-\tn=0;-\tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,-\t\t&key,iv,&n,BF_ENCRYPT);-\tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13,-\t\t&key,iv,&n,BF_ENCRYPT);-\tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\");-\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tn=0;-\tmemcpy(iv,cbc_iv,8);-\tBF_cfb64_encrypt(cbc_out,cbc_in,17,-\t\t&key,iv,&n,BF_DECRYPT);-\tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,-\t\t&key,iv,&n,BF_DECRYPT);-\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)-\t\t{-\t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\tprintf(\"testing blowfish in ofb64\\n\");--\tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);-\tn=0;-\tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n);-\tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]),-\t\t&(cbc_out[13]),len-13,&key,iv,&n);-\tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0)-\t\t{-\t\terr=1;-\t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\");-\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);-\t\t}-\tn=0;-\tmemcpy(iv,cbc_iv,8);-\tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n);-\tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n);-\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)-\t\t{-\t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\");-\t\terr=1;-\t\t}--\treturn(err);-\t}++    printf(\"testing blowfish in ecb mode\\n\");++    for (n = 0; n < NUM_TESTS; n++) {+        BF_set_key(&key, 8, ecb_data[n]);++        BF_ecb_encrypt(&(plain_data[n][0]), out, &key, BF_ENCRYPT);+        if (memcmp(&(cipher_data[n][0]), out, 8) != 0) {+            printf(\"BF_ecb_encrypt blowfish error encrypting\\n\");+            printf(\"got     :\");+            for (i = 0; i < 8; i++)+                printf(\"%02X \", out[i]);+            printf(\"\\n\");+            printf(\"expected:\");+            for (i = 0; i < 8; i++)+                printf(\"%02X \", cipher_data[n][i]);+            err = 1;+            printf(\"\\n\");+        }",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -350,184 +350,184 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; #ifdef CHARSET_EBCDIC \tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data)); #endif \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ #ifdef CHARSET_EBCDIC \t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n])); #endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */ \t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key);-\tmemset(cbc_in,0,40);-\tmemset(cbc_out,0,40);-\tmemcpy(iv,cbc_iv,8);+\tmemset(cbc_in,0,sizeof cbc_in);+\tmemset(cbc_out,0,sizeof cbc_out);+\tmemcpy(iv,cbc_iv,sizeof iv); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "2002-11-13 15:43:43+00:00",
            "commit_hash": "54a656ef081f72a740c550ebd8099b40b8b5cde0",
            "message": "Security fixes brought forward from 0.9.7."
        },
        {
            "author": {
                "email": "appro@openssl.org",
                "name": "Andy Polyakov"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -350,183 +350,184 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; #ifdef CHARSET_EBCDIC \tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data)); #endif \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ #ifdef CHARSET_EBCDIC \t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n])); #endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);-\t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0)+\t\t/* mips-sgi-irix6.5-gcc  vv  -mabi=64 bug workaround */+\t\tif (memcmp(out,&(key_out[i=n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "2000-06-05 14:39:47+00:00",
            "commit_hash": "e6441154fc8365f0be481d9f619caedc019283d6",
            "message": "GCC 2.95.2 from IRIX 6.5 -mabi=64 compiler bug workaround:-(\nSubmitted by:\nReviewed by:\nPR:"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -346,176 +350,183 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len;+#ifdef CHARSET_EBCDIC+\tebcdic2ascii(cbc_data, cbc_data, strlen(cbc_data));+#endif+ \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{+#ifdef CHARSET_EBCDIC+\t\tebcdic2ascii(bf_key[n], bf_key[n], strlen(bf_key[n]));+#endif \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1999-06-04 21:35:58+00:00",
            "commit_hash": "a53955d8abd68c604de02cc1e101c66169207fb7",
            "message": "Support the EBCDIC character set and BS2000/OSD-POSIX (work in progress).\nSubmitted by: Martin Kraemer <Martin.Kraemer@MchP.Siemens.De>"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -344,176 +344,176 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1]; \t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++)-\t\t\t\tprintf(\"%08lX \",bf_plain[n][i]);+\t\t\t\tprintf(\"%08lX \",(unsigned long)bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1999-04-20 22:48:55+00:00",
            "commit_hash": "f36cd05b22a587e552c97797b54fd07bc0762446",
            "message": "Fix some warnings."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- a/crypto/bf/bftest.c+++ b/crypto/bf/bftest.c@@ -346,176 +346,176 @@ \t{ \tunsigned char cbc_in[40],cbc_out[40],iv[8]; \tint i,n,err=0; \tBF_KEY key; \tBF_LONG data[2];  \tunsigned char out[8];  \tBF_LONG len; \tprintf(\"testing blowfish in raw ecb mode\\n\"); \tfor (n=0; n<2; n++) \t\t{ \t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]); \t\tdata[0]=bf_plain[n][0]; \t\tdata[1]=bf_plain[n][1];-\t\tBF_encrypt(data,&key,BF_ENCRYPT);+\t\tBF_encrypt(data,&key); \t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t}-\t\tBF_encrypt(&(data[0]),&key,BF_DECRYPT);+\t\tBF_decrypt(&(data[0]),&key); \t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0) \t\t\t{ \t\t\tprintf(\"BF_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",data[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<2; i++) \t\t\t\tprintf(\"%08lX \",bf_plain[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in ecb mode\\n\"); \tfor (n=0; n<NUM_TESTS; n++) \t\t{ \t\tBF_set_key(&key,8,ecb_data[n]); \t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT); \t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",cipher_data[n][i]); \t\t\terr=1; \t\t\tprintf(\"\\n\"); \t\t\t} \t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT); \t\tif (memcmp(&(plain_data[n][0]),out,8) != 0) \t\t\t{ \t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\"); \t\t\tprintf(\"got     :\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",out[i]); \t\t\tprintf(\"\\n\"); \t\t\tprintf(\"expected:\"); \t\t\tfor (i=0; i<8; i++) \t\t\t\tprintf(\"%02X \",plain_data[n][i]); \t\t\tprintf(\"\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish set_key\\n\"); \tfor (n=1; n<KEY_TEST_NUM; n++) \t\t{ \t\tBF_set_key(&key,n,key_test); \t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT); \t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0) \t\t\t{ \t\t\tprintf(\"blowfish setkey error\\n\"); \t\t\terr=1; \t\t\t} \t\t} \tprintf(\"testing blowfish in cbc mode\\n\"); \tlen=strlen(cbc_data)+1; \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len, \t\t&key,iv,BF_ENCRYPT); \tif (memcmp(cbc_out,cbc_ok,32) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cbc_encrypt encrypt error\\n\"); \t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tmemcpy(iv,cbc_iv,8); \tBF_cbc_encrypt(cbc_out,cbc_in,len, \t\t&key,iv,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0) \t\t{ \t\tprintf(\"BF_cbc_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in cfb64 mode\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13, \t\t&key,iv,&n,BF_ENCRYPT); \tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13, \t\t&key,iv,&n,BF_ENCRYPT); \tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_cfb64_encrypt(cbc_out,cbc_in,17, \t\t&key,iv,&n,BF_DECRYPT); \tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17, \t\t&key,iv,&n,BF_DECRYPT); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \tprintf(\"testing blowfish in ofb64\\n\"); \tBF_set_key(&key,16,cbc_key); \tmemset(cbc_in,0,40); \tmemset(cbc_out,0,40); \tmemcpy(iv,cbc_iv,8); \tn=0; \tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n); \tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]), \t\t&(cbc_out[13]),len-13,&key,iv,&n); \tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0) \t\t{ \t\terr=1; \t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\"); \t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]); \t\t} \tn=0; \tmemcpy(iv,cbc_iv,8); \tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n); \tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n); \tif (memcmp(cbc_in,cbc_data,(int)len) != 0) \t\t{ \t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\"); \t\terr=1; \t\t} \treturn(err); \t}",
            "commit_date": "1998-12-21 10:56:39+00:00",
            "commit_hash": "58964a492275ca9a59a0cd9c8155cb2491b4b909",
            "message": "Import of old SSLeay release: SSLeay 0.9.0b"
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bf/bftest.c b/crypto/bf/bftest.c--- /dev/null+++ b/crypto/bf/bftest.c@@ -0,0 +346,176 @@+\t{+\tunsigned char cbc_in[40],cbc_out[40],iv[8];+\tint i,n,err=0;+\tBF_KEY key;+\tBF_LONG data[2]; +\tunsigned char out[8]; +\tBF_LONG len;++\tprintf(\"testing blowfish in raw ecb mode\\n\");+\tfor (n=0; n<2; n++)+\t\t{+\t\tBF_set_key(&key,strlen(bf_key[n]),(unsigned char *)bf_key[n]);++\t\tdata[0]=bf_plain[n][0];+\t\tdata[1]=bf_plain[n][1];+\t\tBF_encrypt(data,&key,BF_ENCRYPT);+\t\tif (memcmp(&(bf_cipher[n][0]),&(data[0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_encrypt error encrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",bf_cipher[n][i]);+\t\t\terr=1;+\t\t\tprintf(\"\\n\");+\t\t\t}++\t\tBF_encrypt(&(data[0]),&key,BF_DECRYPT);+\t\tif (memcmp(&(bf_plain[n][0]),&(data[0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_encrypt error decrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",data[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<2; i++)+\t\t\t\tprintf(\"%08lX \",bf_plain[n][i]);+\t\t\tprintf(\"\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish in ecb mode\\n\");++\tfor (n=0; n<NUM_TESTS; n++)+\t\t{+\t\tBF_set_key(&key,8,ecb_data[n]);++\t\tBF_ecb_encrypt(&(plain_data[n][0]),out,&key,BF_ENCRYPT);+\t\tif (memcmp(&(cipher_data[n][0]),out,8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_ecb_encrypt blowfish error encrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",out[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",cipher_data[n][i]);+\t\t\terr=1;+\t\t\tprintf(\"\\n\");+\t\t\t}++\t\tBF_ecb_encrypt(out,out,&key,BF_DECRYPT);+\t\tif (memcmp(&(plain_data[n][0]),out,8) != 0)+\t\t\t{+\t\t\tprintf(\"BF_ecb_encrypt error decrypting\\n\");+\t\t\tprintf(\"got     :\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",out[i]);+\t\t\tprintf(\"\\n\");+\t\t\tprintf(\"expected:\");+\t\t\tfor (i=0; i<8; i++)+\t\t\t\tprintf(\"%02X \",plain_data[n][i]);+\t\t\tprintf(\"\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish set_key\\n\");+\tfor (n=1; n<KEY_TEST_NUM; n++)+\t\t{+\t\tBF_set_key(&key,n,key_test);+\t\tBF_ecb_encrypt(key_data,out,&key,BF_ENCRYPT);+\t\tif (memcmp(out,&(key_out[n-1][0]),8) != 0)+\t\t\t{+\t\t\tprintf(\"blowfish setkey error\\n\");+\t\t\terr=1;+\t\t\t}+\t\t}++\tprintf(\"testing blowfish in cbc mode\\n\");+\tlen=strlen(cbc_data)+1;++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tBF_cbc_encrypt((unsigned char *)cbc_data,cbc_out,len,+\t\t&key,iv,BF_ENCRYPT);+\tif (memcmp(cbc_out,cbc_ok,32) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_cbc_encrypt encrypt error\\n\");+\t\tfor (i=0; i<32; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tmemcpy(iv,cbc_iv,8);+\tBF_cbc_encrypt(cbc_out,cbc_in,len,+\t\t&key,iv,BF_DECRYPT);+\tif (memcmp(cbc_in,cbc_data,strlen(cbc_data)+1) != 0)+\t\t{+\t\tprintf(\"BF_cbc_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\tprintf(\"testing blowfish in cfb64 mode\\n\");++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tn=0;+\tBF_cfb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,+\t\t&key,iv,&n,BF_ENCRYPT);+\tBF_cfb64_encrypt((unsigned char *)&(cbc_data[13]),&(cbc_out[13]),len-13,+\t\t&key,iv,&n,BF_ENCRYPT);+\tif (memcmp(cbc_out,cfb64_ok,(int)len) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_cfb64_encrypt encrypt error\\n\");+\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tn=0;+\tmemcpy(iv,cbc_iv,8);+\tBF_cfb64_encrypt(cbc_out,cbc_in,17,+\t\t&key,iv,&n,BF_DECRYPT);+\tBF_cfb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,+\t\t&key,iv,&n,BF_DECRYPT);+\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)+\t\t{+\t\tprintf(\"BF_cfb64_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\tprintf(\"testing blowfish in ofb64\\n\");++\tBF_set_key(&key,16,cbc_key);+\tmemset(cbc_in,0,40);+\tmemset(cbc_out,0,40);+\tmemcpy(iv,cbc_iv,8);+\tn=0;+\tBF_ofb64_encrypt((unsigned char *)cbc_data,cbc_out,(long)13,&key,iv,&n);+\tBF_ofb64_encrypt((unsigned char *)&(cbc_data[13]),+\t\t&(cbc_out[13]),len-13,&key,iv,&n);+\tif (memcmp(cbc_out,ofb64_ok,(int)len) != 0)+\t\t{+\t\terr=1;+\t\tprintf(\"BF_ofb64_encrypt encrypt error\\n\");+\t\tfor (i=0; i<(int)len; i++) printf(\"0x%02X,\",cbc_out[i]);+\t\t}+\tn=0;+\tmemcpy(iv,cbc_iv,8);+\tBF_ofb64_encrypt(cbc_out,cbc_in,17,&key,iv,&n);+\tBF_ofb64_encrypt(&(cbc_out[17]),&(cbc_in[17]),len-17,&key,iv,&n);+\tif (memcmp(cbc_in,cbc_data,(int)len) != 0)+\t\t{+\t\tprintf(\"BF_ofb64_encrypt decrypt error\\n\");+\t\terr=1;+\t\t}++\treturn(err);+\t}",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L23,49:crypto/ec/curve448/arch_64/f_impl64.c": [
        {
            "author": {
                "email": "amitay@ozlabs.org",
                "name": "Amitay Isaacs"
            },
            "changes": "diff --git a/crypto/ec/curve448/arch_64/f_impl.c b/crypto/ec/curve448/arch_64/f_impl.c--- a/crypto/ec/curve448/arch_64/f_impl.c+++ b/crypto/ec/curve448/arch_64/f_impl.c@@ -14,45 +14,27 @@ void gf_mul(gf_s * RESTRICT cs, const gf as, const gf bs) {-    unsigned int i;+    unsigned int i, j;-    int I_HATE_UNROLLED_LOOPS = 0;--    if (I_HATE_UNROLLED_LOOPS) {-        /*-         * The compiler probably won't unroll this, so it's like 80% slower.-         */-        for (i = 0; i < 4; i++) {-            accum2 = 0;--            unsigned int j;-            for (j = 0; j <= i; j++) {-                accum2 += widemul(a[j], b[i - j]);-                accum1 += widemul(aa[j], bb[i - j]);-                accum0 += widemul(a[j + 4], b[i - j + 4]);-            }-            for (; j < 4; j++) {-                accum2 += widemul(a[j], b[i - j + 8]);-                accum1 += widemul(aa[j], bbb[i - j + 4]);-                accum0 += widemul(a[j + 4], bb[i - j + 4]);-            }--            accum1 -= accum2;-            accum0 += accum2;--            c[i] = ((uint64_t)(accum0)) & mask;-            c[i + 4] = ((uint64_t)(accum1)) & mask;+    for (i = 0; i < 4; i++) {+        accum2 = 0;-            accum0 >>= 56;-            accum1 >>= 56;+        for (j = 0; j <= i; j++) {+            accum2 += widemul(a[j], b[i - j]);+            accum1 += widemul(aa[j], bb[i - j]);+            accum0 += widemul(a[j + 4], b[i - j + 4]);+        }+        for (; j < 4; j++) {+            accum2 += widemul(a[j], b[i - j + 8]);+            accum1 += widemul(aa[j], bbb[i - j + 4]);",
            "commit_date": "2021-01-19 14:05:24+11:00",
            "commit_hash": "eb7bcff67c6bbd9cb463c44035afd00c37ca327f",
            "message": "curve448: Remove the unrolled loop version\nSigned-off-by: Amitay Isaacs <amitay@ozlabs.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14784)\nconst uint64_t *a = as->limb, *b = bs->limb;\nuint64_t *c = cs->limb;\nuint128_t accum0 = 0, accum1 = 0, accum2;\nuint64_t mask = (1ULL << 56) - 1;\nuint64_t aa[4], bb[4], bbb[4];\nfor (i = 0; i < 4; i++) {\naa[i] = a[i] + a[i + 4];\nbb[i] = b[i] + b[i + 4];\nbbb[i] = bb[i] + b[i + 4];\n}"
        },
        {
            "author": {
                "email": "amitay@ozlabs.org",
                "name": "Amitay Isaacs"
            },
            "changes": "diff --git a/crypto/ec/curve448/arch_64/f_impl.c b/crypto/ec/curve448/arch_64/f_impl.c--- a/crypto/ec/curve448/arch_64/f_impl.c+++ b/crypto/ec/curve448/arch_64/f_impl.c@@ -13,45 +14,45 @@-void gf_mul(gf_s * __restrict__ cs, const gf as, const gf bs)+void gf_mul(gf_s * RESTRICT cs, const gf as, const gf bs) {-    __uint128_t accum0 = 0, accum1 = 0, accum2;-    uint64_t mask = (1ull << 56) - 1;+    uint128_t accum0 = 0, accum1 = 0, accum2;+    uint64_t mask = (1ULL << 56) - 1;",
            "commit_date": "2021-01-19 14:04:48+11:00",
            "commit_hash": "70fd5110261e9c663b2f6a6009514f72c303d85d",
            "message": "curve448: Modernise reference 64-bit code\nSigned-off-by: Amitay Isaacs <amitay@ozlabs.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14784)\nconst uint64_t *a = as->limb, *b = bs->limb;\nuint64_t *c = cs->limb;\nuint64_t aa[4], bb[4], bbb[4];\nunsigned int i;\nfor (i = 0; i < 4; i++) {\naa[i] = a[i] + a[i + 4];\nbb[i] = b[i] + b[i + 4];\nbbb[i] = bb[i] + b[i + 4];\n}\nint I_HATE_UNROLLED_LOOPS = 0;\nif (I_HATE_UNROLLED_LOOPS) {\n/*\n* The compiler probably won't unroll this, so it's like 80% slower.\n*/\nfor (i = 0; i < 4; i++) {\naccum2 = 0;\nunsigned int j;\nfor (j = 0; j <= i; j++) {\naccum2 += widemul(a[j], b[i - j]);\naccum1 += widemul(aa[j], bb[i - j]);\naccum0 += widemul(a[j + 4], b[i - j + 4]);\n}\nfor (; j < 4; j++) {\naccum2 += widemul(a[j], b[i - j + 8]);\naccum1 += widemul(aa[j], bbb[i - j + 4]);\naccum0 += widemul(a[j + 4], bb[i - j + 4]);\n}\naccum1 -= accum2;\naccum0 += accum2;\nc[i] = ((uint64_t)(accum0)) & mask;\nc[i + 4] = ((uint64_t)(accum1)) & mask;\naccum0 >>= 56;\naccum1 >>= 56;"
        },
        {
            "author": {
                "email": "amitay@ozlabs.org",
                "name": "Amitay Isaacs"
            },
            "changes": "diff --git a/crypto/ec/curve448/arch_ref64/f_impl.c b/crypto/ec/curve448/arch_ref64/f_impl.c--- /dev/null+++ b/crypto/ec/curve448/arch_ref64/f_impl.c@@ -0,0 +13,45 @@++void gf_mul(gf_s * __restrict__ cs, const gf as, const gf bs)+{+    const uint64_t *a = as->limb, *b = bs->limb;+    uint64_t *c = cs->limb;+    __uint128_t accum0 = 0, accum1 = 0, accum2;+    uint64_t mask = (1ull << 56) - 1;+    uint64_t aa[4], bb[4], bbb[4];+    unsigned int i;++    for (i = 0; i < 4; i++) {+        aa[i] = a[i] + a[i + 4];+        bb[i] = b[i] + b[i + 4];+        bbb[i] = bb[i] + b[i + 4];+    }++    int I_HATE_UNROLLED_LOOPS = 0;++    if (I_HATE_UNROLLED_LOOPS) {+        /*+         * The compiler probably won't unroll this, so it's like 80% slower.+         */+        for (i = 0; i < 4; i++) {+            accum2 = 0;++            unsigned int j;+            for (j = 0; j <= i; j++) {+                accum2 += widemul(a[j], b[i - j]);+                accum1 += widemul(aa[j], bb[i - j]);+                accum0 += widemul(a[j + 4], b[i - j + 4]);+            }+            for (; j < 4; j++) {+                accum2 += widemul(a[j], b[i - j + 8]);+                accum1 += widemul(aa[j], bbb[i - j + 4]);+                accum0 += widemul(a[j + 4], bb[i - j + 4]);+            }++            accum1 -= accum2;+            accum0 += accum2;++            c[i] = ((uint64_t)(accum0)) & mask;+            c[i + 4] = ((uint64_t)(accum1)) & mask;++            accum0 >>= 56;+            accum1 >>= 56;",
            "commit_date": "2021-01-19 13:50:18+11:00",
            "commit_hash": "927e704e8c2ec47ca58a86f57dc1900d48ebb985",
            "message": "Partially Revert \"Remove curve448 architecture specific files\"\nThis reverts commit 7e492f3372ed83af074a63d5920f13de7e3455b6.\nThis brings back the 64-bit reference implementation for curve448.\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14784)"
        }
    ],
    "git log -L74,90:apps/lib/app_params.c": [
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/apps/lib/app_params.c b/apps/lib/app_params.c--- a/apps/lib/app_params.c+++ b/apps/lib/app_params.c@@ -74,17 +74,17 @@ int print_param_types(const char *thing, const OSSL_PARAM *pdefs, int indent) {-        BIO_printf(bio_out, \"%*sNo declared %s\\n\", indent, \"\", thing);+        return 1;",
            "commit_date": "2020-08-12 11:59:43+10:00",
            "commit_hash": "e3efe7a53299dff3cd2222542b6a999b1360d626",
            "message": "Add public API for gettables and settables for keymanagement, signatures and key exchange.\nThe openssl provider app will now display these params.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/12396)\nif (pdefs == NULL) {\n} else if (pdefs->key == NULL) {\n/*\n* An empty list?  This shouldn't happen, but let's just make sure to\n* say something if there's a badly written provider...\n*/\nBIO_printf(bio_out, \"%*sEmpty list of %s (!!!)\\n\", indent, \"\", thing);\n} else {\nBIO_printf(bio_out, \"%*s%s:\\n\", indent, \"\", thing);\nfor (; pdefs->key != NULL; pdefs++) {\nchar buf[200];       /* This should be ample space */\ndescribe_param_type(buf, sizeof(buf), pdefs);"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/apps/lib/app_params.c b/apps/lib/app_params.c--- a/apps/lib/app_params.c+++ b/apps/lib/app_params.c@@ -74,17 +74,17 @@ int print_param_types(const char *thing, const OSSL_PARAM *pdefs, int indent) {-        BIO_printf(bio_out, \"%*sNo declared %s\\n\", indent, \" \", thing);+        BIO_printf(bio_out, \"%*sNo declared %s\\n\", indent, \"\", thing);-        BIO_printf(bio_out, \"%*sEmpty list of %s (!!!)\\n\", indent, \" \", thing);+        BIO_printf(bio_out, \"%*sEmpty list of %s (!!!)\\n\", indent, \"\", thing);-        BIO_printf(bio_out, \"%*s%s:\\n\", indent, \" \", thing);+        BIO_printf(bio_out, \"%*s%s:\\n\", indent, \"\", thing);",
            "commit_date": "2019-08-29 15:21:04+10:00",
            "commit_hash": "c92d0c5c6550346cffb942000e99aa88452bde6d",
            "message": "Allow an output indentation of zero in apps.\nPreviously, it would indent one space even if zero were specified.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9725)\nif (pdefs == NULL) {\n} else if (pdefs->key == NULL) {\n/*\n* An empty list?  This shouldn't happen, but let's just make sure to\n* say something if there's a badly written provider...\n*/\n} else {\nfor (; pdefs->key != NULL; pdefs++) {\nchar buf[200];       /* This should be ample space */\ndescribe_param_type(buf, sizeof(buf), pdefs);"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/apps/lib/app_params.c b/apps/lib/app_params.c--- /dev/null+++ b/apps/lib/app_params.c@@ -0,0 +74,17 @@++int print_param_types(const char *thing, const OSSL_PARAM *pdefs, int indent)+{+    if (pdefs == NULL) {+        BIO_printf(bio_out, \"%*sNo declared %s\\n\", indent, \" \", thing);+    } else if (pdefs->key == NULL) {+        /*+         * An empty list?  This shouldn't happen, but let's just make sure to+         * say something if there's a badly written provider...+         */+        BIO_printf(bio_out, \"%*sEmpty list of %s (!!!)\\n\", indent, \" \", thing);+    } else {+        BIO_printf(bio_out, \"%*s%s:\\n\", indent, \" \", thing);+        for (; pdefs->key != NULL; pdefs++) {+            char buf[200];       /* This should be ample space */++            describe_param_type(buf, sizeof(buf), pdefs);",
            "commit_date": "2019-08-26 22:08:04+02:00",
            "commit_hash": "16485a3ada49e68b1ae93ed4fe3b55fdb3a7e61e",
            "message": "Move print_param_types() to libapps, and give it indent argument\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/9697)"
        }
    ],
    "git log -L135,154:test/srptest.c": [
        {
            "author": {
                "email": "paulyang.inf@gmail.com",
                "name": "Paul Yang"
            },
            "changes": "diff --git a/test/srptest.c b/test/srptest.c--- a/test/srptest.c+++ b/test/srptest.c@@ -145,20 +145,20 @@ /* SRP test vectors from RFC5054 */ static int run_srp_kat(void) {-        +",
            "commit_date": "2017-06-06 23:35:43+08:00",
            "commit_hash": "bd91e3c870402c4b10909c47082daece473d22ef",
            "message": "Fix a bundle of trailing spaces in several files\nSigned-off-by: Paul Yang <paulyang.inf@gmail.com>\nReviewed-by: Kurt Roeckx <kurt@openssl.org>\nReviewed-by: Ben Kaduk <kaduk@mit.edu>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3622)\nint ret = 0;\nBIGNUM *s = NULL;\nBIGNUM *v = NULL;\nBIGNUM *a = NULL;\nBIGNUM *b = NULL;\nBIGNUM *u = NULL;\nBIGNUM *x = NULL;\nBIGNUM *Apub = NULL;\nBIGNUM *Bpub = NULL;\nBIGNUM *Kclient = NULL;\nBIGNUM *Kserver = NULL;\n/* use builtin 1024-bit params */\nconst SRP_gN *GN;\nif (!TEST_ptr(GN = SRP_get_default_gN(\"1024\")))\ngoto err;\nBN_hex2bn(&s, \"BEB25379D1A8581EB5A727673A2441EE\");"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/srptest.c b/test/srptest.c--- a/test/srptest.c+++ b/test/srptest.c@@ -157,22 +156,20 @@ /* SRP test vectors from RFC5054 */ static int run_srp_kat(void) {-    const SRP_gN *GN = SRP_get_default_gN(\"1024\");--    if (GN == NULL) {-        fprintf(stderr, \"Failed to get SRP parameters\\n\");+    const SRP_gN *GN;+        +    if (!TEST_ptr(GN = SRP_get_default_gN(\"1024\")))-    }",
            "commit_date": "2017-04-18 14:34:43-04:00",
            "commit_hash": "b66411f6cda6970c01283ddde6d8063c57b3b7d9",
            "message": "Convert more tests\nrecordlentest, srptest, ecdsatest, enginetest, pbelutest\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3237)\nint ret = 0;\nBIGNUM *s = NULL;\nBIGNUM *v = NULL;\nBIGNUM *a = NULL;\nBIGNUM *b = NULL;\nBIGNUM *u = NULL;\nBIGNUM *x = NULL;\nBIGNUM *Apub = NULL;\nBIGNUM *Bpub = NULL;\nBIGNUM *Kclient = NULL;\nBIGNUM *Kserver = NULL;\n/* use builtin 1024-bit params */\ngoto err;\nBN_hex2bn(&s, \"BEB25379D1A8581EB5A727673A2441EE\");"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/test/srptest.c b/test/srptest.c--- a/test/srptest.c+++ b/test/srptest.c@@ -133,0 +157,22 @@+/* SRP test vectors from RFC5054 */+static int run_srp_kat(void)+{+    int ret = 0;+    BIGNUM *s = NULL;+    BIGNUM *v = NULL;+    BIGNUM *a = NULL;+    BIGNUM *b = NULL;+    BIGNUM *u = NULL;+    BIGNUM *x = NULL;+    BIGNUM *Apub = NULL;+    BIGNUM *Bpub = NULL;+    BIGNUM *Kclient = NULL;+    BIGNUM *Kserver = NULL;+    /* use builtin 1024-bit params */+    const SRP_gN *GN = SRP_get_default_gN(\"1024\");++    if (GN == NULL) {+        fprintf(stderr, \"Failed to get SRP parameters\\n\");+        goto err;+    }+    BN_hex2bn(&s, \"BEB25379D1A8581EB5A727673A2441EE\");",
            "commit_date": "2016-09-29 23:22:46+01:00",
            "commit_hash": "198d805900b183943a1ced0f5a230d55c8493a04",
            "message": "Add SRP test vectors from RFC5054\nReviewed-by: Rich Salz <rsalz@openssl.org>"
        }
    ],
    "git log -L780,799:apps/ts.c": [
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/apps/ts.c b/apps/ts.c--- a/apps/ts.c+++ b/apps/ts.c@@ -867,20 +869,20 @@ static ASN1_INTEGER *next_serial(const char *serialfile) {-    if (!(serial = ASN1_INTEGER_new()))+    if ((serial = ASN1_INTEGER_new()) == NULL)-    if (!(in = BIO_new_file(serialfile, \"r\"))) {+    if ((in = BIO_new_file(serialfile, \"r\")) == NULL) {",
            "commit_date": "2015-05-06 13:43:59-04:00",
            "commit_hash": "75ebbd9aa411c5b8b19ded6ace2b34181566b56a",
            "message": "Use p==NULL not !p (in if statements, mainly)\nReviewed-by: Tim Hudson <tjh@openssl.org>\nint ret = 0;\nBIO *in = NULL;\nASN1_INTEGER *serial = NULL;\nBIGNUM *bn = NULL;\ngoto err;\nERR_clear_error();\nBIO_printf(bio_err, \"Warning: could not open file %s for \"\n\"reading, using serial number: 1\\n\", serialfile);\nif (!ASN1_INTEGER_set(serial, 1))\ngoto err;\n} else {\nchar buf[1024];\nif (!a2i_ASN1_INTEGER(in, serial, buf, sizeof(buf))) {"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/apps/ts.c b/apps/ts.c--- a/apps/ts.c+++ b/apps/ts.c@@ -897,33 +877,20 @@ static ASN1_INTEGER *next_serial(const char *serialfile)-\t{-\tint ret = 0;-\tBIO *in = NULL;-\tASN1_INTEGER *serial = NULL;-\tBIGNUM *bn = NULL;--\tif (!(serial = ASN1_INTEGER_new())) goto err;--\tif (!(in = BIO_new_file(serialfile, \"r\"))) -\t\t{-\t\tERR_clear_error();-\t\tBIO_printf(bio_err, \"Warning: could not open file %s for \"-\t\t\t   \"reading, using serial number: 1\\n\", serialfile);-\t\tif (!ASN1_INTEGER_set(serial, 1)) goto err;-\t\t}-\telse-\t\t{-\t\tchar buf[1024];-\t\tif (!a2i_ASN1_INTEGER(in, serial, buf, sizeof(buf)))-\t\t\t{-\t\t\tBIO_printf(bio_err, \"unable to load number from %s\\n\",-\t\t\t\t   serialfile);-\t\t\tgoto err;-\t\t\t}-\t\tif (!(bn = ASN1_INTEGER_to_BN(serial, NULL))) goto err;-\t\tASN1_INTEGER_free(serial);-\t\tserial = NULL;-\t\tif (!BN_add_word(bn, 1)) goto err;-\t\tif (!(serial = BN_to_ASN1_INTEGER(bn, NULL))) goto err;-\t\t}-\tret = 1;+{+    int ret = 0;+    BIO *in = NULL;+    ASN1_INTEGER *serial = NULL;+    BIGNUM *bn = NULL;++    if (!(serial = ASN1_INTEGER_new()))+        goto err;++    if (!(in = BIO_new_file(serialfile, \"r\"))) {+        ERR_clear_error();+        BIO_printf(bio_err, \"Warning: could not open file %s for \"+                   \"reading, using serial number: 1\\n\", serialfile);+        if (!ASN1_INTEGER_set(serial, 1))+            goto err;+    } else {+        char buf[1024];+        if (!a2i_ASN1_INTEGER(in, serial, buf, sizeof(buf))) {",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/apps/ts.c b/apps/ts.c--- /dev/null+++ b/apps/ts.c@@ -0,0 +894,33 @@++static ASN1_INTEGER *next_serial(const char *serialfile)+\t{+\tint ret = 0;+\tBIO *in = NULL;+\tASN1_INTEGER *serial = NULL;+\tBIGNUM *bn = NULL;++\tif (!(serial = ASN1_INTEGER_new())) goto err;++\tif (!(in = BIO_new_file(serialfile, \"r\"))) +\t\t{+\t\tERR_clear_error();+\t\tBIO_printf(bio_err, \"Warning: could not open file %s for \"+\t\t\t   \"reading, using serial number: 1\\n\", serialfile);+\t\tif (!ASN1_INTEGER_set(serial, 1)) goto err;+\t\t}+\telse+\t\t{+\t\tchar buf[1024];+\t\tif (!a2i_ASN1_INTEGER(in, serial, buf, sizeof(buf)))+\t\t\t{+\t\t\tBIO_printf(bio_err, \"unable to load number from %s\\n\",+\t\t\t\t   serialfile);+\t\t\tgoto err;+\t\t\t}+\t\tif (!(bn = ASN1_INTEGER_to_BN(serial, NULL))) goto err;+\t\tASN1_INTEGER_free(serial);+\t\tserial = NULL;+\t\tif (!BN_add_word(bn, 1)) goto err;+\t\tif (!(serial = BN_to_ASN1_INTEGER(bn, NULL))) goto err;+\t\t}+\tret = 1;",
            "commit_date": "2006-02-12 23:11:56+00:00",
            "commit_hash": "c7235be6e36c4bef84594aa3b2f0561db84b63d8",
            "message": "RFC 3161 compliant time stamp request creation, response generation\nand response verification.\nSubmitted by: Zoltan Glozik <zglozik@opentsa.org>\nReviewed by: Ulf Moeller"
        }
    ],
    "git log -L1456,1488:apps/lib/apps.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/apps/lib/apps.c b/apps/lib/apps.c--- a/apps/lib/apps.c+++ b/apps/lib/apps.c@@ -1421,24 +1421,33 @@ #define BSIZE 256-BIGNUM *load_serial(const char *serialfile, int create, ASN1_INTEGER **retai)+BIGNUM *load_serial(const char *serialfile, int *exists, int create,+                    ASN1_INTEGER **retai) {+    if (exists != NULL)+        *exists = in != NULL;-        if (ret == NULL || !rand_serial(ret, ai))+        if (ret == NULL) {+        } else if (!rand_serial(ret, ai)) {+            BIO_printf(bio_err, \"Error creating random number to store in %s\\n\",+                       serialfile);+            BN_free(ret);+            ret = NULL;+        }",
            "commit_date": "2022-05-30 16:53:05+02:00",
            "commit_hash": "ec8a3409487c871b440fa52bff7c3ef33378494a",
            "message": "APPS/x509: With -CA but both -CAserial and -CAcreateserial not given, use random serial.\nAlso improve openssl-x509.pod.in and error handling of load_serial() in apps.c.\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Hugo Landau <hlandau@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/18373)\nBIO *in = NULL;\nBIGNUM *ret = NULL;\nchar buf[1024];\nASN1_INTEGER *ai = NULL;\nai = ASN1_INTEGER_new();\nif (ai == NULL)\ngoto err;\nin = BIO_new_file(serialfile, \"r\");\nif (in == NULL) {\nif (!create) {\nperror(serialfile);\ngoto err;\n}\nERR_clear_error();\nret = BN_new();\nBIO_printf(bio_err, \"Out of memory\\n\");\n} else {\nif (!a2i_ASN1_INTEGER(in, ai, buf, 1024)) {"
        },
        {
            "author": {
                "email": "fdasilvayy@gmail.com",
                "name": "FdaSilvaYY"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -1320,24 +1320,24 @@ #define BSIZE 256-BIGNUM *load_serial(char *serialfile, int create, ASN1_INTEGER **retai)+BIGNUM *load_serial(const char *serialfile, int create, ASN1_INTEGER **retai) {",
            "commit_date": "2016-08-04 23:52:22+02:00",
            "commit_hash": "cc69629626ce0dab934704e1d9e806e0823c87d0",
            "message": "Constify char* input parameters in apps code\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nBIO *in = NULL;\nBIGNUM *ret = NULL;\nchar buf[1024];\nASN1_INTEGER *ai = NULL;\nai = ASN1_INTEGER_new();\nif (ai == NULL)\ngoto err;\nin = BIO_new_file(serialfile, \"r\");\nif (in == NULL) {\nif (!create) {\nperror(serialfile);\ngoto err;\n}\nERR_clear_error();\nret = BN_new();\nif (ret == NULL || !rand_serial(ret, ai))\nBIO_printf(bio_err, \"Out of memory\\n\");\n} else {\nif (!a2i_ASN1_INTEGER(in, ai, buf, 1024)) {"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -1638,28 +1376,24 @@ #define BSIZE 256 BIGNUM *load_serial(char *serialfile, int create, ASN1_INTEGER **retai) {-    if ((in = BIO_new(BIO_s_file())) == NULL) {-        ERR_print_errors(bio_err);-        goto err;-    }--    if (BIO_read_filename(in, serialfile) <= 0) {+    in = BIO_new_file(serialfile, \"r\");+    if (in == NULL) {-        } else {-            ret = BN_new();-            if (ret == NULL || !rand_serial(ret, ai))-                BIO_printf(bio_err, \"Out of memory\\n\");+        ERR_clear_error();+        ret = BN_new();+        if (ret == NULL || !rand_serial(ret, ai))+            BIO_printf(bio_err, \"Out of memory\\n\");",
            "commit_date": "2015-04-24 15:26:15-04:00",
            "commit_hash": "7e1b7485706c2b11091b5fa897fe496a2faa56cc",
            "message": "Big apps cleanup (option-parsing, etc)\nThis is merges the old \"rsalz-monolith\" branch over to master.  The biggest\nchange is that option parsing switch from cascasding 'else if strcmp(\"-foo\")'\nto a utility routine and somethin akin to getopt.  Also, an error in the\ncommand line no longer prints the full summary; use -help (or --help :)\nfor that.  There have been many other changes and code-cleanup, see\nbullet list below.\nSpecial thanks to Matt for the long and detailed code review.\nTEMPORARY:\nFor now, comment out CRYPTO_mem_leaks() at end of main\nTickets closed:\nRT3515: Use 3DES in pkcs12 if built with no-rc2\nRT1766: s_client -reconnect and -starttls broke\nRT2932: Catch write errors\nRT2604: port should be 'unsigned short'\nRT2983: total_bytes undeclared #ifdef RENEG\nRT1523: Add -nocert to fix output in x509 app\nRT3508: Remove unused variable introduced by b09eb24\nRT3511: doc fix; req default serial is random\nRT1325,2973: Add more extensions to c_rehash\nRT2119,3407: Updated to dgst.pod\nRT2379: Additional typo fix\nRT2693: Extra include of string.h\nRT2880: HFS is case-insensitive filenames\nRT3246: req command prints version number wrong\nOther changes; incompatibilities marked with *:\nAdd SCSV support\nAdd -misalign to speed command\nMake dhparam, dsaparam, ecparam, x509 output C in proper style\nMake some internal ocsp.c functions void\nOnly display cert usages with -help in verify\nUse global bio_err, remove \"BIO*err\" parameter from functions\nFor filenames, - always means stdin (or stdout as appropriate)\nAdd aliases for -des/aes \"wrap\" ciphers.\n*Remove support for IISSGC (server gated crypto)\n*The undocumented OCSP -header flag is now \"-header name=value\"\n*Documented the OCSP -header flag\nReviewed-by: Matt Caswell <matt@openssl.org>\nBIO *in = NULL;\nBIGNUM *ret = NULL;\nchar buf[1024];\nASN1_INTEGER *ai = NULL;\nai = ASN1_INTEGER_new();\nif (ai == NULL)\ngoto err;\nif (!create) {\nperror(serialfile);\ngoto err;\n}\n} else {\nif (!a2i_ASN1_INTEGER(in, ai, buf, 1024)) {"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -1629,28 +1629,28 @@ #define BSIZE 256 BIGNUM *load_serial(char *serialfile, int create, ASN1_INTEGER **retai) {-    MS_STATIC char buf[1024];+    char buf[1024];",
            "commit_date": "2015-01-23 11:58:26-05:00",
            "commit_hash": "68b00c237298b2e7e382686ffd583847d57bbc0b",
            "message": "ifdef cleanup part 3: OPENSSL_SYSNAME\nRename OPENSSL_SYSNAME_xxx to OPENSSL_SYS_xxx\nRemove MS_STATIC; it's a relic from platforms <32 bits.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Tim Hudson <tjh@openssl.org>\nBIO *in = NULL;\nBIGNUM *ret = NULL;\nASN1_INTEGER *ai = NULL;\nai = ASN1_INTEGER_new();\nif (ai == NULL)\ngoto err;\nif ((in = BIO_new(BIO_s_file())) == NULL) {\nERR_print_errors(bio_err);\ngoto err;\n}\nif (BIO_read_filename(in, serialfile) <= 0) {\nif (!create) {\nperror(serialfile);\ngoto err;\n} else {\nret = BN_new();\nif (ret == NULL || !rand_serial(ret, ai))\nBIO_printf(bio_err, \"Out of memory\\n\");\n}\n} else {\nif (!a2i_ASN1_INTEGER(in, ai, buf, 1024)) {"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -1714,53 +1641,28 @@ #define BSIZE 256- BIGNUM *load_serial(char *serialfile, int create, ASN1_INTEGER **retai)-\t{-\tBIO *in=NULL;-\tBIGNUM *ret=NULL;-\tMS_STATIC char buf[1024];-\tASN1_INTEGER *ai=NULL;--\tai=ASN1_INTEGER_new();-\tif (ai == NULL) goto err;--\tif ((in=BIO_new(BIO_s_file())) == NULL)-\t\t{-\t\tERR_print_errors(bio_err);-\t\tgoto err;-\t\t}--\tif (BIO_read_filename(in,serialfile) <= 0)-\t\t{-\t\tif (!create)-\t\t\t{-\t\t\tperror(serialfile);-\t\t\tgoto err;-\t\t\t}-\t\telse-\t\t\t{-\t\t\tret=BN_new();-\t\t\tif (ret == NULL || !rand_serial(ret, ai))-\t\t\t\tBIO_printf(bio_err, \"Out of memory\\n\");-\t\t\t}-\t\t}-\telse-\t\t{-\t\tif (!a2i_ASN1_INTEGER(in,ai,buf,1024))-\t\t\t{-\t\t\tBIO_printf(bio_err,\"unable to load number from %s\\n\",-\t\t\t\tserialfile);-\t\t\tgoto err;-\t\t\t}-\t\tret=ASN1_INTEGER_to_BN(ai,NULL);-\t\tif (ret == NULL)-\t\t\t{-\t\t\tBIO_printf(bio_err,\"error converting number from bin to BIGNUM\\n\");-\t\t\tgoto err;-\t\t\t}-\t\t}--\tif (ret && retai)-\t\t{-\t\t*retai = ai;-\t\tai = NULL;-\t\t}+{+    BIO *in = NULL;+    BIGNUM *ret = NULL;+    MS_STATIC char buf[1024];+    ASN1_INTEGER *ai = NULL;++    ai = ASN1_INTEGER_new();+    if (ai == NULL)+        goto err;++    if ((in = BIO_new(BIO_s_file())) == NULL) {+        ERR_print_errors(bio_err);+        goto err;+    }++    if (BIO_read_filename(in, serialfile) <= 0) {+        if (!create) {+            perror(serialfile);+            goto err;+        } else {+            ret = BN_new();+            if (ret == NULL || !rand_serial(ret, ai))+                BIO_printf(bio_err, \"Out of memory\\n\");+        }+    } else {+        if (!a2i_ASN1_INTEGER(in, ai, buf, 1024)) {",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -1410,56 +1410,53 @@ #define BSIZE 256 BIGNUM *load_serial(char *serialfile, int create, ASN1_INTEGER **retai) \t{ \tBIO *in=NULL; \tBIGNUM *ret=NULL; \tMS_STATIC char buf[1024]; \tASN1_INTEGER *ai=NULL; \tai=ASN1_INTEGER_new(); \tif (ai == NULL) goto err; \tif ((in=BIO_new(BIO_s_file())) == NULL) \t\t{ \t\tERR_print_errors(bio_err); \t\tgoto err; \t\t} \tif (BIO_read_filename(in,serialfile) <= 0) \t\t{ \t\tif (!create) \t\t\t{ \t\t\tperror(serialfile); \t\t\tgoto err; \t\t\t} \t\telse \t\t\t{-\t\t\tASN1_INTEGER_set(ai,1); \t\t\tret=BN_new();-\t\t\tif (ret == NULL)+\t\t\tif (ret == NULL || !rand_serial(ret, ai)) \t\t\t\tBIO_printf(bio_err, \"Out of memory\\n\");-\t\t\telse-\t\t\t\tBN_one(ret); \t\t\t} \t\t} \telse \t\t{ \t\tif (!a2i_ASN1_INTEGER(in,ai,buf,1024)) \t\t\t{ \t\t\tBIO_printf(bio_err,\"unable to load number from %s\\n\", \t\t\t\tserialfile); \t\t\tgoto err; \t\t\t} \t\tret=ASN1_INTEGER_to_BN(ai,NULL); \t\tif (ret == NULL) \t\t\t{ \t\t\tBIO_printf(bio_err,\"error converting number from bin to BIGNUM\\n\"); \t\t\tgoto err; \t\t\t} \t\t} \tif (ret && retai) \t\t{ \t\t*retai = ai; \t\tai = NULL; \t\t}",
            "commit_date": "2004-04-20 12:05:26+00:00",
            "commit_hash": "64674bcc8cee73853d00388a5e83cb1b2f38bec1",
            "message": "Reduce chances of issuer and serial number duplication by use of random\ninitial serial numbers.\nPR: 842"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -1425,0 +1460,56 @@+#define BSIZE 256++BIGNUM *load_serial(char *serialfile, int create, ASN1_INTEGER **retai)+\t{+\tBIO *in=NULL;+\tBIGNUM *ret=NULL;+\tMS_STATIC char buf[1024];+\tASN1_INTEGER *ai=NULL;++\tai=ASN1_INTEGER_new();+\tif (ai == NULL) goto err;++\tif ((in=BIO_new(BIO_s_file())) == NULL)+\t\t{+\t\tERR_print_errors(bio_err);+\t\tgoto err;+\t\t}++\tif (BIO_read_filename(in,serialfile) <= 0)+\t\t{+\t\tif (!create)+\t\t\t{+\t\t\tperror(serialfile);+\t\t\tgoto err;+\t\t\t}+\t\telse+\t\t\t{+\t\t\tASN1_INTEGER_set(ai,1);+\t\t\tret=BN_new();+\t\t\tif (ret == NULL)+\t\t\t\tBIO_printf(bio_err, \"Out of memory\\n\");+\t\t\telse+\t\t\t\tBN_one(ret);+\t\t\t}+\t\t}+\telse+\t\t{+\t\tif (!a2i_ASN1_INTEGER(in,ai,buf,1024))+\t\t\t{+\t\t\tBIO_printf(bio_err,\"unable to load number from %s\\n\",+\t\t\t\tserialfile);+\t\t\tgoto err;+\t\t\t}+\t\tret=ASN1_INTEGER_to_BN(ai,NULL);+\t\tif (ret == NULL)+\t\t\t{+\t\t\tBIO_printf(bio_err,\"error converting number from bin to BIGNUM\\n\");+\t\t\tgoto err;+\t\t\t}+\t\t}++\tif (ret && retai)+\t\t{+\t\t*retai = ai;+\t\tai = NULL;+\t\t}",
            "commit_date": "2003-04-03 16:33:03+00:00",
            "commit_hash": "f85b68cd4982c28c02070c2e036da1c84cf0e7af",
            "message": "Make it possible to have multiple active certificates with the same\nsubject."
        }
    ],
    "git log -L2081,2117:apps/lib/apps.c": [
        {
            "author": {
                "email": "David.von.Oheimb@siemens.com",
                "name": "Dr. David von Oheimb"
            },
            "changes": "diff --git a/apps/lib/apps.c b/apps/lib/apps.c--- a/apps/lib/apps.c+++ b/apps/lib/apps.c@@ -2051,37 +2026,37 @@  */ unsigned char *next_protos_parse(size_t *outlen, const char *in) {-            out[start-skipped] = (unsigned char)(i - start);+            out[start - skipped] = (unsigned char)(i - start);",
            "commit_date": "2022-01-06 23:26:04+01:00",
            "commit_hash": "8cdb993d8b1ad9fd58fb5f41cc43df97014f00c9",
            "message": "apps.c: fix various coding style nits found by check-format.pl\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/17435)\nsize_t len;\nunsigned char *out;\nsize_t i, start = 0;\nsize_t skipped = 0;\nlen = strlen(in);\nif (len == 0 || len >= 65535)\nreturn NULL;\nout = app_malloc(len + 1, \"NPN buffer\");\nfor (i = 0; i <= len; ++i) {\nif (i == len || in[i] == ',') {\n/*\n* Zero-length ALPN elements are invalid on the wire, we could be\n* strict and reject the entire string, but just ignoring extra\n* commas seems harmless and more friendly.\n*\n* Every comma we skip in this way puts the input buffer another\n* byte ahead of the output buffer, so all stores into the output\n* buffer need to be decremented by the number commas skipped.\n*/\nif (i == start) {\n++start;\n++skipped;\ncontinue;\n}\nif (i - start > 255) {\nOPENSSL_free(out);\nreturn NULL;\n}\nstart = i + 1;\n} else {\nout[i + 1 - skipped] = in[i];"
        },
        {
            "author": {
                "email": "openssl-users@dukhovni.org",
                "name": "Viktor Dukhovni"
            },
            "changes": "diff --git a/apps/lib/apps.c b/apps/lib/apps.c--- a/apps/lib/apps.c+++ b/apps/lib/apps.c@@ -1806,22 +1806,37 @@  */ unsigned char *next_protos_parse(size_t *outlen, const char *in) {+    size_t skipped = 0;-    if (len >= 65535)+    if (len == 0 || len >= 65535)-    out = app_malloc(strlen(in) + 1, \"NPN buffer\");+    out = app_malloc(len + 1, \"NPN buffer\");+            /*+             * Zero-length ALPN elements are invalid on the wire, we could be+             * strict and reject the entire string, but just ignoring extra+             * commas seems harmless and more friendly.+             *+             * Every comma we skip in this way puts the input buffer another+             * byte ahead of the output buffer, so all stores into the output+             * buffer need to be decremented by the number commas skipped.+             */+            if (i == start) {+                ++start;+                ++skipped;+                continue;+            }-            out[start] = (unsigned char)(i - start);+            out[start-skipped] = (unsigned char)(i - start);-            out[i + 1] = in[i];+            out[i + 1 - skipped] = in[i];",
            "commit_date": "2019-10-11 17:52:19-04:00",
            "commit_hash": "e78253f2d0c1a9fe6b023d867ee02342b4560150",
            "message": "Ignore empty ALPN elements in CLI args\nReviewed-by: Matt Caswell <matt@openssl.org>\nsize_t len;\nunsigned char *out;\nsize_t i, start = 0;\nlen = strlen(in);\nreturn NULL;\nfor (i = 0; i <= len; ++i) {\nif (i == len || in[i] == ',') {\nif (i - start > 255) {\nOPENSSL_free(out);\nreturn NULL;\n}\nstart = i + 1;\n} else {"
        },
        {
            "author": {
                "email": "appro@openssl.org",
                "name": "Andy Polyakov"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -1911,22 +1911,22 @@  */ unsigned char *next_protos_parse(size_t *outlen, const char *in) {-            out[start] = i - start;+            out[start] = (unsigned char)(i - start);",
            "commit_date": "2017-11-11 22:23:12+01:00",
            "commit_hash": "3a63c0edab842af3e84ef1cad2b4eb701eece3e1",
            "message": "Resolve warnings in VC-WIN32 build, which allows to add /WX.\nIt's argued that /WX allows to keep better focus on new code, which\nmotivates its comeback...\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4721)\nsize_t len;\nunsigned char *out;\nsize_t i, start = 0;\nlen = strlen(in);\nif (len >= 65535)\nreturn NULL;\nout = app_malloc(strlen(in) + 1, \"NPN buffer\");\nfor (i = 0; i <= len; ++i) {\nif (i == len || in[i] == ',') {\nif (i - start > 255) {\nOPENSSL_free(out);\nreturn NULL;\n}\nstart = i + 1;\n} else {\nout[i + 1] = in[i];"
        },
        {
            "author": {
                "email": "paulyang.inf@gmail.com",
                "name": "Paul Yang"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -1902,22 +1907,22 @@  */ unsigned char *next_protos_parse(size_t *outlen, const char *in) {-        } else+        } else {",
            "commit_date": "2017-06-13 01:24:02+08:00",
            "commit_hash": "2234212c3dde887e0b7fa08277d035cd132e2cce",
            "message": "Clean up a bundle of codingstyle stuff in apps directory\nMostly braces and NULL pointer check and also copyright year bump\nSigned-off-by: Paul Yang <paulyang.inf@gmail.com>\nReviewed-by: Kurt Roeckx <kurt@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3657)\nsize_t len;\nunsigned char *out;\nsize_t i, start = 0;\nlen = strlen(in);\nif (len >= 65535)\nreturn NULL;\nout = app_malloc(strlen(in) + 1, \"NPN buffer\");\nfor (i = 0; i <= len; ++i) {\nif (i == len || in[i] == ',') {\nif (i - start > 255) {\nOPENSSL_free(out);\nreturn NULL;\n}\nout[start] = i - start;\nstart = i + 1;\nout[i + 1] = in[i];"
        },
        {
            "author": {
                "email": "tshort@akamai.com",
                "name": "Todd Short"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -1962,22 +1962,22 @@  */-unsigned char *next_protos_parse(unsigned short *outlen, const char *in)+unsigned char *next_protos_parse(size_t *outlen, const char *in) {",
            "commit_date": "2016-03-05 08:47:55-05:00",
            "commit_hash": "817cd0d52f0462039d1fe60462150be7f59d2002",
            "message": "GH787: Fix ALPN\n* Perform ALPN after the SNI callback; the SSL_CTX may change due to\nthat processing\n* Add flags to indicate that we actually sent ALPN, to properly error\nout if unexpectedly received.\n* clean up ssl3_free() no need to explicitly clear when doing memset\n* document ALPN functions\nSigned-off-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Emilia K\u00e4sper <emilia@openssl.org>\nsize_t len;\nunsigned char *out;\nsize_t i, start = 0;\nlen = strlen(in);\nif (len >= 65535)\nreturn NULL;\nout = app_malloc(strlen(in) + 1, \"NPN buffer\");\nfor (i = 0; i <= len; ++i) {\nif (i == len || in[i] == ',') {\nif (i - start > 255) {\nOPENSSL_free(out);\nreturn NULL;\n}\nout[start] = i - start;\nstart = i + 1;\n} else\nout[i + 1] = in[i];"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -2222,25 +2227,22 @@  */ unsigned char *next_protos_parse(unsigned short *outlen, const char *in) {-    out = OPENSSL_malloc(strlen(in) + 1);-    if (!out)-        return NULL;-+    out = app_malloc(strlen(in) + 1, \"NPN buffer\");",
            "commit_date": "2015-04-30 17:48:31-04:00",
            "commit_hash": "68dc682499ea3fe27d909c946d7abd39062d6efd",
            "message": "In apps, malloc or die\nNo point in proceeding if you're out of memory.  So change\n*all* OPENSSL_malloc calls in apps to use the new routine which\nprints a message and exits.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nsize_t len;\nunsigned char *out;\nsize_t i, start = 0;\nlen = strlen(in);\nif (len >= 65535)\nreturn NULL;\nfor (i = 0; i <= len; ++i) {\nif (i == len || in[i] == ',') {\nif (i - start > 255) {\nOPENSSL_free(out);\nreturn NULL;\n}\nout[start] = i - start;\nstart = i + 1;\n} else\nout[i + 1] = in[i];"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -2930,35 +2755,25 @@  */ unsigned char *next_protos_parse(unsigned short *outlen, const char *in)-\t{-\tsize_t len;-\tunsigned char *out;-\tsize_t i, start = 0;--\tlen = strlen(in);-\tif (len >= 65535)-\t\treturn NULL;--\tout = OPENSSL_malloc(strlen(in) + 1);-\tif (!out)-\t\treturn NULL;--\tfor (i = 0; i <= len; ++i)-\t\t{-\t\tif (i == len || in[i] == ',')-\t\t\t{-\t\t\tif (i - start > 255)-\t\t\t\t{-\t\t\t\tOPENSSL_free(out);-\t\t\t\treturn NULL;-\t\t\t\t}-\t\t\tout[start] = i - start;-\t\t\tstart = i + 1;-\t\t\t}-\t\telse-\t\t\tout[i+1] = in[i];-\t\t}--\t*outlen = len + 1;-\treturn out;-\t}-#endif  /* ndef OPENSSL_NO_TLSEXT */+{+    size_t len;+    unsigned char *out;+    size_t i, start = 0;++    len = strlen(in);+    if (len >= 65535)+        return NULL;++    out = OPENSSL_malloc(strlen(in) + 1);+    if (!out)+        return NULL;++    for (i = 0; i <= len; ++i) {+        if (i == len || in[i] == ',') {+            if (i - start > 255) {+                OPENSSL_free(out);+                return NULL;+            }+            out[start] = i - start;+            start = i + 1;+        } else+            out[i + 1] = in[i];",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "piotr@cloudflare.com",
                "name": "Piotr Sikora"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -2920,35 +2920,35 @@  */ unsigned char *next_protos_parse(unsigned short *outlen, const char *in) \t{ \tsize_t len; \tunsigned char *out; \tsize_t i, start = 0; \tlen = strlen(in); \tif (len >= 65535) \t\treturn NULL; \tout = OPENSSL_malloc(strlen(in) + 1); \tif (!out) \t\treturn NULL; \tfor (i = 0; i <= len; ++i) \t\t{ \t\tif (i == len || in[i] == ',') \t\t\t{ \t\t\tif (i - start > 255) \t\t\t\t{ \t\t\t\tOPENSSL_free(out); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tout[start] = i - start; \t\t\tstart = i + 1; \t\t\t} \t\telse \t\t\tout[i+1] = in[i]; \t\t} \t*outlen = len + 1; \treturn out; \t}-#endif  /* !OPENSSL_NO_TLSEXT && !OPENSSL_NO_NEXTPROTONEG */+#endif  /* ndef OPENSSL_NO_TLSEXT */",
            "commit_date": "2013-11-13 15:20:22-08:00",
            "commit_hash": "2911575c6e790541e495927a60121d7546a66962",
            "message": "Fix compilation with no-nextprotoneg.\nPR#3106"
        },
        {
            "author": {
                "email": "ben@openssl.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/apps/apps.c b/apps/apps.c--- a/apps/apps.c+++ b/apps/apps.c@@ -2743,0 +2752,35 @@+ */+unsigned char *next_protos_parse(unsigned short *outlen, const char *in)+\t{+\tsize_t len;+\tunsigned char *out;+\tsize_t i, start = 0;++\tlen = strlen(in);+\tif (len >= 65535)+\t\treturn NULL;++\tout = OPENSSL_malloc(strlen(in) + 1);+\tif (!out)+\t\treturn NULL;++\tfor (i = 0; i <= len; ++i)+\t\t{+\t\tif (i == len || in[i] == ',')+\t\t\t{+\t\t\tif (i - start > 255)+\t\t\t\t{+\t\t\t\tOPENSSL_free(out);+\t\t\t\treturn NULL;+\t\t\t\t}+\t\t\tout[start] = i - start;+\t\t\tstart = i + 1;+\t\t\t}+\t\telse+\t\t\tout[i+1] = in[i];+\t\t}++\t*outlen = len + 1;+\treturn out;+\t}+#endif  /* !OPENSSL_NO_TLSEXT && !OPENSSL_NO_NEXTPROTONEG */",
            "commit_date": "2012-06-03 22:00:21+00:00",
            "commit_hash": "71fa451343f97b3624374ed1359adc23fba5696e",
            "message": "Version skew reduction: trivia (I hope)."
        }
    ],
    "git log -L297,325:test/ec_internal_test.c": [
        {
            "author": {
                "email": "tmraz@fedoraproject.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/test/ec_internal_test.c b/test/ec_internal_test.c--- a/test/ec_internal_test.c+++ b/test/ec_internal_test.c@@ -262,0 +264,29 @@+ */+static int decoded_flag_test(void)+{+    EC_GROUP *grp;+    EC_GROUP *grp_copy = NULL;+    ECPARAMETERS *ecparams = NULL;+    ECPKPARAMETERS *ecpkparams = NULL;+    EC_KEY *key = NULL;+    unsigned char *encodedparams = NULL;+    const unsigned char *encp;+    int encodedlen;+    int testresult = 0;++    /* Test EC_GROUP_new not setting the flag */+    grp = EC_GROUP_new(EC_GFp_simple_method());+    if (!TEST_ptr(grp)+        || !TEST_int_eq(grp->decoded_from_explicit_params, 0))+        goto err;+    EC_GROUP_free(grp);++    /* Test EC_GROUP_new_by_curve_name not setting the flag */+    grp = EC_GROUP_new_by_curve_name(NID_X9_62_prime256v1);+    if (!TEST_ptr(grp)+        || !TEST_int_eq(grp->decoded_from_explicit_params, 0))+        goto err;++    /* Test EC_GROUP_new_from_ecparameters not setting the flag */+    if (!TEST_ptr(ecparams = EC_GROUP_get_ecparameters(grp, NULL))+        || !TEST_ptr(grp_copy = EC_GROUP_new_from_ecparameters(ecparams))",
            "commit_date": "2020-08-21 14:50:52+02:00",
            "commit_hash": "fe2f8aecfe4a0de483334bf671a8eb4f14444c00",
            "message": "EC_KEY: add EC_KEY_decoded_from_explicit_params()\nThe function returns 1 when the encoding of a decoded EC key used\nexplicit encoding of the curve parameters.\nReviewed-by: David von Oheimb <david.von.oheimb@siemens.com>\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\n(Merged from https://github.com/openssl/openssl/pull/12683)"
        }
    ],
    "git log -L126,442:ssl/record/methods/ssl3_cbc.c": [
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/record/methods/ssl3_cbc.c b/ssl/record/methods/ssl3_cbc.c--- a/ssl/record/methods/ssl3_cbc.c+++ b/ssl/record/methods/ssl3_cbc.c@@ -127,312 +126,317 @@  */ int ssl3_cbc_digest_record(const EVP_MD *md, { #ifdef FIPS_MODULE #else #endif-     } else if (EVP_MD_is_a(md, \"SHA2-256\")) {+    } else if (EVP_MD_is_a(md, \"SHA2-256\")) {-     } else if (EVP_MD_is_a(md, \"SHA2-384\")) {+    } else if (EVP_MD_is_a(md, \"SHA2-384\")) {-        header_length = mac_secret_length + sslv3_pad_length + 8 /* sequence-                                                                  * number */  +-            1 /* record type */  +-            2 /* record length */ ;+        header_length = mac_secret_length+                        + sslv3_pad_length+                        + 8  /* sequence number */+                        + 1  /* record type */+                        + 2; /* record length */-    variance_blocks = is_sslv3 ? 2 : ( ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1);+    variance_blocks = is_sslv3 ? 2+                               : (((255 + 1 + md_size + md_block_size - 1)+                                   / md_block_size) + 1);++",
            "commit_date": "2022-07-27 14:20:23+01:00",
            "commit_hash": "1704961cf085a64b0e104bd0c9cb81188f061698",
            "message": "Formatting cleanups\nSome minor formatting cleanups and other minor tweaks.\nReviewed-by: Hugo Landau <hlandau@openssl.org>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/18132)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char *header,\nconst unsigned char *data,\nsize_t data_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\nOSSL_UNION_ALIGN;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret = 0;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nif (EVP_MD_is_a(md, \"MD5\")) {\nreturn 0;\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\n} else if (EVP_MD_is_a(md, \"SHA1\")) {\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\n} else if (EVP_MD_is_a(md, \"SHA2-224\")) {\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\n} else if (EVP_MD_is_a(md, \"SHA2-512\")) {\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\n} else {\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final |variance_blocks|\n* blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_size + header_length;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this block contains the end of the application data\n* and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "jchrist@linux.ibm.com",
                "name": "Juergen Christ"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -155,312 +155,312 @@  */ int ssl3_cbc_digest_record(const EVP_MD *md,-                           const unsigned char header[13],+                           const unsigned char *header, { #ifdef FIPS_MODULE #else #endif",
            "commit_date": "2021-05-25 18:03:06+02:00",
            "commit_hash": "4612eec35def0523192ee2c406f99ea5bbb184fb",
            "message": "Fix compilation warning with GCC11.\nParameter \"header\" of ssl3_cbc_digest_record was fixed to a 13 bytes header\nbut used as a pointer.  This caused a warning about out-of-bounds array access\nwith GCC 11.\nFixes #15462.\nSigned-off-by: Juergen Christ <jchrist@linux.ibm.com>\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15463)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char *data,\nsize_t data_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\nOSSL_UNION_ALIGN;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret = 0;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nif (EVP_MD_is_a(md, \"MD5\")) {\nreturn 0;\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\n} else if (EVP_MD_is_a(md, \"SHA1\")) {\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\n} else if (EVP_MD_is_a(md, \"SHA2-224\")) {\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\n} else if (EVP_MD_is_a(md, \"SHA2-256\")) {\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\n} else if (EVP_MD_is_a(md, \"SHA2-384\")) {\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\n} else if (EVP_MD_is_a(md, \"SHA2-512\")) {\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\n} else {\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final |variance_blocks|\n* blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : ( ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1);\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_size + header_length;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this block contains the end of the application data\n* and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -153,308 +155,312 @@  */ int ssl3_cbc_digest_record(const EVP_MD *md, {+#ifdef FIPS_MODULE+        return 0;+#else+#endif",
            "commit_date": "2021-05-06 14:03:20+10:00",
            "commit_hash": "839261592ca447aa083403cee7b0ced97cef6159",
            "message": "Remove unused code from the fips module\nReviewed-by: Tomas Mraz <tomas@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/15167)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\nOSSL_UNION_ALIGN;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret = 0;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nif (EVP_MD_is_a(md, \"MD5\")) {\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\n} else if (EVP_MD_is_a(md, \"SHA1\")) {\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\n} else if (EVP_MD_is_a(md, \"SHA2-224\")) {\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\n} else if (EVP_MD_is_a(md, \"SHA2-256\")) {\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\n} else if (EVP_MD_is_a(md, \"SHA2-384\")) {\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\n} else if (EVP_MD_is_a(md, \"SHA2-512\")) {\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\n} else {\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final |variance_blocks|\n* blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : ( ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1);\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_size + header_length;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this block contains the end of the application data\n* and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -172,315 +172,308 @@  */ int ssl3_cbc_digest_record(const EVP_MD *md, {-    switch (EVP_MD_type(md)) {-    case NID_md5:+    if (EVP_MD_is_a(md, \"MD5\")) {-        break;-    case NID_sha1:+    } else if (EVP_MD_is_a(md, \"SHA1\")) {-        break;-    case NID_sha224:+    } else if (EVP_MD_is_a(md, \"SHA2-224\")) {-        break;-    case NID_sha256:+     } else if (EVP_MD_is_a(md, \"SHA2-256\")) {-        break;-    case NID_sha384:+     } else if (EVP_MD_is_a(md, \"SHA2-384\")) {-        break;-    case NID_sha512:+    } else if (EVP_MD_is_a(md, \"SHA2-512\")) {-        break;-    default:+    } else {",
            "commit_date": "2020-08-31 14:43:15+01:00",
            "commit_hash": "13c9843cff061304275a1723bcba137280e2e97d",
            "message": "Convert ssl3_cbc_digest_record() to use EVP_MD_is_a()\nPreviously it used EVP_MD_type(), which doesn't work when called inside\nthe FIPs module.\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/12732)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\nOSSL_UNION_ALIGN;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret = 0;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final |variance_blocks|\n* blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : ( ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1);\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_size + header_length;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this block contains the end of the application data\n* and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -175,315 +172,315 @@  */ int ssl3_cbc_digest_record(const EVP_MD *md,-                           size_t data_plus_mac_size,+                           size_t data_size, {-    mac_end_offset = data_plus_mac_size + header_length - md_size;+    mac_end_offset = data_size + header_length;",
            "commit_date": "2020-08-20 15:48:05+01:00",
            "commit_hash": "e08f86ddb1b4b911da55af6d7f71f00f43529e50",
            "message": "Make ssl3_cbc_digest_record() use the real data_size\nPreviously we passed it the data plus mac size. Now we just pass it the\ndata size. We already know the mac size.\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/12732)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\nOSSL_UNION_ALIGN;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret = 0;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nswitch (EVP_MD_type(md)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final |variance_blocks|\n* blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : ( ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1);\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this block contains the end of the application data\n* and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -133,317 +175,315 @@  */-int ssl3_cbc_digest_record(SSL *s,-                           const EVP_MD_CTX *ctx,+int ssl3_cbc_digest_record(const EVP_MD *md, {-    const EVP_MD *md = NULL;-    switch (EVP_MD_CTX_type(ctx)) {+    switch (EVP_MD_type(md)) {",
            "commit_date": "2020-07-30 12:02:06+01:00",
            "commit_hash": "3fddbb264e87a8cef2903cbd7b02b8e1a39a2a99",
            "message": "Add an HMAC implementation that is TLS aware\nThe TLS HMAC implementation should take care to calculate the MAC in\nconstant time in the case of MAC-Then-Encrypt where we have a variable\namount of padding.\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/12732)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\nOSSL_UNION_ALIGN;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret = 0;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final |variance_blocks|\n* blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : ( ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1);\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this block contains the end of the application data\n* and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -133,315 +133,317 @@  */-int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,+int ssl3_cbc_digest_record(SSL *s,+                           const EVP_MD_CTX *ctx, {-    int ret;+    int ret = 0;+    const EVP_MD *md = NULL;",
            "commit_date": "2020-04-18 11:54:23+01:00",
            "commit_hash": "73d391ad139b6744fa16fb8be1813b2f7ec8f6c0",
            "message": "Use a fetched MD if appropriate in ssl3_cbc_digest_record\nHMACs used via the legacy EVP_DigestSign interface are strange in\nthat they use legacy codepath's which eventually (under the covers)\ntransform the operation into a new style EVP_MAC. This can mean the\ndigest in use can be a legacy one, so we need to be careful with any\ndigest we extract from the ctx.\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/11511)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\nOSSL_UNION_ALIGN;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final |variance_blocks|\n* blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : ( ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1);\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this block contains the end of the application data\n* and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -127,315 +127,315 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-        double align;+        OSSL_UNION_ALIGN;",
            "commit_date": "2019-04-30 20:36:16+10:00",
            "commit_hash": "39147079fc41b1af9a4e2974e89de20668e02aea",
            "message": "Structure alignment macro.\nIntroduce a macro that allows all structure alignment tricks to be rolled up\ninto a single place.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/8845)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final |variance_blocks|\n* blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : ( ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1);\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this block contains the end of the application data\n* and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "armfazh@gmail.com",
                "name": "armfazh"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -127,314 +127,315 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-     * required to be minimal. Therefore we say that the final six blocks can+     * required to be minimal. Therefore we say that the final |variance_blocks|+     * blocks can-    variance_blocks = is_sslv3 ? 2 : 6;+    variance_blocks = is_sslv3 ? 2 : ( ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1);",
            "commit_date": "2018-10-19 08:26:58+10:00",
            "commit_hash": "cb8164b05e3bad5586c2a109bbdbab1ad65a1a6f",
            "message": "Fix tls_cbc_digest_record is slow using SHA-384 and short messages\nThe formula used for this is now\nkVarianceBlocks = ((255 + 1 + md_size + md_block_size - 1) / md_block_size) + 1\nNotice that md_block_size=64 for SHA256, which results on the\nmagic constant kVarianceBlocks = 6.\nHowever, md_block_size=128 for SHA384 leading to kVarianceBlocks = 4.\nCLA:trivial\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/7342)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this block contains the end of the application data\n* and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "xiaoyinl@users.noreply.github.com",
                "name": "Xiaoyin Liu"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -126,314 +126,314 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-             * If this the the block containing the end of the application-             * data and we're past the 0x80 value then just write zero.+             * If this block contains the end of the application data+             * and we're past the 0x80 value then just write zero.",
            "commit_date": "2017-07-30 18:43:19-04:00",
            "commit_hash": "3519bae518f0ed576daf05057e4fc79e49cb2bee",
            "message": "Fix typos in files in ssl directory\nReviewed-by: Tim Hudson <tjh@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4052)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size != NULL)\n*md_out_size = 0;\nreturn ossl_assert(0);\n}\nif (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)\n|| !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)\n|| !ossl_assert(md_size <= EVP_MAX_MD_SIZE))\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -127,315 +126,314 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-        assert(0);-        if (md_out_size)+        if (md_out_size != NULL)-        return 0;+        return ossl_assert(0);-    if (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES-                    && md_block_size <= MAX_HASH_BLOCK_SIZE-                    && md_size <= EVP_MAX_MD_SIZE))+    if (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES)+            || !ossl_assert(md_block_size <= MAX_HASH_BLOCK_SIZE)+            || !ossl_assert(md_size <= EVP_MAX_MD_SIZE))",
            "commit_date": "2017-05-22 12:33:42+01:00",
            "commit_hash": "b77f3ed17134fe6bf99d143abb1aec3f2bfac555",
            "message": "Convert existing usage of assert() to ossl_assert() in libssl\nProvides consistent output and approach.\nReviewed-by: Tim Hudson <tjh@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3496)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nif (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))\nreturn 0;\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\n*md_out_size = 0;\n}\nreturn 0;\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nif (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))\nreturn 0;\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -126,312 +127,315 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-    OPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);+    if (!ossl_assert(data_plus_mac_plus_padding_size < 1024 * 1024))+        return 0;-        OPENSSL_assert(0);+        assert(0);-    OPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);-    OPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);-    OPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);+    if (!ossl_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES+                    && md_block_size <= MAX_HASH_BLOCK_SIZE+                    && md_size <= EVP_MAX_MD_SIZE))+        return 0;-        OPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));+        if (!ossl_assert(mac_secret_length <= sizeof(hmac_pad)))+            return 0;",
            "commit_date": "2017-05-19 09:35:19+01:00",
            "commit_hash": "380a522f689252e7f19e0c44ea49461ec7bd040f",
            "message": "Replace instances of OPENSSL_assert() with soft asserts in libssl\nReviewed-by: Tim Hudson <tjh@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3496)\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nif (md_out_size)\n*md_out_size = 0;\nreturn 0;\n}\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8_s(i, index_a);\nunsigned char is_block_b = constant_time_eq_8_s(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8_s(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -128,312 +128,312 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-        unsigned char is_block_a = constant_time_eq_8(i, index_a);-        unsigned char is_block_b = constant_time_eq_8(i, index_b);+        unsigned char is_block_a = constant_time_eq_8_s(i, index_a);+        unsigned char is_block_b = constant_time_eq_8_s(i, index_b);-            is_past_c = is_block_a & constant_time_ge_8(j, c);-            is_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);+            is_past_c = is_block_a & constant_time_ge_8_s(j, c);+            is_past_cp1 = is_block_a & constant_time_ge_8_s(j, c + 1);",
            "commit_date": "2016-10-19 17:13:13+01:00",
            "commit_hash": "2688e7a0beb0f5e76a98749f25b978ddfb40ac7f",
            "message": "Provide some constant time functions for dealing with size_t values\nAlso implement the using of them\nReviewed-by: Rich Salz <rsalz@openssl.org>\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nOPENSSL_assert(0);\nif (md_out_size)\n*md_out_size = 0;\nreturn 0;\n}\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nsize_t overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -128,312 +128,312 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-            unsigned overhang;+            size_t overhang;",
            "commit_date": "2016-10-19 15:11:24+01:00",
            "commit_hash": "348240c676a1b2beaebb865e8be0b62f88c10b7d",
            "message": "Fix misc size_t issues causing Windows warnings in 64 bit\nReviewed-by: Rich Salz <rsalz@openssl.org>\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nsize_t mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nsize_t md_size, md_block_size = 64;\nsize_t sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nsize_t bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nsize_t i, j;\nunsigned md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nsize_t md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nOPENSSL_assert(0);\nif (md_out_size)\n*md_out_size = 0;\nreturn 0;\n}\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8(i, index_a);\nunsigned char is_block_b = constant_time_eq_8(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -128,311 +128,312 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,-                           unsigned mac_secret_length, char is_sslv3)+                           size_t mac_secret_length, char is_sslv3) {-    unsigned md_size, md_block_size = 64;-    unsigned sslv3_pad_length = 40, header_length, variance_blocks,+    size_t md_size, md_block_size = 64;+    size_t sslv3_pad_length = 40, header_length, variance_blocks,-    unsigned int bits;          /* at most 18 bits */+    size_t bits;          /* at most 18 bits */-    unsigned i, j, md_out_size_u;+    size_t i, j;+    unsigned md_out_size_u;-    unsigned md_length_size = 8;+    size_t md_length_size = 8;",
            "commit_date": "2016-10-03 22:26:59+01:00",
            "commit_hash": "d0e7c31db04349882855add5a5a21977b4467e3d",
            "message": "Convert ssl3_cbc_digest_record for size_t\nReviewed-by: Rich Salz <rsalz@openssl.org>\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nOPENSSL_assert(0);\nif (md_out_size)\n*md_out_size = 0;\nreturn 0;\n}\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nunsigned overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8(i, index_a);\nunsigned char is_block_b = constant_time_eq_8(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -130,311 +128,311 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,-                            unsigned char *md_out,-                            size_t *md_out_size,-                            const unsigned char header[13],-                            const unsigned char *data,-                            size_t data_plus_mac_size,-                            size_t data_plus_mac_plus_padding_size,-                            const unsigned char *mac_secret,-                            unsigned mac_secret_length, char is_sslv3)+                           unsigned char *md_out,+                           size_t *md_out_size,+                           const unsigned char header[13],+                           const unsigned char *data,+                           size_t data_plus_mac_size,+                           size_t data_plus_mac_plus_padding_size,+                           const unsigned char *mac_secret,+                           unsigned mac_secret_length, char is_sslv3) {",
            "commit_date": "2016-08-05 19:03:17+02:00",
            "commit_hash": "a230b26e0959dc5f072fbbdadcc9ed45e904c50c",
            "message": "Indent ssl/\nRun util/openssl-format-source on ssl/\nSome comments and hand-formatted tables were fixed up\nmanually by disabling auto-formatting.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nunsigned md_size, md_block_size = 64;\nunsigned sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nunsigned int bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nunsigned i, j, md_out_size_u;\nEVP_MD_CTX *md_ctx = NULL;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nunsigned md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nOPENSSL_assert(0);\nif (md_out_size)\n*md_out_size = 0;\nreturn 0;\n}\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nunsigned overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8(i, index_a);\nunsigned char is_block_b = constant_time_eq_8(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -176,311 +176,311 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-    EVP_MD_CTX md_ctx;+    EVP_MD_CTX *md_ctx = NULL;",
            "commit_date": "2015-11-27 14:02:12+01:00",
            "commit_hash": "6e59a892db781658c050e5217127c4147c116ac9",
            "message": "Adjust all accesses to EVP_MD_CTX to use accessor functions.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nunsigned mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nunsigned md_size, md_block_size = 64;\nunsigned sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nunsigned int bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nunsigned i, j, md_out_size_u;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nunsigned md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nOPENSSL_assert(0);\nif (md_out_size)\n*md_out_size = 0;\nreturn 0;\n}\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nunsigned overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8(i, index_a);\nunsigned char is_block_b = constant_time_eq_8(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "openssl-users@dukhovni.org",
                "name": "Viktor Dukhovni"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -176,311 +176,311 @@  */ int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-            *md_out_size = -1;+            *md_out_size = 0;",
            "commit_date": "2015-11-21 00:59:07-05:00",
            "commit_hash": "5c649375dd756dcd0b0c81a14a04cd8e87f198c1",
            "message": "Good hygiene with size_t output argument.\nThough the callers check the function return value and ignore the\nsize_t output argument on failure, it is still often not ideal to\nstore (-1) in size_t on error.  That might signal an unduly large\nbuffer.  Instead set the size_t to 0, to indicate no space.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nunsigned mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nunsigned md_size, md_block_size = 64;\nunsigned sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nunsigned int bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nunsigned i, j, md_out_size_u;\nEVP_MD_CTX md_ctx;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nunsigned md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nif (MD5_Init((MD5_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nif (SHA1_Init((SHA_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nif (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nif (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nif (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nif (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)\nreturn 0;\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nOPENSSL_assert(0);\nif (md_out_size)\nreturn 0;\n}\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nunsigned overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\nreturn 0;\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8(i, index_a);\nunsigned char is_block_b = constant_time_eq_8(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -175,305 +176,311 @@  */-void ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,+int ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-        MD5_Init((MD5_CTX *)md_state.c);+        if (MD5_Init((MD5_CTX *)md_state.c) <= 0)+            return 0;-        SHA1_Init((SHA_CTX *)md_state.c);+        if (SHA1_Init((SHA_CTX *)md_state.c) <= 0)+            return 0;-        SHA224_Init((SHA256_CTX *)md_state.c);+        if (SHA224_Init((SHA256_CTX *)md_state.c) <= 0)+            return 0;-        SHA256_Init((SHA256_CTX *)md_state.c);+        if (SHA256_Init((SHA256_CTX *)md_state.c) <= 0)+            return 0;-        SHA384_Init((SHA512_CTX *)md_state.c);+        if (SHA384_Init((SHA512_CTX *)md_state.c) <= 0)+            return 0;-        SHA512_Init((SHA512_CTX *)md_state.c);+        if (SHA512_Init((SHA512_CTX *)md_state.c) <= 0)+            return 0;-        return;+        return 0;-                return;+                return 0;",
            "commit_date": "2015-11-06 16:31:21+00:00",
            "commit_hash": "5f3d93e4a336c590d7b56a889dde4a93b725e058",
            "message": "Ensure all EVP calls have their returns checked where appropriate\nThere are lots of calls to EVP functions from within libssl There were\nvarious places where we should probably check the return value but don't.\nThis adds these checks.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nunsigned mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nunsigned md_size, md_block_size = 64;\nunsigned sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nunsigned int bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nunsigned i, j, md_out_size_u;\nEVP_MD_CTX md_ctx;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nunsigned md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nOPENSSL_assert(0);\nif (md_out_size)\n*md_out_size = -1;\n}\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\nunsigned overhang;\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no\n* ciphersuites in SSLv3 that are not SHA1 or MD5 based and\n* therefore we can be confident that the header_length will be\n* greater than |md_block_size|. However we add a sanity check just\n* in case\n*/\nif (header_length <= md_block_size) {\n/* Should never happen */\n}\noverhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8(i, index_a);\nunsigned char is_block_b = constant_time_eq_8(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -175,295 +175,305 @@  */ void ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {+            unsigned overhang;+-             * consumes: either 7 bytes (SHA1) or 11 bytes (MD5).+             * consumes: either 7 bytes (SHA1) or 11 bytes (MD5). There are no+             * ciphersuites in SSLv3 that are not SHA1 or MD5 based and+             * therefore we can be confident that the header_length will be+             * greater than |md_block_size|. However we add a sanity check just+             * in case-            unsigned overhang = header_length - md_block_size;+            if (header_length <= md_block_size) {+                /* Should never happen */+                return;+            }+            overhang = header_length - md_block_size;",
            "commit_date": "2015-04-27 15:41:42+01:00",
            "commit_hash": "29b0a15a480626544dd0c803d5de671552544de6",
            "message": "Add sanity check in ssl3_cbc_digest_record\nFor SSLv3 the code assumes that |header_length| > |md_block_size|. Whilst\nthis is true for all SSLv3 ciphersuites, this fact is far from obvious by\nlooking at the code. If this were not the case then an integer overflow\nwould occur, leading to a subsequent buffer overflow. Therefore I have\nadded an explicit sanity check to ensure header_length is always valid.\nThanks to Kevin Wojtysiak (Int3 Solutions) and Paramjot Oberoi (Int3\nSolutions) for reporting this issue.\nReviewed-by: Andy Polyakov <appro@openssl.org>\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nunsigned mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nunsigned md_size, md_block_size = 64;\nunsigned sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nunsigned int bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nunsigned i, j, md_out_size_u;\nEVP_MD_CTX md_ctx;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nunsigned md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nMD5_Init((MD5_CTX *)md_state.c);\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nSHA1_Init((SHA_CTX *)md_state.c);\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nSHA224_Init((SHA256_CTX *)md_state.c);\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nSHA256_Init((SHA256_CTX *)md_state.c);\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nSHA384_Init((SHA512_CTX *)md_state.c);\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nSHA512_Init((SHA512_CTX *)md_state.c);\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nOPENSSL_assert(0);\nif (md_out_size)\n*md_out_size = -1;\nreturn;\n}\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n*/\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8(i, index_a);\nunsigned char is_block_b = constant_time_eq_8(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "rsalz@openssl.org",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -408,299 +395,295 @@  */ void ssl3_cbc_digest_record(const EVP_MD_CTX *ctx, {-#ifndef OPENSSL_NO_SHA256-#endif-#ifndef OPENSSL_NO_SHA512-#endif",
            "commit_date": "2015-01-27 12:34:45-05:00",
            "commit_hash": "474e469bbd056aebcf7e7d3207ef820f2faed4ce",
            "message": "OPENSSL_NO_xxx cleanup: SHA\nRemove support for SHA0 and DSS0 (they were broken), and remove\nthe ability to attempt to build without SHA (it didn't work).\nFor simplicity, remove the option of not building various SHA algorithms;\nyou could argue that SHA_224/256/384/512 should be kept, since they're\nlike crypto algorithms, but I decided to go the other way.\nSo these options are gone:\nGENUINE_DSA         OPENSSL_NO_SHA0\nOPENSSL_NO_SHA      OPENSSL_NO_SHA1\nOPENSSL_NO_SHA224   OPENSSL_NO_SHA256\nOPENSSL_NO_SHA384   OPENSSL_NO_SHA512\nReviewed-by: Richard Levitte <levitte@openssl.org>\nunsigned char *md_out,\nsize_t *md_out_size,\nconst unsigned char header[13],\nconst unsigned char *data,\nsize_t data_plus_mac_size,\nsize_t data_plus_mac_plus_padding_size,\nconst unsigned char *mac_secret,\nunsigned mac_secret_length, char is_sslv3)\nunion {\ndouble align;\nunsigned char c[sizeof(LARGEST_DIGEST_CTX)];\n} md_state;\nvoid (*md_final_raw) (void *ctx, unsigned char *md_out);\nvoid (*md_transform) (void *ctx, const unsigned char *block);\nunsigned md_size, md_block_size = 64;\nunsigned sslv3_pad_length = 40, header_length, variance_blocks,\nlen, max_mac_bytes, num_blocks,\nnum_starting_blocks, k, mac_end_offset, c, index_a, index_b;\nunsigned int bits;          /* at most 18 bits */\nunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];\n/* hmac_pad is the masked HMAC key. */\nunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];\nunsigned char first_block[MAX_HASH_BLOCK_SIZE];\nunsigned char mac_out[EVP_MAX_MD_SIZE];\nunsigned i, j, md_out_size_u;\nEVP_MD_CTX md_ctx;\n/*\n* mdLengthSize is the number of bytes in the length field that\n* terminates * the hash.\n*/\nunsigned md_length_size = 8;\nchar length_is_big_endian = 1;\nint ret;\n/*\n* This is a, hopefully redundant, check that allows us to forget about\n* many possible overflows later in this function.\n*/\nOPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);\nswitch (EVP_MD_CTX_type(ctx)) {\ncase NID_md5:\nMD5_Init((MD5_CTX *)md_state.c);\nmd_final_raw = tls1_md5_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))MD5_Transform;\nmd_size = 16;\nsslv3_pad_length = 48;\nlength_is_big_endian = 0;\nbreak;\ncase NID_sha1:\nSHA1_Init((SHA_CTX *)md_state.c);\nmd_final_raw = tls1_sha1_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA1_Transform;\nmd_size = 20;\nbreak;\ncase NID_sha224:\nSHA224_Init((SHA256_CTX *)md_state.c);\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 224 / 8;\nbreak;\ncase NID_sha256:\nSHA256_Init((SHA256_CTX *)md_state.c);\nmd_final_raw = tls1_sha256_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA256_Transform;\nmd_size = 32;\nbreak;\ncase NID_sha384:\nSHA384_Init((SHA512_CTX *)md_state.c);\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 384 / 8;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ncase NID_sha512:\nSHA512_Init((SHA512_CTX *)md_state.c);\nmd_final_raw = tls1_sha512_final_raw;\nmd_transform =\n(void (*)(void *ctx, const unsigned char *block))SHA512_Transform;\nmd_size = 64;\nmd_block_size = 128;\nmd_length_size = 16;\nbreak;\ndefault:\n/*\n* ssl3_cbc_record_digest_supported should have been called first to\n* check that the hash function is supported.\n*/\nOPENSSL_assert(0);\nif (md_out_size)\n*md_out_size = -1;\nreturn;\n}\nOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);\nOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);\nOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);\nheader_length = 13;\nif (is_sslv3) {\nheader_length = mac_secret_length + sslv3_pad_length + 8 /* sequence\n* number */  +\n1 /* record type */  +\n2 /* record length */ ;\n}\n/*\n* variance_blocks is the number of blocks of the hash that we have to\n* calculate in constant time because they could be altered by the\n* padding value. In SSLv3, the padding must be minimal so the end of\n* the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively\n* assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes\n* of hash termination (0x80 + 64-bit length) don't fit in the final\n* block, we say that the final two blocks can vary based on the padding.\n* TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not\n* required to be minimal. Therefore we say that the final six blocks can\n* vary based on the padding. Later in the function, if the message is\n* short and there obviously cannot be this many blocks then\n* variance_blocks can be reduced.\n*/\nvariance_blocks = is_sslv3 ? 2 : 6;\n/*\n* From now on we're dealing with the MAC, which conceptually has 13\n* bytes of `header' before the start of the data (TLS) or 71/75 bytes\n* (SSLv3)\n*/\nlen = data_plus_mac_plus_padding_size + header_length;\n/*\n* max_mac_bytes contains the maximum bytes of bytes in the MAC,\n* including * |header|, assuming that there's no padding.\n*/\nmax_mac_bytes = len - md_size - 1;\n/* num_blocks is the maximum number of hash blocks. */\nnum_blocks =\n(max_mac_bytes + 1 + md_length_size + md_block_size -\n1) / md_block_size;\n/*\n* In order to calculate the MAC in constant time we have to handle the\n* final blocks specially because the padding value could cause the end\n* to appear somewhere in the final |variance_blocks| blocks and we can't\n* leak where. However, |num_starting_blocks| worth of data can be hashed\n* right away because no padding value can affect whether they are\n* plaintext.\n*/\nnum_starting_blocks = 0;\n/*\n* k is the starting byte offset into the conceptual header||data where\n* we start processing.\n*/\nk = 0;\n/*\n* mac_end_offset is the index just past the end of the data to be MACed.\n*/\nmac_end_offset = data_plus_mac_size + header_length - md_size;\n/*\n* c is the index of the 0x80 byte in the final hash block that contains\n* application data.\n*/\nc = mac_end_offset % md_block_size;\n/*\n* index_a is the hash block number that contains the 0x80 terminating\n* value.\n*/\nindex_a = mac_end_offset / md_block_size;\n/*\n* index_b is the hash block number that contains the 64-bit hash length,\n* in bits.\n*/\nindex_b = (mac_end_offset + md_length_size) / md_block_size;\n/*\n* bits is the hash-length in bits. It includes the additional hash block\n* for the masked HMAC key, or whole of |header| in the case of SSLv3.\n*/\n/*\n* For SSLv3, if we're going to have any starting blocks then we need at\n* least two because the header is larger than a single block.\n*/\nif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {\nnum_starting_blocks = num_blocks - variance_blocks;\nk = md_block_size * num_starting_blocks;\n}\nbits = 8 * mac_end_offset;\nif (!is_sslv3) {\n/*\n* Compute the initial HMAC block. For SSLv3, the padding and secret\n* bytes are included in |header| because they take more than a\n* single block.\n*/\nbits += 8 * md_block_size;\nmemset(hmac_pad, 0, md_block_size);\nOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));\nmemcpy(hmac_pad, mac_secret, mac_secret_length);\nfor (i = 0; i < md_block_size; i++)\nhmac_pad[i] ^= 0x36;\nmd_transform(md_state.c, hmac_pad);\n}\nif (length_is_big_endian) {\nmemset(length_bytes, 0, md_length_size - 4);\nlength_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 1] = (unsigned char)bits;\n} else {\nmemset(length_bytes, 0, md_length_size);\nlength_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);\nlength_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);\nlength_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);\nlength_bytes[md_length_size - 8] = (unsigned char)bits;\n}\nif (k > 0) {\nif (is_sslv3) {\n/*\n* The SSLv3 header is larger than a single block. overhang is\n* the number of bytes beyond a single block that the header\n* consumes: either 7 bytes (SHA1) or 11 bytes (MD5).\n*/\nunsigned overhang = header_length - md_block_size;\nmd_transform(md_state.c, header);\nmemcpy(first_block, header + md_block_size, overhang);\nmemcpy(first_block + overhang, data, md_block_size - overhang);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size - 1; i++)\nmd_transform(md_state.c, data + md_block_size * i - overhang);\n} else {\n/* k is a multiple of md_block_size. */\nmemcpy(first_block, header, 13);\nmemcpy(first_block + 13, data, md_block_size - 13);\nmd_transform(md_state.c, first_block);\nfor (i = 1; i < k / md_block_size; i++)\nmd_transform(md_state.c, data + md_block_size * i - 13);\n}\n}\nmemset(mac_out, 0, sizeof(mac_out));\n/*\n* We now process the final hash blocks. For each block, we construct it\n* in constant time. If the |i==index_a| then we'll include the 0x80\n* bytes and zero pad etc. For each block we selectively copy it, in\n* constant time, to |mac_out|.\n*/\nfor (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;\ni++) {\nunsigned char block[MAX_HASH_BLOCK_SIZE];\nunsigned char is_block_a = constant_time_eq_8(i, index_a);\nunsigned char is_block_b = constant_time_eq_8(i, index_b);\nfor (j = 0; j < md_block_size; j++) {\nunsigned char b = 0, is_past_c, is_past_cp1;\nif (k < header_length)\nb = header[k];\nelse if (k < data_plus_mac_plus_padding_size + header_length)\nb = data[k - header_length];\nk++;\nis_past_c = is_block_a & constant_time_ge_8(j, c);\nis_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);\n/*\n* If this is the block containing the end of the application\n* data, and we are at the offset for the 0x80 value, then\n* overwrite b with 0x80.\n*/\nb = constant_time_select_8(is_past_c, 0x80, b);\n/*\n* If this the the block containing the end of the application\n* data and we're past the 0x80 value then just write zero.\n*/\nb = b & ~is_past_cp1;\n/*\n* If this is index_b (the final block), but not index_a (the end\n* of the data), then the 64-bit length didn't fit into index_a\n* and we're having to add an extra block of zeros.\n*/\nb &= ~is_block_b | is_block_a;\n/*\n* The final bytes of one of the blocks contains the length.\n*/\nif (j >= md_block_size - md_length_size) {\n/* If this is index_b, write a length byte. */\nb = constant_time_select_8(is_block_b,\nlength_bytes[j -"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -401,315 +408,299 @@  */-void ssl3_cbc_digest_record(-\tconst EVP_MD_CTX *ctx,-\tunsigned char* md_out,-\tsize_t* md_out_size,-\tconst unsigned char header[13],-\tconst unsigned char *data,-\tsize_t data_plus_mac_size,-\tsize_t data_plus_mac_plus_padding_size,-\tconst unsigned char *mac_secret,-\tunsigned mac_secret_length,-\tchar is_sslv3)-\t{-\tunion {\tdouble align;-\t\tunsigned char c[sizeof(LARGEST_DIGEST_CTX)]; } md_state;-\tvoid (*md_final_raw)(void *ctx, unsigned char *md_out);-\tvoid (*md_transform)(void *ctx, const unsigned char *block);-\tunsigned md_size, md_block_size = 64;-\tunsigned sslv3_pad_length = 40, header_length, variance_blocks,-\t\t len, max_mac_bytes, num_blocks,-\t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b;-\tunsigned int bits;\t/* at most 18 bits */-\tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];-\t/* hmac_pad is the masked HMAC key. */-\tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];-\tunsigned char first_block[MAX_HASH_BLOCK_SIZE];-\tunsigned char mac_out[EVP_MAX_MD_SIZE];-\tunsigned i, j, md_out_size_u;-\tEVP_MD_CTX md_ctx;-\t/* mdLengthSize is the number of bytes in the length field that terminates-\t* the hash. */-\tunsigned md_length_size = 8;-\tchar length_is_big_endian = 1;-\tint ret;--\t/* This is a, hopefully redundant, check that allows us to forget about-\t * many possible overflows later in this function. */-\tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024);--\tswitch (EVP_MD_CTX_type(ctx))-\t\t{-\t\tcase NID_md5:-\t\t\tMD5_Init((MD5_CTX*)md_state.c);-\t\t\tmd_final_raw = tls1_md5_final_raw;-\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform;-\t\t\tmd_size = 16;-\t\t\tsslv3_pad_length = 48;-\t\t\tlength_is_big_endian = 0;-\t\t\tbreak;-\t\tcase NID_sha1:-\t\t\tSHA1_Init((SHA_CTX*)md_state.c);-\t\t\tmd_final_raw = tls1_sha1_final_raw;-\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform;-\t\t\tmd_size = 20;-\t\t\tbreak;+void ssl3_cbc_digest_record(const EVP_MD_CTX *ctx,+                            unsigned char *md_out,+                            size_t *md_out_size,+                            const unsigned char header[13],+                            const unsigned char *data,+                            size_t data_plus_mac_size,+                            size_t data_plus_mac_plus_padding_size,+                            const unsigned char *mac_secret,+                            unsigned mac_secret_length, char is_sslv3)+{+    union {+        double align;+        unsigned char c[sizeof(LARGEST_DIGEST_CTX)];+    } md_state;+    void (*md_final_raw) (void *ctx, unsigned char *md_out);+    void (*md_transform) (void *ctx, const unsigned char *block);+    unsigned md_size, md_block_size = 64;+    unsigned sslv3_pad_length = 40, header_length, variance_blocks,+        len, max_mac_bytes, num_blocks,+        num_starting_blocks, k, mac_end_offset, c, index_a, index_b;+    unsigned int bits;          /* at most 18 bits */+    unsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];+    /* hmac_pad is the masked HMAC key. */+    unsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];+    unsigned char first_block[MAX_HASH_BLOCK_SIZE];+    unsigned char mac_out[EVP_MAX_MD_SIZE];+    unsigned i, j, md_out_size_u;+    EVP_MD_CTX md_ctx;+    /*+     * mdLengthSize is the number of bytes in the length field that+     * terminates * the hash.+     */+    unsigned md_length_size = 8;+    char length_is_big_endian = 1;+    int ret;++    /*+     * This is a, hopefully redundant, check that allows us to forget about+     * many possible overflows later in this function.+     */+    OPENSSL_assert(data_plus_mac_plus_padding_size < 1024 * 1024);++    switch (EVP_MD_CTX_type(ctx)) {+    case NID_md5:+        MD5_Init((MD5_CTX *)md_state.c);+        md_final_raw = tls1_md5_final_raw;+        md_transform =+            (void (*)(void *ctx, const unsigned char *block))MD5_Transform;+        md_size = 16;+        sslv3_pad_length = 48;+        length_is_big_endian = 0;+        break;+    case NID_sha1:+        SHA1_Init((SHA_CTX *)md_state.c);+        md_final_raw = tls1_sha1_final_raw;+        md_transform =+            (void (*)(void *ctx, const unsigned char *block))SHA1_Transform;+        md_size = 20;+        break; #ifndef OPENSSL_NO_SHA256-\t\tcase NID_sha224:-\t\t\tSHA224_Init((SHA256_CTX*)md_state.c);-\t\t\tmd_final_raw = tls1_sha256_final_raw;-\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;-\t\t\tmd_size = 224/8;-\t\t\tbreak;-\t\tcase NID_sha256:-\t\t\tSHA256_Init((SHA256_CTX*)md_state.c);-\t\t\tmd_final_raw = tls1_sha256_final_raw;-\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;-\t\t\tmd_size = 32;-\t\t\tbreak;+    case NID_sha224:+        SHA224_Init((SHA256_CTX *)md_state.c);+        md_final_raw = tls1_sha256_final_raw;+        md_transform =+            (void (*)(void *ctx, const unsigned char *block))SHA256_Transform;+        md_size = 224 / 8;+        break;+    case NID_sha256:+        SHA256_Init((SHA256_CTX *)md_state.c);+        md_final_raw = tls1_sha256_final_raw;+        md_transform =+            (void (*)(void *ctx, const unsigned char *block))SHA256_Transform;+        md_size = 32;+        break; #endif #ifndef OPENSSL_NO_SHA512-\t\tcase NID_sha384:-\t\t\tSHA384_Init((SHA512_CTX*)md_state.c);-\t\t\tmd_final_raw = tls1_sha512_final_raw;-\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;-\t\t\tmd_size = 384/8;-\t\t\tmd_block_size = 128;-\t\t\tmd_length_size = 16;-\t\t\tbreak;-\t\tcase NID_sha512:-\t\t\tSHA512_Init((SHA512_CTX*)md_state.c);-\t\t\tmd_final_raw = tls1_sha512_final_raw;-\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;-\t\t\tmd_size = 64;-\t\t\tmd_block_size = 128;-\t\t\tmd_length_size = 16;-\t\t\tbreak;+    case NID_sha384:+        SHA384_Init((SHA512_CTX *)md_state.c);+        md_final_raw = tls1_sha512_final_raw;+        md_transform =+            (void (*)(void *ctx, const unsigned char *block))SHA512_Transform;+        md_size = 384 / 8;+        md_block_size = 128;+        md_length_size = 16;+        break;+    case NID_sha512:+        SHA512_Init((SHA512_CTX *)md_state.c);+        md_final_raw = tls1_sha512_final_raw;+        md_transform =+            (void (*)(void *ctx, const unsigned char *block))SHA512_Transform;+        md_size = 64;+        md_block_size = 128;+        md_length_size = 16;+        break; #endif-\t\tdefault:-\t\t\t/* ssl3_cbc_record_digest_supported should have been-\t\t\t * called first to check that the hash function is-\t\t\t * supported. */-\t\t\tOPENSSL_assert(0);-\t\t\tif (md_out_size)-\t\t\t\t*md_out_size = -1;-\t\t\treturn;-\t\t}--\tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);-\tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);-\tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);--\theader_length = 13;-\tif (is_sslv3)-\t\t{-\t\theader_length =-\t\t\tmac_secret_length +-\t\t\tsslv3_pad_length +-\t\t\t8 /* sequence number */ +-\t\t\t1 /* record type */ +-\t\t\t2 /* record length */;-\t\t}--\t/* variance_blocks is the number of blocks of the hash that we have to-\t * calculate in constant time because they could be altered by the-\t * padding value.-\t *-\t * In SSLv3, the padding must be minimal so the end of the plaintext-\t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that-\t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash-\t * termination (0x80 + 64-bit length) don't fit in the final block, we-\t * say that the final two blocks can vary based on the padding.-\t *-\t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not-\t * required to be minimal. Therefore we say that the final six blocks-\t * can vary based on the padding.-\t *-\t * Later in the function, if the message is short and there obviously-\t * cannot be this many blocks then variance_blocks can be reduced. */-\tvariance_blocks = is_sslv3 ? 2 : 6;-\t/* From now on we're dealing with the MAC, which conceptually has 13-\t * bytes of `header' before the start of the data (TLS) or 71/75 bytes-\t * (SSLv3) */-\tlen = data_plus_mac_plus_padding_size + header_length;-\t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including-\t* |header|, assuming that there's no padding. */-\tmax_mac_bytes = len - md_size - 1;-\t/* num_blocks is the maximum number of hash blocks. */-\tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size;-\t/* In order to calculate the MAC in constant time we have to handle-\t * the final blocks specially because the padding value could cause the-\t * end to appear somewhere in the final |variance_blocks| blocks and we-\t * can't leak where. However, |num_starting_blocks| worth of data can-\t * be hashed right away because no padding value can affect whether-\t * they are plaintext. */-\tnum_starting_blocks = 0;-\t/* k is the starting byte offset into the conceptual header||data where-\t * we start processing. */-\tk = 0;-\t/* mac_end_offset is the index just past the end of the data to be-\t * MACed. */-\tmac_end_offset = data_plus_mac_size + header_length - md_size;-\t/* c is the index of the 0x80 byte in the final hash block that-\t * contains application data. */-\tc = mac_end_offset % md_block_size;-\t/* index_a is the hash block number that contains the 0x80 terminating-\t * value. */-\tindex_a = mac_end_offset / md_block_size;-\t/* index_b is the hash block number that contains the 64-bit hash-\t * length, in bits. */-\tindex_b = (mac_end_offset + md_length_size) / md_block_size;-\t/* bits is the hash-length in bits. It includes the additional hash-\t * block for the masked HMAC key, or whole of |header| in the case of-\t * SSLv3. */--\t/* For SSLv3, if we're going to have any starting blocks then we need-\t * at least two because the header is larger than a single block. */-\tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0))-\t\t{-\t\tnum_starting_blocks = num_blocks - variance_blocks;-\t\tk = md_block_size*num_starting_blocks;-\t\t}--\tbits = 8*mac_end_offset;-\tif (!is_sslv3)-\t\t{-\t\t/* Compute the initial HMAC block. For SSLv3, the padding and-\t\t * secret bytes are included in |header| because they take more-\t\t * than a single block. */-\t\tbits += 8*md_block_size;-\t\tmemset(hmac_pad, 0, md_block_size);-\t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));-\t\tmemcpy(hmac_pad, mac_secret, mac_secret_length);-\t\tfor (i = 0; i < md_block_size; i++)-\t\t\thmac_pad[i] ^= 0x36;--\t\tmd_transform(md_state.c, hmac_pad);-\t\t}--\tif (length_is_big_endian)-\t\t{-\t\tmemset(length_bytes,0,md_length_size-4);-\t\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24);-\t\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16);-\t\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8);-\t\tlength_bytes[md_length_size-1] = (unsigned char)bits;-\t\t}-\telse-\t\t{-\t\tmemset(length_bytes,0,md_length_size);-\t\tlength_bytes[md_length_size-5] = (unsigned char)(bits>>24);-\t\tlength_bytes[md_length_size-6] = (unsigned char)(bits>>16);-\t\tlength_bytes[md_length_size-7] = (unsigned char)(bits>>8);-\t\tlength_bytes[md_length_size-8] = (unsigned char)bits;-\t\t}--\tif (k > 0)-\t\t{-\t\tif (is_sslv3)-\t\t\t{-\t\t\t/* The SSLv3 header is larger than a single block.-\t\t\t * overhang is the number of bytes beyond a single-\t\t\t * block that the header consumes: either 7 bytes-\t\t\t * (SHA1) or 11 bytes (MD5). */-\t\t\tunsigned overhang = header_length-md_block_size;-\t\t\tmd_transform(md_state.c, header);-\t\t\tmemcpy(first_block, header + md_block_size, overhang);-\t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang);-\t\t\tmd_transform(md_state.c, first_block);-\t\t\tfor (i = 1; i < k/md_block_size - 1; i++)-\t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang);-\t\t\t}-\t\telse-\t\t\t{-\t\t\t/* k is a multiple of md_block_size. */-\t\t\tmemcpy(first_block, header, 13);-\t\t\tmemcpy(first_block+13, data, md_block_size-13);-\t\t\tmd_transform(md_state.c, first_block);-\t\t\tfor (i = 1; i < k/md_block_size; i++)-\t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13);-\t\t\t}-\t\t}--\tmemset(mac_out, 0, sizeof(mac_out));--\t/* We now process the final hash blocks. For each block, we construct-\t * it in constant time. If the |i==index_a| then we'll include the 0x80-\t * bytes and zero pad etc. For each block we selectively copy it, in-\t * constant time, to |mac_out|. */-\tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++)-\t\t{-\t\tunsigned char block[MAX_HASH_BLOCK_SIZE];-\t\tunsigned char is_block_a = constant_time_eq_8(i, index_a);-\t\tunsigned char is_block_b = constant_time_eq_8(i, index_b);-\t\tfor (j = 0; j < md_block_size; j++)-\t\t\t{-\t\t\tunsigned char b = 0, is_past_c, is_past_cp1;-\t\t\tif (k < header_length)-\t\t\t\tb = header[k];-\t\t\telse if (k < data_plus_mac_plus_padding_size + header_length)-\t\t\t\tb = data[k-header_length];-\t\t\tk++;--\t\t\tis_past_c = is_block_a & constant_time_ge_8(j, c);-\t\t\tis_past_cp1 = is_block_a & constant_time_ge_8(j, c+1);-\t\t\t/* If this is the block containing the end of the-\t\t\t * application data, and we are at the offset for the-\t\t\t * 0x80 value, then overwrite b with 0x80. */-                        b =  constant_time_select_8(is_past_c, 0x80, b);-\t\t\t/* If this the the block containing the end of the-\t\t\t * application data and we're past the 0x80 value then-\t\t\t * just write zero. */-\t\t\tb = b&~is_past_cp1;-\t\t\t/* If this is index_b (the final block), but not-\t\t\t * index_a (the end of the data), then the 64-bit-\t\t\t * length didn't fit into index_a and we're having to-\t\t\t * add an extra block of zeros. */-\t\t\tb &= ~is_block_b | is_block_a;--\t\t\t/* The final bytes of one of the blocks contains the-\t\t\t * length. */-\t\t\tif (j >= md_block_size - md_length_size)-\t\t\t\t{-\t\t\t\t/* If this is index_b, write a length byte. */-\t\t\t\tb = constant_time_select_8(-\t\t\t\t\tis_block_b, length_bytes[j-(md_block_size-md_length_size)], b);-\t\t\t\t}-\t\t\tblock[j] = b;-\t\t\t}--\t\tmd_transform(md_state.c, block);-\t\tmd_final_raw(md_state.c, block);-\t\t/* If this is index_b, copy the hash value to |mac_out|. */-\t\tfor (j = 0; j < md_size; j++)-\t\t\tmac_out[j] |= block[j]&is_block_b;-\t\t}--\tEVP_MD_CTX_init(&md_ctx);-\tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */);-\tif (is_sslv3)-\t\t{-\t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */-\t\tmemset(hmac_pad, 0x5c, sslv3_pad_length);--\t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length);-\t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length);-\t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size);-\t\t}-\telse-\t\t{-\t\t/* Complete the HMAC in the standard manner. */-\t\tfor (i = 0; i < md_block_size; i++)-\t\t\thmac_pad[i] ^= 0x6a;--\t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size);-\t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size);-\t\t}-\tret = EVP_DigestFinal(&md_ctx, md_out, &md_out_size_u);-\tif (ret && md_out_size)-\t\t*md_out_size = md_out_size_u;-\tEVP_MD_CTX_cleanup(&md_ctx);-\t}--/* Due to the need to use EVP in FIPS mode we can't reimplement digests but- * we can ensure the number of blocks processed is equal for all cases- * by digesting additional data.+    default:+        /*+         * ssl3_cbc_record_digest_supported should have been called first to+         * check that the hash function is supported.+         */+        OPENSSL_assert(0);+        if (md_out_size)+            *md_out_size = -1;+        return;+    }++    OPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);+    OPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);+    OPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);++    header_length = 13;+    if (is_sslv3) {+        header_length = mac_secret_length + sslv3_pad_length + 8 /* sequence+                                                                  * number */  ++            1 /* record type */  ++            2 /* record length */ ;+    }++    /*+     * variance_blocks is the number of blocks of the hash that we have to+     * calculate in constant time because they could be altered by the+     * padding value. In SSLv3, the padding must be minimal so the end of+     * the plaintext varies by, at most, 15+20 = 35 bytes. (We conservatively+     * assume that the MAC size varies from 0..20 bytes.) In case the 9 bytes+     * of hash termination (0x80 + 64-bit length) don't fit in the final+     * block, we say that the final two blocks can vary based on the padding.+     * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not+     * required to be minimal. Therefore we say that the final six blocks can+     * vary based on the padding. Later in the function, if the message is+     * short and there obviously cannot be this many blocks then+     * variance_blocks can be reduced.+     */+    variance_blocks = is_sslv3 ? 2 : 6;+    /*+     * From now on we're dealing with the MAC, which conceptually has 13+     * bytes of `header' before the start of the data (TLS) or 71/75 bytes+     * (SSLv3)+     */+    len = data_plus_mac_plus_padding_size + header_length;+    /*+     * max_mac_bytes contains the maximum bytes of bytes in the MAC,+     * including * |header|, assuming that there's no padding.+     */+    max_mac_bytes = len - md_size - 1;+    /* num_blocks is the maximum number of hash blocks. */+    num_blocks =+        (max_mac_bytes + 1 + md_length_size + md_block_size -+         1) / md_block_size;+    /*+     * In order to calculate the MAC in constant time we have to handle the+     * final blocks specially because the padding value could cause the end+     * to appear somewhere in the final |variance_blocks| blocks and we can't+     * leak where. However, |num_starting_blocks| worth of data can be hashed+     * right away because no padding value can affect whether they are+     * plaintext.+     */+    num_starting_blocks = 0;+    /*+     * k is the starting byte offset into the conceptual header||data where+     * we start processing.+     */+    k = 0;+    /*+     * mac_end_offset is the index just past the end of the data to be MACed.+     */+    mac_end_offset = data_plus_mac_size + header_length - md_size;+    /*+     * c is the index of the 0x80 byte in the final hash block that contains+     * application data.+     */+    c = mac_end_offset % md_block_size;+    /*+     * index_a is the hash block number that contains the 0x80 terminating+     * value.+     */+    index_a = mac_end_offset / md_block_size;+    /*+     * index_b is the hash block number that contains the 64-bit hash length,+     * in bits.+     */+    index_b = (mac_end_offset + md_length_size) / md_block_size;+    /*+     * bits is the hash-length in bits. It includes the additional hash block+     * for the masked HMAC key, or whole of |header| in the case of SSLv3.+     */++    /*+     * For SSLv3, if we're going to have any starting blocks then we need at+     * least two because the header is larger than a single block.+     */+    if (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) {+        num_starting_blocks = num_blocks - variance_blocks;+        k = md_block_size * num_starting_blocks;+    }++    bits = 8 * mac_end_offset;+    if (!is_sslv3) {+        /*+         * Compute the initial HMAC block. For SSLv3, the padding and secret+         * bytes are included in |header| because they take more than a+         * single block.+         */+        bits += 8 * md_block_size;+        memset(hmac_pad, 0, md_block_size);+        OPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));+        memcpy(hmac_pad, mac_secret, mac_secret_length);+        for (i = 0; i < md_block_size; i++)+            hmac_pad[i] ^= 0x36;++        md_transform(md_state.c, hmac_pad);+    }++    if (length_is_big_endian) {+        memset(length_bytes, 0, md_length_size - 4);+        length_bytes[md_length_size - 4] = (unsigned char)(bits >> 24);+        length_bytes[md_length_size - 3] = (unsigned char)(bits >> 16);+        length_bytes[md_length_size - 2] = (unsigned char)(bits >> 8);+        length_bytes[md_length_size - 1] = (unsigned char)bits;+    } else {+        memset(length_bytes, 0, md_length_size);+        length_bytes[md_length_size - 5] = (unsigned char)(bits >> 24);+        length_bytes[md_length_size - 6] = (unsigned char)(bits >> 16);+        length_bytes[md_length_size - 7] = (unsigned char)(bits >> 8);+        length_bytes[md_length_size - 8] = (unsigned char)bits;+    }++    if (k > 0) {+        if (is_sslv3) {+            /*+             * The SSLv3 header is larger than a single block. overhang is+             * the number of bytes beyond a single block that the header+             * consumes: either 7 bytes (SHA1) or 11 bytes (MD5).+             */+            unsigned overhang = header_length - md_block_size;+            md_transform(md_state.c, header);+            memcpy(first_block, header + md_block_size, overhang);+            memcpy(first_block + overhang, data, md_block_size - overhang);+            md_transform(md_state.c, first_block);+            for (i = 1; i < k / md_block_size - 1; i++)+                md_transform(md_state.c, data + md_block_size * i - overhang);+        } else {+            /* k is a multiple of md_block_size. */+            memcpy(first_block, header, 13);+            memcpy(first_block + 13, data, md_block_size - 13);+            md_transform(md_state.c, first_block);+            for (i = 1; i < k / md_block_size; i++)+                md_transform(md_state.c, data + md_block_size * i - 13);+        }+    }++    memset(mac_out, 0, sizeof(mac_out));++    /*+     * We now process the final hash blocks. For each block, we construct it+     * in constant time. If the |i==index_a| then we'll include the 0x80+     * bytes and zero pad etc. For each block we selectively copy it, in+     * constant time, to |mac_out|.+     */+    for (i = num_starting_blocks; i <= num_starting_blocks + variance_blocks;+         i++) {+        unsigned char block[MAX_HASH_BLOCK_SIZE];+        unsigned char is_block_a = constant_time_eq_8(i, index_a);+        unsigned char is_block_b = constant_time_eq_8(i, index_b);+        for (j = 0; j < md_block_size; j++) {+            unsigned char b = 0, is_past_c, is_past_cp1;+            if (k < header_length)+                b = header[k];+            else if (k < data_plus_mac_plus_padding_size + header_length)+                b = data[k - header_length];+            k++;++            is_past_c = is_block_a & constant_time_ge_8(j, c);+            is_past_cp1 = is_block_a & constant_time_ge_8(j, c + 1);+            /*+             * If this is the block containing the end of the application+             * data, and we are at the offset for the 0x80 value, then+             * overwrite b with 0x80.+             */+            b = constant_time_select_8(is_past_c, 0x80, b);+            /*+             * If this the the block containing the end of the application+             * data and we're past the 0x80 value then just write zero.+             */+            b = b & ~is_past_cp1;+            /*+             * If this is index_b (the final block), but not index_a (the end+             * of the data), then the 64-bit length didn't fit into index_a+             * and we're having to add an extra block of zeros.+             */+            b &= ~is_block_b | is_block_a;++            /*+             * The final bytes of one of the blocks contains the length.+             */+            if (j >= md_block_size - md_length_size) {+                /* If this is index_b, write a length byte. */+                b = constant_time_select_8(is_block_b,+                                           length_bytes[j -",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "tjh@openssl.org",
                "name": "Tim Hudson"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -394,315 +401,315 @@- * padding too. ) */+ */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunion {\tdouble align; \t\tunsigned char c[sizeof(LARGEST_DIGEST_CTX)]; } md_state; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \tchar length_is_big_endian = 1; \tint ret; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (EVP_MD_CTX_type(ctx)) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tlength_is_big_endian = 0; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; #ifndef OPENSSL_NO_SHA256 \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; #endif #ifndef OPENSSL_NO_SHA512 \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; #endif \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state.c, hmac_pad); \t\t} \tif (length_is_big_endian) \t\t{ \t\tmemset(length_bytes,0,md_length_size-4); \t\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-1] = (unsigned char)bits; \t\t} \telse \t\t{ \t\tmemset(length_bytes,0,md_length_size); \t\tlength_bytes[md_length_size-5] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-6] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-7] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-8] = (unsigned char)bits; \t\t} \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state.c, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge_8(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge_8(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = constant_time_select_8( \t\t\t\t\tis_block_b, length_bytes[j-(md_block_size-md_length_size)], b); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state.c, block); \t\tmd_final_raw(md_state.c, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tret = EVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (ret && md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t} /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2014-12-28 12:48:40+10:00",
            "commit_hash": "1d97c8435171a7af575f73c526d79e1ef0ee5960",
            "message": "mark all block comments that need format preserving so that\nindent will not alter them when reformatting comments\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nb =  constant_time_select_8(is_past_c, 0x80, b);"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -396,317 +394,315 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunion {\tdouble align; \t\tunsigned char c[sizeof(LARGEST_DIGEST_CTX)]; } md_state; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \tchar length_is_big_endian = 1; \tint ret; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (EVP_MD_CTX_type(ctx)) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tlength_is_big_endian = 0; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; #ifndef OPENSSL_NO_SHA256 \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; #endif #ifndef OPENSSL_NO_SHA512 \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; #endif \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state.c, hmac_pad); \t\t} \tif (length_is_big_endian) \t\t{ \t\tmemset(length_bytes,0,md_length_size-4); \t\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-1] = (unsigned char)bits; \t\t} \telse \t\t{ \t\tmemset(length_bytes,0,md_length_size); \t\tlength_bytes[md_length_size-5] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-6] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-7] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-8] = (unsigned char)bits; \t\t} \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state.c, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge_8(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge_8(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = constant_time_select_8( \t\t\t\t\tis_block_b, length_bytes[j-(md_block_size-md_length_size)], b); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state.c, block); \t\tmd_final_raw(md_state.c, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tret = EVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (ret && md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t}-#ifdef OPENSSL_FIPS- /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2014-10-18 20:14:36+01:00",
            "commit_hash": "00b4ee7664051a0dc589b1d81ba56582576a6ca4",
            "message": "Remove some unnecessary OPENSSL_FIPS references\nFIPS_mode() exists in all versions of OpenSSL but always returns 0 if OpenSSL is not FIPS\ncapable.\nReviewed-by: Tim Hudson <tjh@openssl.org>\nb =  constant_time_select_8(is_past_c, 0x80, b);"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -396,316 +396,317 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunion {\tdouble align; \t\tunsigned char c[sizeof(LARGEST_DIGEST_CTX)]; } md_state; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \tchar length_is_big_endian = 1; \tint ret; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (EVP_MD_CTX_type(ctx)) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tlength_is_big_endian = 0; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; #ifndef OPENSSL_NO_SHA256 \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; #endif #ifndef OPENSSL_NO_SHA512 \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; #endif \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state.c, hmac_pad); \t\t} \tif (length_is_big_endian) \t\t{ \t\tmemset(length_bytes,0,md_length_size-4); \t\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-1] = (unsigned char)bits; \t\t} \telse \t\t{ \t\tmemset(length_bytes,0,md_length_size); \t\tlength_bytes[md_length_size-5] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-6] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-7] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-8] = (unsigned char)bits; \t\t} \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state.c, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge_8(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge_8(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */-\t\t\tb = (b&~is_past_c) | (0x80&is_past_c);+                        b =  constant_time_select_8(is_past_c, 0x80, b); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */-\t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]);+\t\t\t\tb = constant_time_select_8(+\t\t\t\t\tis_block_b, length_bytes[j-(md_block_size-md_length_size)], b); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state.c, block); \t\tmd_final_raw(md_state.c, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tret = EVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (ret && md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t} #ifdef OPENSSL_FIPS /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2014-08-28 19:43:49+02:00",
            "commit_hash": "294d1e36c2495ff00e697c9ff622856d3114f14f",
            "message": "RT3066: rewrite RSA padding checks to be slightly more constant time.\nAlso tweak s3_cbc.c to use new constant-time methods.\nAlso fix memory leaks from internal errors in RSA_padding_check_PKCS1_OAEP_mgf1\nThis patch is based on the original RT submission by Adam Langley <agl@chromium.org>,\nas well as code from BoringSSL and OpenSSL.\nReviewed-by: Kurt Roeckx <kurt@openssl.org>"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -432,316 +396,316 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunion {\tdouble align; \t\tunsigned char c[sizeof(LARGEST_DIGEST_CTX)]; } md_state; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \tchar length_is_big_endian = 1; \tint ret; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (EVP_MD_CTX_type(ctx)) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tlength_is_big_endian = 0; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; #ifndef OPENSSL_NO_SHA256 \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; #endif #ifndef OPENSSL_NO_SHA512 \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; #endif \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state.c, hmac_pad); \t\t} \tif (length_is_big_endian) \t\t{ \t\tmemset(length_bytes,0,md_length_size-4); \t\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-1] = (unsigned char)bits; \t\t} \telse \t\t{ \t\tmemset(length_bytes,0,md_length_size); \t\tlength_bytes[md_length_size-5] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-6] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-7] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-8] = (unsigned char)bits; \t\t} \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state.c, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++;-\t\t\tis_past_c = is_block_a & constant_time_ge(j, c);-\t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1);+\t\t\tis_past_c = is_block_a & constant_time_ge_8(j, c);+\t\t\tis_past_cp1 = is_block_a & constant_time_ge_8(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\tb = (b&~is_past_c) | (0x80&is_past_c); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state.c, block); \t\tmd_final_raw(md_state.c, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tret = EVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (ret && md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t} #ifdef OPENSSL_FIPS /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2014-08-28 15:33:34+02:00",
            "commit_hash": "5a3d21c0585064292bde5cd34089e120487ab687",
            "message": "Constant-time utilities\nPull constant-time methods out to a separate header, add tests.\nReviewed-by: Bodo Moeller <bodo@openssl.org>"
        },
        {
            "author": {
                "email": "ben@links.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -432,315 +432,316 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunion {\tdouble align; \t\tunsigned char c[sizeof(LARGEST_DIGEST_CTX)]; } md_state; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \tchar length_is_big_endian = 1;+\tint ret; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (EVP_MD_CTX_type(ctx)) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tlength_is_big_endian = 0; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; #ifndef OPENSSL_NO_SHA256 \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; #endif #ifndef OPENSSL_NO_SHA512 \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; #endif \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state.c, hmac_pad); \t\t} \tif (length_is_big_endian) \t\t{ \t\tmemset(length_bytes,0,md_length_size-4); \t\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-1] = (unsigned char)bits; \t\t} \telse \t\t{ \t\tmemset(length_bytes,0,md_length_size); \t\tlength_bytes[md_length_size-5] = (unsigned char)(bits>>24); \t\tlength_bytes[md_length_size-6] = (unsigned char)(bits>>16); \t\tlength_bytes[md_length_size-7] = (unsigned char)(bits>>8); \t\tlength_bytes[md_length_size-8] = (unsigned char)bits; \t\t} \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state.c, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\tb = (b&~is_past_c) | (0x80&is_past_c); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state.c, block); \t\tmd_final_raw(md_state.c, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t}-\tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u);-\tif (md_out_size)+\tret = EVP_DigestFinal(&md_ctx, md_out, &md_out_size_u);+\tif (ret && md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t} #ifdef OPENSSL_FIPS /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2013-02-21 18:30:04+00:00",
            "commit_hash": "0850f11855fff2691d5827ea56b4b55307163612",
            "message": "Fix ignored return value warnings.\nNot sure why I am getting these now and not before."
        },
        {
            "author": {
                "email": "agl@chromium.org",
                "name": "Adam Langley"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -428,302 +436,315 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunion {\tdouble align; \t\tunsigned char c[sizeof(LARGEST_DIGEST_CTX)]; } md_state; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8;+\tchar length_is_big_endian = 1; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (EVP_MD_CTX_type(ctx)) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48;+\t\t\tlength_is_big_endian = 0; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; #ifndef OPENSSL_NO_SHA256 \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; #endif #ifndef OPENSSL_NO_SHA512 \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; #endif \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state.c, hmac_pad); \t\t}-\tmemset(length_bytes,0,md_length_size-4);-\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24);-\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16);-\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8);-\tlength_bytes[md_length_size-1] = (unsigned char)bits;+\tif (length_is_big_endian)+\t\t{+\t\tmemset(length_bytes,0,md_length_size-4);+\t\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24);+\t\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16);+\t\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8);+\t\tlength_bytes[md_length_size-1] = (unsigned char)bits;+\t\t}+\telse+\t\t{+\t\tmemset(length_bytes,0,md_length_size);+\t\tlength_bytes[md_length_size-5] = (unsigned char)(bits>>24);+\t\tlength_bytes[md_length_size-6] = (unsigned char)(bits>>16);+\t\tlength_bytes[md_length_size-7] = (unsigned char)(bits>>8);+\t\tlength_bytes[md_length_size-8] = (unsigned char)bits;+\t\t} \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state.c, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\tb = (b&~is_past_c) | (0x80&is_past_c); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state.c, block); \t\tmd_final_raw(md_state.c, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t} #ifdef OPENSSL_FIPS /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2013-02-06 16:05:40+00:00",
            "commit_hash": "32620fe9d15749dc35aa0c96fe38f9b431229f90",
            "message": "Fix for EXP-RC2-CBC-MD5\nMD5 should use little endian order. Fortunately the only ciphersuite\naffected is EXP-RC2-CBC-MD5 (TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5) which\nis a rarely used export grade ciphersuite.\n(cherry picked from commit f306b87d766e6ecf30824635c7c395b67cff9dbc)"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -418,302 +418,302 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunion {\tdouble align; \t\tunsigned char c[sizeof(LARGEST_DIGEST_CTX)]; } md_state; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024);-\tswitch (ctx->digest->type)+\tswitch (EVP_MD_CTX_type(ctx)) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; #ifndef OPENSSL_NO_SHA256 \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; #endif #ifndef OPENSSL_NO_SHA512 \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; #endif \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state.c, hmac_pad); \t\t} \tmemset(length_bytes,0,md_length_size-4); \tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24); \tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16); \tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8); \tlength_bytes[md_length_size-1] = (unsigned char)bits; \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state.c, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\tb = (b&~is_past_c) | (0x80&is_past_c); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state.c, block); \t\tmd_final_raw(md_state.c, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t} #ifdef OPENSSL_FIPS /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2013-02-01 13:53:43+00:00",
            "commit_hash": "b714a1fe09fc03588b0a0f6f8f14488bd3a2efaf",
            "message": "Don't access EVP_MD_CTX internals directly.\n(cherry picked from commit 04e45b52ee3be81121359cc1198fd01e38096e9f)"
        },
        {
            "author": {
                "email": "appro@openssl.org",
                "name": "Andy Polyakov"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -405,298 +418,302 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunion {\tdouble align;-\t\tunsigned char c[sizeof(SHA512_CTX)]; } md_state;+\t\tunsigned char c[sizeof(LARGEST_DIGEST_CTX)]; } md_state; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (ctx->digest->type) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak;+#ifndef OPENSSL_NO_SHA256 \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak;+#endif+#ifndef OPENSSL_NO_SHA512 \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak;+#endif \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state.c, hmac_pad); \t\t} \tmemset(length_bytes,0,md_length_size-4); \tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24); \tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16); \tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8); \tlength_bytes[md_length_size-1] = (unsigned char)bits; \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state.c, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\tb = (b&~is_past_c) | (0x80&is_past_c); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state.c, block); \t\tmd_final_raw(md_state.c, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t} #ifdef OPENSSL_FIPS /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2013-02-01 10:10:32+01:00",
            "commit_hash": "bbb4ee85748743d19576a430034f28026c39903c",
            "message": "s3/s3_cbc.c: allow for compilations with NO_SHA256|512.\n(cherry picked from commit d5371324d978e4096bf99b9d0fe71b2cb65d9dc8)"
        },
        {
            "author": {
                "email": "appro@openssl.org",
                "name": "Andy Polyakov"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -405,297 +405,298 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{-\tunsigned char md_state[sizeof(SHA512_CTX)];+\tunion {\tdouble align;+\t\tunsigned char c[sizeof(SHA512_CTX)]; } md_state; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (ctx->digest->type) \t\t{ \t\tcase NID_md5:-\t\t\tMD5_Init((MD5_CTX*)md_state);+\t\t\tMD5_Init((MD5_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tbreak; \t\tcase NID_sha1:-\t\t\tSHA1_Init((SHA_CTX*)md_state);+\t\t\tSHA1_Init((SHA_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; \t\tcase NID_sha224:-\t\t\tSHA224_Init((SHA256_CTX*)md_state);+\t\t\tSHA224_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256:-\t\t\tSHA256_Init((SHA256_CTX*)md_state);+\t\t\tSHA256_Init((SHA256_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; \t\tcase NID_sha384:-\t\t\tSHA384_Init((SHA512_CTX*)md_state);+\t\t\tSHA384_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512:-\t\t\tSHA512_Init((SHA512_CTX*)md_state);+\t\t\tSHA512_Init((SHA512_CTX*)md_state.c); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36;-\t\tmd_transform(md_state, hmac_pad);+\t\tmd_transform(md_state.c, hmac_pad); \t\t} \tmemset(length_bytes,0,md_length_size-4); \tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24); \tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16); \tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8); \tlength_bytes[md_length_size-1] = (unsigned char)bits; \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size;-\t\t\tmd_transform(md_state, header);+\t\t\tmd_transform(md_state.c, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang);-\t\t\tmd_transform(md_state, first_block);+\t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++)-\t\t\t\tmd_transform(md_state, data + md_block_size*i - overhang);+\t\t\t\tmd_transform(md_state.c, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13);-\t\t\tmd_transform(md_state, first_block);+\t\t\tmd_transform(md_state.c, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++)-\t\t\t\tmd_transform(md_state, data + md_block_size*i - 13);+\t\t\t\tmd_transform(md_state.c, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\tb = (b&~is_past_c) | (0x80&is_past_c); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t}-\t\tmd_transform(md_state, block);-\t\tmd_final_raw(md_state, block);+\t\tmd_transform(md_state.c, block);+\t\tmd_final_raw(md_state.c, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t} #ifdef OPENSSL_FIPS /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2013-02-01 09:59:56+01:00",
            "commit_hash": "4af91ec072242305f4b6560330e7161b122dc461",
            "message": "ssl/s3_cbc.c: md_state alignment portability fix.\nRISCs are picky and alignment granted by compiler for md_state can be\ninsufficient for SHA512.\n(cherry picked from commit 36260233e7e3396feed884d3f501283e0453c04f)"
        },
        {
            "author": {
                "email": "appro@openssl.org",
                "name": "Andy Polyakov"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -407,300 +405,297 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunsigned char md_state[sizeof(SHA512_CTX)]; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b;-\tuint64_t bits;+\tunsigned int bits;\t/* at most 18 bits */ \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (ctx->digest->type) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state, hmac_pad); \t\t}-\tj = 0;-\tif (md_length_size == 16)-\t\t{-\t\tmemset(length_bytes, 0, 8);-\t\tj = 8;-\t\t}-\tfor (i = 0; i < 8; i++)-\t\tlength_bytes[i+j] = bits >> (8*(7-i));+\tmemset(length_bytes,0,md_length_size-4);+\tlength_bytes[md_length_size-4] = (unsigned char)(bits>>24);+\tlength_bytes[md_length_size-3] = (unsigned char)(bits>>16);+\tlength_bytes[md_length_size-2] = (unsigned char)(bits>>8);+\tlength_bytes[md_length_size-1] = (unsigned char)bits; \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\tb = (b&~is_past_c) | (0x80&is_past_c); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state, block); \t\tmd_final_raw(md_state, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t} #ifdef OPENSSL_FIPS /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2013-02-01 09:55:43+01:00",
            "commit_hash": "6b2a843970387ca07c505696129e80d439b1e5f8",
            "message": "ssl/s3_cbc.c: uint64_t portability fix.\nBreak dependency on uint64_t. It's possible to declare bits as\nunsigned int, because TLS packets are limited in size and 32-bit\nvalue can't overflow.\n(cherry picked from commit cab13fc8473856a43556d41d8dac5605f4ba1f91)"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -407,300 +407,300 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunsigned char md_state[sizeof(SHA512_CTX)]; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tuint64_t bits; \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (ctx->digest->type) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state, hmac_pad); \t\t} \tj = 0; \tif (md_length_size == 16) \t\t{ \t\tmemset(length_bytes, 0, 8); \t\tj = 8; \t\t} \tfor (i = 0; i < 8; i++) \t\tlength_bytes[i+j] = bits >> (8*(7-i)); \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\tb = (b&~is_past_c) | (0x80&is_past_c); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state, block); \t\tmd_final_raw(md_state, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t}-#ifndef OPENSSL_FIPS+#ifdef OPENSSL_FIPS /* Due to the need to use EVP in FIPS mode we can't reimplement digests but  * we can ensure the number of blocks processed is equal for all cases  * by digesting additional data.",
            "commit_date": "2013-01-31 23:04:39+00:00",
            "commit_hash": "6b1f7beeee7edd0613a1913c08b4f101c7ea7af7",
            "message": "typo.\n(cherry picked from commit 34ab3c8c711ff79c2b768f0b17e4b2a78fd1df5d)"
        },
        {
            "author": {
                "email": "steve@openssl.org",
                "name": "Dr. Stephen Henson"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- a/ssl/s3_cbc.c+++ b/ssl/s3_cbc.c@@ -403,294 +407,300 @@  * padding too. ) */ void ssl3_cbc_digest_record( \tconst EVP_MD_CTX *ctx, \tunsigned char* md_out, \tsize_t* md_out_size, \tconst unsigned char header[13], \tconst unsigned char *data, \tsize_t data_plus_mac_size, \tsize_t data_plus_mac_plus_padding_size, \tconst unsigned char *mac_secret, \tunsigned mac_secret_length, \tchar is_sslv3) \t{ \tunsigned char md_state[sizeof(SHA512_CTX)]; \tvoid (*md_final_raw)(void *ctx, unsigned char *md_out); \tvoid (*md_transform)(void *ctx, const unsigned char *block); \tunsigned md_size, md_block_size = 64; \tunsigned sslv3_pad_length = 40, header_length, variance_blocks, \t\t len, max_mac_bytes, num_blocks, \t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b; \tuint64_t bits; \tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES]; \t/* hmac_pad is the masked HMAC key. */ \tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE]; \tunsigned char first_block[MAX_HASH_BLOCK_SIZE]; \tunsigned char mac_out[EVP_MAX_MD_SIZE]; \tunsigned i, j, md_out_size_u; \tEVP_MD_CTX md_ctx; \t/* mdLengthSize is the number of bytes in the length field that terminates \t* the hash. */ \tunsigned md_length_size = 8; \t/* This is a, hopefully redundant, check that allows us to forget about \t * many possible overflows later in this function. */ \tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024); \tswitch (ctx->digest->type) \t\t{ \t\tcase NID_md5: \t\t\tMD5_Init((MD5_CTX*)md_state); \t\t\tmd_final_raw = tls1_md5_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform; \t\t\tmd_size = 16; \t\t\tsslv3_pad_length = 48; \t\t\tbreak; \t\tcase NID_sha1: \t\t\tSHA1_Init((SHA_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha1_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform; \t\t\tmd_size = 20; \t\t\tbreak; \t\tcase NID_sha224: \t\t\tSHA224_Init((SHA256_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 224/8; \t\t\tbreak; \t\tcase NID_sha256: \t\t\tSHA256_Init((SHA256_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha256_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform; \t\t\tmd_size = 32; \t\t\tbreak; \t\tcase NID_sha384: \t\t\tSHA384_Init((SHA512_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 384/8; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tcase NID_sha512: \t\t\tSHA512_Init((SHA512_CTX*)md_state); \t\t\tmd_final_raw = tls1_sha512_final_raw; \t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform; \t\t\tmd_size = 64; \t\t\tmd_block_size = 128; \t\t\tmd_length_size = 16; \t\t\tbreak; \t\tdefault: \t\t\t/* ssl3_cbc_record_digest_supported should have been \t\t\t * called first to check that the hash function is \t\t\t * supported. */ \t\t\tOPENSSL_assert(0); \t\t\tif (md_out_size) \t\t\t\t*md_out_size = -1; \t\t\treturn; \t\t} \tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES); \tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE); \tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE); \theader_length = 13; \tif (is_sslv3) \t\t{ \t\theader_length = \t\t\tmac_secret_length + \t\t\tsslv3_pad_length + \t\t\t8 /* sequence number */ + \t\t\t1 /* record type */ + \t\t\t2 /* record length */; \t\t} \t/* variance_blocks is the number of blocks of the hash that we have to \t * calculate in constant time because they could be altered by the \t * padding value. \t * \t * In SSLv3, the padding must be minimal so the end of the plaintext \t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that \t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash \t * termination (0x80 + 64-bit length) don't fit in the final block, we \t * say that the final two blocks can vary based on the padding. \t * \t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not \t * required to be minimal. Therefore we say that the final six blocks \t * can vary based on the padding. \t * \t * Later in the function, if the message is short and there obviously \t * cannot be this many blocks then variance_blocks can be reduced. */ \tvariance_blocks = is_sslv3 ? 2 : 6; \t/* From now on we're dealing with the MAC, which conceptually has 13 \t * bytes of `header' before the start of the data (TLS) or 71/75 bytes \t * (SSLv3) */ \tlen = data_plus_mac_plus_padding_size + header_length; \t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including \t* |header|, assuming that there's no padding. */ \tmax_mac_bytes = len - md_size - 1; \t/* num_blocks is the maximum number of hash blocks. */ \tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size; \t/* In order to calculate the MAC in constant time we have to handle \t * the final blocks specially because the padding value could cause the \t * end to appear somewhere in the final |variance_blocks| blocks and we \t * can't leak where. However, |num_starting_blocks| worth of data can \t * be hashed right away because no padding value can affect whether \t * they are plaintext. */ \tnum_starting_blocks = 0; \t/* k is the starting byte offset into the conceptual header||data where \t * we start processing. */ \tk = 0; \t/* mac_end_offset is the index just past the end of the data to be \t * MACed. */ \tmac_end_offset = data_plus_mac_size + header_length - md_size; \t/* c is the index of the 0x80 byte in the final hash block that \t * contains application data. */ \tc = mac_end_offset % md_block_size; \t/* index_a is the hash block number that contains the 0x80 terminating \t * value. */ \tindex_a = mac_end_offset / md_block_size; \t/* index_b is the hash block number that contains the 64-bit hash \t * length, in bits. */ \tindex_b = (mac_end_offset + md_length_size) / md_block_size; \t/* bits is the hash-length in bits. It includes the additional hash \t * block for the masked HMAC key, or whole of |header| in the case of \t * SSLv3. */ \t/* For SSLv3, if we're going to have any starting blocks then we need \t * at least two because the header is larger than a single block. */ \tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0)) \t\t{ \t\tnum_starting_blocks = num_blocks - variance_blocks; \t\tk = md_block_size*num_starting_blocks; \t\t} \tbits = 8*mac_end_offset; \tif (!is_sslv3) \t\t{ \t\t/* Compute the initial HMAC block. For SSLv3, the padding and \t\t * secret bytes are included in |header| because they take more \t\t * than a single block. */ \t\tbits += 8*md_block_size; \t\tmemset(hmac_pad, 0, md_block_size); \t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad)); \t\tmemcpy(hmac_pad, mac_secret, mac_secret_length); \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x36; \t\tmd_transform(md_state, hmac_pad); \t\t} \tj = 0; \tif (md_length_size == 16) \t\t{ \t\tmemset(length_bytes, 0, 8); \t\tj = 8; \t\t} \tfor (i = 0; i < 8; i++) \t\tlength_bytes[i+j] = bits >> (8*(7-i)); \tif (k > 0) \t\t{ \t\tif (is_sslv3) \t\t\t{ \t\t\t/* The SSLv3 header is larger than a single block. \t\t\t * overhang is the number of bytes beyond a single \t\t\t * block that the header consumes: either 7 bytes \t\t\t * (SHA1) or 11 bytes (MD5). */ \t\t\tunsigned overhang = header_length-md_block_size; \t\t\tmd_transform(md_state, header); \t\t\tmemcpy(first_block, header + md_block_size, overhang); \t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang); \t\t\tmd_transform(md_state, first_block); \t\t\tfor (i = 1; i < k/md_block_size - 1; i++) \t\t\t\tmd_transform(md_state, data + md_block_size*i - overhang); \t\t\t} \t\telse \t\t\t{ \t\t\t/* k is a multiple of md_block_size. */ \t\t\tmemcpy(first_block, header, 13); \t\t\tmemcpy(first_block+13, data, md_block_size-13); \t\t\tmd_transform(md_state, first_block); \t\t\tfor (i = 1; i < k/md_block_size; i++) \t\t\t\tmd_transform(md_state, data + md_block_size*i - 13); \t\t\t} \t\t} \tmemset(mac_out, 0, sizeof(mac_out)); \t/* We now process the final hash blocks. For each block, we construct \t * it in constant time. If the |i==index_a| then we'll include the 0x80 \t * bytes and zero pad etc. For each block we selectively copy it, in \t * constant time, to |mac_out|. */ \tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++) \t\t{ \t\tunsigned char block[MAX_HASH_BLOCK_SIZE]; \t\tunsigned char is_block_a = constant_time_eq_8(i, index_a); \t\tunsigned char is_block_b = constant_time_eq_8(i, index_b); \t\tfor (j = 0; j < md_block_size; j++) \t\t\t{ \t\t\tunsigned char b = 0, is_past_c, is_past_cp1; \t\t\tif (k < header_length) \t\t\t\tb = header[k]; \t\t\telse if (k < data_plus_mac_plus_padding_size + header_length) \t\t\t\tb = data[k-header_length]; \t\t\tk++; \t\t\tis_past_c = is_block_a & constant_time_ge(j, c); \t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1); \t\t\t/* If this is the block containing the end of the \t\t\t * application data, and we are at the offset for the \t\t\t * 0x80 value, then overwrite b with 0x80. */ \t\t\tb = (b&~is_past_c) | (0x80&is_past_c); \t\t\t/* If this the the block containing the end of the \t\t\t * application data and we're past the 0x80 value then \t\t\t * just write zero. */ \t\t\tb = b&~is_past_cp1; \t\t\t/* If this is index_b (the final block), but not \t\t\t * index_a (the end of the data), then the 64-bit \t\t\t * length didn't fit into index_a and we're having to \t\t\t * add an extra block of zeros. */ \t\t\tb &= ~is_block_b | is_block_a; \t\t\t/* The final bytes of one of the blocks contains the \t\t\t * length. */ \t\t\tif (j >= md_block_size - md_length_size) \t\t\t\t{ \t\t\t\t/* If this is index_b, write a length byte. */ \t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]); \t\t\t\t} \t\t\tblock[j] = b; \t\t\t} \t\tmd_transform(md_state, block); \t\tmd_final_raw(md_state, block); \t\t/* If this is index_b, copy the hash value to |mac_out|. */ \t\tfor (j = 0; j < md_size; j++) \t\t\tmac_out[j] |= block[j]&is_block_b; \t\t} \tEVP_MD_CTX_init(&md_ctx); \tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */); \tif (is_sslv3) \t\t{ \t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */ \t\tmemset(hmac_pad, 0x5c, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length); \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \telse \t\t{ \t\t/* Complete the HMAC in the standard manner. */ \t\tfor (i = 0; i < md_block_size; i++) \t\t\thmac_pad[i] ^= 0x6a; \t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size); \t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size); \t\t} \tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u); \tif (md_out_size) \t\t*md_out_size = md_out_size_u; \tEVP_MD_CTX_cleanup(&md_ctx); \t}++#ifndef OPENSSL_FIPS++/* Due to the need to use EVP in FIPS mode we can't reimplement digests but+ * we can ensure the number of blocks processed is equal for all cases+ * by digesting additional data.",
            "commit_date": "2013-01-29 14:44:36+00:00",
            "commit_hash": "c4e6fb15244e27f1e93df3f59fe37b59a784f5dc",
            "message": "Timing fix mitigation for FIPS mode.\nWe have to use EVP in FIPS mode so we can only partially mitigate\ntiming differences.\nMake an extra call to EVP_DigestSignUpdate to hash additonal blocks\nto cover any timing differences caused by removal of padding.\n(cherry picked from commit b908e88ec15aa0a74805e3f2236fc4f83f2789c2)"
        },
        {
            "author": {
                "email": "ben@links.org",
                "name": "Ben Laurie"
            },
            "changes": "diff --git a/ssl/s3_cbc.c b/ssl/s3_cbc.c--- /dev/null+++ b/ssl/s3_cbc.c@@ -0,0 +403,294 @@+ * padding too. ) */+void ssl3_cbc_digest_record(+\tconst EVP_MD_CTX *ctx,+\tunsigned char* md_out,+\tsize_t* md_out_size,+\tconst unsigned char header[13],+\tconst unsigned char *data,+\tsize_t data_plus_mac_size,+\tsize_t data_plus_mac_plus_padding_size,+\tconst unsigned char *mac_secret,+\tunsigned mac_secret_length,+\tchar is_sslv3)+\t{+\tunsigned char md_state[sizeof(SHA512_CTX)];+\tvoid (*md_final_raw)(void *ctx, unsigned char *md_out);+\tvoid (*md_transform)(void *ctx, const unsigned char *block);+\tunsigned md_size, md_block_size = 64;+\tunsigned sslv3_pad_length = 40, header_length, variance_blocks,+\t\t len, max_mac_bytes, num_blocks,+\t\t num_starting_blocks, k, mac_end_offset, c, index_a, index_b;+\tuint64_t bits;+\tunsigned char length_bytes[MAX_HASH_BIT_COUNT_BYTES];+\t/* hmac_pad is the masked HMAC key. */+\tunsigned char hmac_pad[MAX_HASH_BLOCK_SIZE];+\tunsigned char first_block[MAX_HASH_BLOCK_SIZE];+\tunsigned char mac_out[EVP_MAX_MD_SIZE];+\tunsigned i, j, md_out_size_u;+\tEVP_MD_CTX md_ctx;+\t/* mdLengthSize is the number of bytes in the length field that terminates+\t* the hash. */+\tunsigned md_length_size = 8;++\t/* This is a, hopefully redundant, check that allows us to forget about+\t * many possible overflows later in this function. */+\tOPENSSL_assert(data_plus_mac_plus_padding_size < 1024*1024);++\tswitch (ctx->digest->type)+\t\t{+\t\tcase NID_md5:+\t\t\tMD5_Init((MD5_CTX*)md_state);+\t\t\tmd_final_raw = tls1_md5_final_raw;+\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) MD5_Transform;+\t\t\tmd_size = 16;+\t\t\tsslv3_pad_length = 48;+\t\t\tbreak;+\t\tcase NID_sha1:+\t\t\tSHA1_Init((SHA_CTX*)md_state);+\t\t\tmd_final_raw = tls1_sha1_final_raw;+\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA1_Transform;+\t\t\tmd_size = 20;+\t\t\tbreak;+\t\tcase NID_sha224:+\t\t\tSHA224_Init((SHA256_CTX*)md_state);+\t\t\tmd_final_raw = tls1_sha256_final_raw;+\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;+\t\t\tmd_size = 224/8;+\t\t\tbreak;+\t\tcase NID_sha256:+\t\t\tSHA256_Init((SHA256_CTX*)md_state);+\t\t\tmd_final_raw = tls1_sha256_final_raw;+\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA256_Transform;+\t\t\tmd_size = 32;+\t\t\tbreak;+\t\tcase NID_sha384:+\t\t\tSHA384_Init((SHA512_CTX*)md_state);+\t\t\tmd_final_raw = tls1_sha512_final_raw;+\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;+\t\t\tmd_size = 384/8;+\t\t\tmd_block_size = 128;+\t\t\tmd_length_size = 16;+\t\t\tbreak;+\t\tcase NID_sha512:+\t\t\tSHA512_Init((SHA512_CTX*)md_state);+\t\t\tmd_final_raw = tls1_sha512_final_raw;+\t\t\tmd_transform = (void(*)(void *ctx, const unsigned char *block)) SHA512_Transform;+\t\t\tmd_size = 64;+\t\t\tmd_block_size = 128;+\t\t\tmd_length_size = 16;+\t\t\tbreak;+\t\tdefault:+\t\t\t/* ssl3_cbc_record_digest_supported should have been+\t\t\t * called first to check that the hash function is+\t\t\t * supported. */+\t\t\tOPENSSL_assert(0);+\t\t\tif (md_out_size)+\t\t\t\t*md_out_size = -1;+\t\t\treturn;+\t\t}++\tOPENSSL_assert(md_length_size <= MAX_HASH_BIT_COUNT_BYTES);+\tOPENSSL_assert(md_block_size <= MAX_HASH_BLOCK_SIZE);+\tOPENSSL_assert(md_size <= EVP_MAX_MD_SIZE);++\theader_length = 13;+\tif (is_sslv3)+\t\t{+\t\theader_length =+\t\t\tmac_secret_length ++\t\t\tsslv3_pad_length ++\t\t\t8 /* sequence number */ ++\t\t\t1 /* record type */ ++\t\t\t2 /* record length */;+\t\t}++\t/* variance_blocks is the number of blocks of the hash that we have to+\t * calculate in constant time because they could be altered by the+\t * padding value.+\t *+\t * In SSLv3, the padding must be minimal so the end of the plaintext+\t * varies by, at most, 15+20 = 35 bytes. (We conservatively assume that+\t * the MAC size varies from 0..20 bytes.) In case the 9 bytes of hash+\t * termination (0x80 + 64-bit length) don't fit in the final block, we+\t * say that the final two blocks can vary based on the padding.+\t *+\t * TLSv1 has MACs up to 48 bytes long (SHA-384) and the padding is not+\t * required to be minimal. Therefore we say that the final six blocks+\t * can vary based on the padding.+\t *+\t * Later in the function, if the message is short and there obviously+\t * cannot be this many blocks then variance_blocks can be reduced. */+\tvariance_blocks = is_sslv3 ? 2 : 6;+\t/* From now on we're dealing with the MAC, which conceptually has 13+\t * bytes of `header' before the start of the data (TLS) or 71/75 bytes+\t * (SSLv3) */+\tlen = data_plus_mac_plus_padding_size + header_length;+\t/* max_mac_bytes contains the maximum bytes of bytes in the MAC, including+\t* |header|, assuming that there's no padding. */+\tmax_mac_bytes = len - md_size - 1;+\t/* num_blocks is the maximum number of hash blocks. */+\tnum_blocks = (max_mac_bytes + 1 + md_length_size + md_block_size - 1) / md_block_size;+\t/* In order to calculate the MAC in constant time we have to handle+\t * the final blocks specially because the padding value could cause the+\t * end to appear somewhere in the final |variance_blocks| blocks and we+\t * can't leak where. However, |num_starting_blocks| worth of data can+\t * be hashed right away because no padding value can affect whether+\t * they are plaintext. */+\tnum_starting_blocks = 0;+\t/* k is the starting byte offset into the conceptual header||data where+\t * we start processing. */+\tk = 0;+\t/* mac_end_offset is the index just past the end of the data to be+\t * MACed. */+\tmac_end_offset = data_plus_mac_size + header_length - md_size;+\t/* c is the index of the 0x80 byte in the final hash block that+\t * contains application data. */+\tc = mac_end_offset % md_block_size;+\t/* index_a is the hash block number that contains the 0x80 terminating+\t * value. */+\tindex_a = mac_end_offset / md_block_size;+\t/* index_b is the hash block number that contains the 64-bit hash+\t * length, in bits. */+\tindex_b = (mac_end_offset + md_length_size) / md_block_size;+\t/* bits is the hash-length in bits. It includes the additional hash+\t * block for the masked HMAC key, or whole of |header| in the case of+\t * SSLv3. */++\t/* For SSLv3, if we're going to have any starting blocks then we need+\t * at least two because the header is larger than a single block. */+\tif (num_blocks > variance_blocks + (is_sslv3 ? 1 : 0))+\t\t{+\t\tnum_starting_blocks = num_blocks - variance_blocks;+\t\tk = md_block_size*num_starting_blocks;+\t\t}++\tbits = 8*mac_end_offset;+\tif (!is_sslv3)+\t\t{+\t\t/* Compute the initial HMAC block. For SSLv3, the padding and+\t\t * secret bytes are included in |header| because they take more+\t\t * than a single block. */+\t\tbits += 8*md_block_size;+\t\tmemset(hmac_pad, 0, md_block_size);+\t\tOPENSSL_assert(mac_secret_length <= sizeof(hmac_pad));+\t\tmemcpy(hmac_pad, mac_secret, mac_secret_length);+\t\tfor (i = 0; i < md_block_size; i++)+\t\t\thmac_pad[i] ^= 0x36;++\t\tmd_transform(md_state, hmac_pad);+\t\t}++\tj = 0;+\tif (md_length_size == 16)+\t\t{+\t\tmemset(length_bytes, 0, 8);+\t\tj = 8;+\t\t}+\tfor (i = 0; i < 8; i++)+\t\tlength_bytes[i+j] = bits >> (8*(7-i));++\tif (k > 0)+\t\t{+\t\tif (is_sslv3)+\t\t\t{+\t\t\t/* The SSLv3 header is larger than a single block.+\t\t\t * overhang is the number of bytes beyond a single+\t\t\t * block that the header consumes: either 7 bytes+\t\t\t * (SHA1) or 11 bytes (MD5). */+\t\t\tunsigned overhang = header_length-md_block_size;+\t\t\tmd_transform(md_state, header);+\t\t\tmemcpy(first_block, header + md_block_size, overhang);+\t\t\tmemcpy(first_block + overhang, data, md_block_size-overhang);+\t\t\tmd_transform(md_state, first_block);+\t\t\tfor (i = 1; i < k/md_block_size - 1; i++)+\t\t\t\tmd_transform(md_state, data + md_block_size*i - overhang);+\t\t\t}+\t\telse+\t\t\t{+\t\t\t/* k is a multiple of md_block_size. */+\t\t\tmemcpy(first_block, header, 13);+\t\t\tmemcpy(first_block+13, data, md_block_size-13);+\t\t\tmd_transform(md_state, first_block);+\t\t\tfor (i = 1; i < k/md_block_size; i++)+\t\t\t\tmd_transform(md_state, data + md_block_size*i - 13);+\t\t\t}+\t\t}++\tmemset(mac_out, 0, sizeof(mac_out));++\t/* We now process the final hash blocks. For each block, we construct+\t * it in constant time. If the |i==index_a| then we'll include the 0x80+\t * bytes and zero pad etc. For each block we selectively copy it, in+\t * constant time, to |mac_out|. */+\tfor (i = num_starting_blocks; i <= num_starting_blocks+variance_blocks; i++)+\t\t{+\t\tunsigned char block[MAX_HASH_BLOCK_SIZE];+\t\tunsigned char is_block_a = constant_time_eq_8(i, index_a);+\t\tunsigned char is_block_b = constant_time_eq_8(i, index_b);+\t\tfor (j = 0; j < md_block_size; j++)+\t\t\t{+\t\t\tunsigned char b = 0, is_past_c, is_past_cp1;+\t\t\tif (k < header_length)+\t\t\t\tb = header[k];+\t\t\telse if (k < data_plus_mac_plus_padding_size + header_length)+\t\t\t\tb = data[k-header_length];+\t\t\tk++;++\t\t\tis_past_c = is_block_a & constant_time_ge(j, c);+\t\t\tis_past_cp1 = is_block_a & constant_time_ge(j, c+1);+\t\t\t/* If this is the block containing the end of the+\t\t\t * application data, and we are at the offset for the+\t\t\t * 0x80 value, then overwrite b with 0x80. */+\t\t\tb = (b&~is_past_c) | (0x80&is_past_c);+\t\t\t/* If this the the block containing the end of the+\t\t\t * application data and we're past the 0x80 value then+\t\t\t * just write zero. */+\t\t\tb = b&~is_past_cp1;+\t\t\t/* If this is index_b (the final block), but not+\t\t\t * index_a (the end of the data), then the 64-bit+\t\t\t * length didn't fit into index_a and we're having to+\t\t\t * add an extra block of zeros. */+\t\t\tb &= ~is_block_b | is_block_a;++\t\t\t/* The final bytes of one of the blocks contains the+\t\t\t * length. */+\t\t\tif (j >= md_block_size - md_length_size)+\t\t\t\t{+\t\t\t\t/* If this is index_b, write a length byte. */+\t\t\t\tb = (b&~is_block_b) | (is_block_b&length_bytes[j-(md_block_size-md_length_size)]);+\t\t\t\t}+\t\t\tblock[j] = b;+\t\t\t}++\t\tmd_transform(md_state, block);+\t\tmd_final_raw(md_state, block);+\t\t/* If this is index_b, copy the hash value to |mac_out|. */+\t\tfor (j = 0; j < md_size; j++)+\t\t\tmac_out[j] |= block[j]&is_block_b;+\t\t}++\tEVP_MD_CTX_init(&md_ctx);+\tEVP_DigestInit_ex(&md_ctx, ctx->digest, NULL /* engine */);+\tif (is_sslv3)+\t\t{+\t\t/* We repurpose |hmac_pad| to contain the SSLv3 pad2 block. */+\t\tmemset(hmac_pad, 0x5c, sslv3_pad_length);++\t\tEVP_DigestUpdate(&md_ctx, mac_secret, mac_secret_length);+\t\tEVP_DigestUpdate(&md_ctx, hmac_pad, sslv3_pad_length);+\t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size);+\t\t}+\telse+\t\t{+\t\t/* Complete the HMAC in the standard manner. */+\t\tfor (i = 0; i < md_block_size; i++)+\t\t\thmac_pad[i] ^= 0x6a;++\t\tEVP_DigestUpdate(&md_ctx, hmac_pad, md_block_size);+\t\tEVP_DigestUpdate(&md_ctx, mac_out, md_size);+\t\t}+\tEVP_DigestFinal(&md_ctx, md_out, &md_out_size_u);+\tif (md_out_size)+\t\t*md_out_size = md_out_size_u;+\tEVP_MD_CTX_cleanup(&md_ctx);+\t}",
            "commit_date": "2013-01-28 18:24:55+00:00",
            "commit_hash": "a693ead6dc75455f7f5bbbd631b3a0e7ee457965",
            "message": "Oops. Add missing file.\n(cherry picked from commit 014265eb02e26f35c8db58e2ccbf100b0b2f0072)"
        }
    ],
    "git log -L495,580:test/evp_pkey_provided_test.c": [
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "slontis"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -456,86 +456,86 @@ #ifndef OPENSSL_NO_DH static int test_fromdata_dh_named_group(void) {-    if (!TEST_true(EVP_PKEY_fromdata_init(ctx))-        || !TEST_true(EVP_PKEY_fromdata(ctx, &pk, EVP_PKEY_KEYPAIR,-                                        fromdata_params)))+    if (!TEST_int_eq(EVP_PKEY_fromdata_init(ctx), 1)+        || !TEST_int_eq(EVP_PKEY_fromdata(ctx, &pk, EVP_PKEY_KEYPAIR,+                                          fromdata_params), 1))",
            "commit_date": "2021-10-11 12:00:12+10:00",
            "commit_hash": "884400d78992d1da1573a3677876b06421b797eb",
            "message": "Fix tests to check for negative results when calling EVP_PKEY_fromdata_init\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16801)\nint ret = 0;\nint gindex = 0, pcounter = 0, hindex = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nEVP_PKEY *pk = NULL, *copy_pk = NULL, *dup_pk = NULL;\nsize_t len;\nBIGNUM *pub = NULL, *priv = NULL;\nBIGNUM *pub_out = NULL, *priv_out = NULL;\nBIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;\nOSSL_PARAM *fromdata_params = NULL;\nOSSL_PARAM_BLD *bld = NULL;\nchar name_out[80];\nunsigned char seed_out[32];\n/*\n* DH key data was generated using the following:\n* openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048\n*                 -pkeyopt priv_len:224 -text\n*/\nstatic const unsigned char priv_data[] = {\n0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,\n0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,\n0x87, 0xe8, 0xa9, 0x7b,\n};\nstatic const unsigned char pub_data[] = {\n0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,\n0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,\n0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,\n0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,\n0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,\n0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,\n0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,\n0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,\n0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,\n0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,\n0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,\n0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,\n0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,\n0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,\n0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,\n0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,\n0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,\n0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,\n0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,\n0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,\n0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,\n0xcf, 0x33, 0x42, 0x83, 0x42\n};\nstatic const char group_name[] = \"ffdhe2048\";\nstatic const long priv_len = 224;\nif (!TEST_ptr(bld = OSSL_PARAM_BLD_new())\n|| !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))\n|| !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))\n|| !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,\nOSSL_PKEY_PARAM_GROUP_NAME,\ngroup_name, 0))\n|| !TEST_true(OSSL_PARAM_BLD_push_long(bld, OSSL_PKEY_PARAM_DH_PRIV_LEN,\npriv_len))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))\n|| !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))\ngoto err;\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\ngoto err;\n/*\n* A few extra checks of EVP_PKEY_get_utf8_string_param() to see that\n* it behaves as expected with regards to string length and terminating\n* NUL byte.\n*/\nif (!TEST_true(EVP_PKEY_get_utf8_string_param(pk,\nOSSL_PKEY_PARAM_GROUP_NAME,\nNULL, sizeof(name_out),\n&len))\n|| !TEST_size_t_eq(len, sizeof(group_name) - 1)\n/* Just enough space to hold the group name and a terminating NUL */\n|| !TEST_true(EVP_PKEY_get_utf8_string_param(pk,"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -455,74 +455,86 @@ #ifndef OPENSSL_NO_DH static int test_fromdata_dh_named_group(void) {+    /*+     * A few extra checks of EVP_PKEY_get_utf8_string_param() to see that+     * it behaves as expected with regards to string length and terminating+     * NUL byte.+     */+    if (!TEST_true(EVP_PKEY_get_utf8_string_param(pk,+                                                  OSSL_PKEY_PARAM_GROUP_NAME,+                                                  NULL, sizeof(name_out),+                                                  &len))+        || !TEST_size_t_eq(len, sizeof(group_name) - 1)+        /* Just enough space to hold the group name and a terminating NUL */+        || !TEST_true(EVP_PKEY_get_utf8_string_param(pk,",
            "commit_date": "2021-08-17 14:32:35+02:00",
            "commit_hash": "d68820d95634322108316f3051a1746ead88adaf",
            "message": "Add tests for EVP_PKEY_get_utf8_string_param(), both positive and negative\nReviewed-by: Viktor Dukhovni <viktor@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/16334)\nint ret = 0;\nint gindex = 0, pcounter = 0, hindex = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nEVP_PKEY *pk = NULL, *copy_pk = NULL, *dup_pk = NULL;\nsize_t len;\nBIGNUM *pub = NULL, *priv = NULL;\nBIGNUM *pub_out = NULL, *priv_out = NULL;\nBIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;\nOSSL_PARAM *fromdata_params = NULL;\nOSSL_PARAM_BLD *bld = NULL;\nchar name_out[80];\nunsigned char seed_out[32];\n/*\n* DH key data was generated using the following:\n* openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048\n*                 -pkeyopt priv_len:224 -text\n*/\nstatic const unsigned char priv_data[] = {\n0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,\n0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,\n0x87, 0xe8, 0xa9, 0x7b,\n};\nstatic const unsigned char pub_data[] = {\n0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,\n0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,\n0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,\n0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,\n0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,\n0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,\n0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,\n0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,\n0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,\n0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,\n0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,\n0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,\n0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,\n0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,\n0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,\n0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,\n0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,\n0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,\n0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,\n0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,\n0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,\n0xcf, 0x33, 0x42, 0x83, 0x42\n};\nstatic const char group_name[] = \"ffdhe2048\";\nstatic const long priv_len = 224;\nif (!TEST_ptr(bld = OSSL_PARAM_BLD_new())\n|| !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))\n|| !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))\n|| !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,\nOSSL_PKEY_PARAM_GROUP_NAME,\ngroup_name, 0))\n|| !TEST_true(OSSL_PARAM_BLD_push_long(bld, OSSL_PKEY_PARAM_DH_PRIV_LEN,\npriv_len))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))\n|| !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))\ngoto err;\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, EVP_PKEY_KEYPAIR,\nfromdata_params)))\ngoto err;"
        },
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -439,78 +455,74 @@ #ifndef OPENSSL_NO_DH static int test_fromdata_dh_named_group(void) {-    EVP_PKEY *pk = NULL, *copy_pk = NULL;+    EVP_PKEY *pk = NULL, *copy_pk = NULL, *dup_pk = NULL;-                                        fromdata_params))-        || !TEST_int_eq(EVP_PKEY_bits(pk), 2048)-        || !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)-        || !TEST_int_eq(EVP_PKEY_size(pk), 256)-        || !TEST_false(EVP_PKEY_missing_parameters(pk)))+                                        fromdata_params)))",
            "commit_date": "2021-03-19 18:45:43+01:00",
            "commit_hash": "2145ba5e8383184d7f212500ec2f759bdf08503a",
            "message": "Implement EVP_PKEY_dup() function\nFixes #14501\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14624)\nint ret = 0;\nint gindex = 0, pcounter = 0, hindex = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nsize_t len;\nBIGNUM *pub = NULL, *priv = NULL;\nBIGNUM *pub_out = NULL, *priv_out = NULL;\nBIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;\nOSSL_PARAM *fromdata_params = NULL;\nOSSL_PARAM_BLD *bld = NULL;\nchar name_out[80];\nunsigned char seed_out[32];\n/*\n* DH key data was generated using the following:\n* openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048\n*                 -pkeyopt priv_len:224 -text\n*/\nstatic const unsigned char priv_data[] = {\n0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,\n0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,\n0x87, 0xe8, 0xa9, 0x7b,\n};\nstatic const unsigned char pub_data[] = {\n0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,\n0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,\n0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,\n0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,\n0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,\n0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,\n0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,\n0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,\n0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,\n0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,\n0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,\n0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,\n0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,\n0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,\n0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,\n0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,\n0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,\n0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,\n0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,\n0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,\n0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,\n0xcf, 0x33, 0x42, 0x83, 0x42\n};\nstatic const char group_name[] = \"ffdhe2048\";\nstatic const long priv_len = 224;\nif (!TEST_ptr(bld = OSSL_PARAM_BLD_new())\n|| !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))\n|| !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))\n|| !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,\nOSSL_PKEY_PARAM_GROUP_NAME,\ngroup_name, 0))\n|| !TEST_true(OSSL_PARAM_BLD_push_long(bld, OSSL_PKEY_PARAM_DH_PRIV_LEN,\npriv_len))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))\n|| !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))\ngoto err;\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, EVP_PKEY_KEYPAIR,\ngoto err;"
        },
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -438,77 +439,78 @@ #ifndef OPENSSL_NO_DH static int test_fromdata_dh_named_group(void) {-        || !TEST_int_eq(EVP_PKEY_size(pk), 256))+        || !TEST_int_eq(EVP_PKEY_size(pk), 256)+        || !TEST_false(EVP_PKEY_missing_parameters(pk)))",
            "commit_date": "2021-03-11 13:31:13+01:00",
            "commit_hash": "9a4854405869158bd87ee90345b933815882a24d",
            "message": "Make EVP_PKEY_missing_parameters work properly on provided RSA keys\nThis requires changing semantics of the keymgmt_has()\nfunction a little in the sense that it now returns 1\nif the selection has no meaning for the key type. It\nwas already doing so for ECX keys for example.\nThe keymgmt_validate function semantics is changed\nsimilarly to allow passing validation on the same\nselection that the key returns 1 for.\nFixes #14509\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14511)\nint ret = 0;\nint gindex = 0, pcounter = 0, hindex = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nEVP_PKEY *pk = NULL, *copy_pk = NULL;\nsize_t len;\nBIGNUM *pub = NULL, *priv = NULL;\nBIGNUM *pub_out = NULL, *priv_out = NULL;\nBIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;\nOSSL_PARAM *fromdata_params = NULL;\nOSSL_PARAM_BLD *bld = NULL;\nchar name_out[80];\nunsigned char seed_out[32];\n/*\n* DH key data was generated using the following:\n* openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048\n*                 -pkeyopt priv_len:224 -text\n*/\nstatic const unsigned char priv_data[] = {\n0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,\n0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,\n0x87, 0xe8, 0xa9, 0x7b,\n};\nstatic const unsigned char pub_data[] = {\n0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,\n0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,\n0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,\n0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,\n0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,\n0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,\n0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,\n0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,\n0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,\n0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,\n0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,\n0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,\n0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,\n0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,\n0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,\n0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,\n0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,\n0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,\n0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,\n0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,\n0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,\n0xcf, 0x33, 0x42, 0x83, 0x42\n};\nstatic const char group_name[] = \"ffdhe2048\";\nstatic const long priv_len = 224;\nif (!TEST_ptr(bld = OSSL_PARAM_BLD_new())\n|| !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))\n|| !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))\n|| !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,\nOSSL_PKEY_PARAM_GROUP_NAME,\ngroup_name, 0))\n|| !TEST_true(OSSL_PARAM_BLD_push_long(bld, OSSL_PKEY_PARAM_DH_PRIV_LEN,\npriv_len))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))\n|| !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))\ngoto err;\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, EVP_PKEY_KEYPAIR,\nfromdata_params))\n|| !TEST_int_eq(EVP_PKEY_bits(pk), 2048)\n|| !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)\ngoto err;"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -435,76 +437,77 @@ #ifndef OPENSSL_NO_DH static int test_fromdata_dh_named_group(void) {-    if (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))-        || !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))+    if (!TEST_true(EVP_PKEY_fromdata_init(ctx))+        || !TEST_true(EVP_PKEY_fromdata(ctx, &pk, EVP_PKEY_KEYPAIR,+                                        fromdata_params))",
            "commit_date": "2021-02-05 13:55:50+10:00",
            "commit_hash": "2db985b7b1e20ac670d196981aa7e8f31881d2eb",
            "message": "Simplify the EVP_PKEY_XXX_fromdata_XX methods.\nThe existing names such as EVP_PKEY_param_fromdata_settable were a bit\nconfusing since the 'param' referred to key params not OSSL_PARAM. To simplify\nthe interface a 'selection' parameter will be passed instead. The\nchanges are:\n(1) EVP_PKEY_fromdata_init() replaces both EVP_PKEY_key_fromdata_init() and EVP_PKEY_param_fromdata_init().\n(2) EVP_PKEY_fromdata() has an additional selection parameter.\n(3) EVP_PKEY_fromdata_settable() replaces EVP_PKEY_key_fromdata_settable() and EVP_PKEY_param_fromdata_settable().\nEVP_PKEY_fromdata_settable() also uses a selection parameter.\nFixes #12989\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14076)\nint ret = 0;\nint gindex = 0, pcounter = 0, hindex = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nEVP_PKEY *pk = NULL, *copy_pk = NULL;\nsize_t len;\nBIGNUM *pub = NULL, *priv = NULL;\nBIGNUM *pub_out = NULL, *priv_out = NULL;\nBIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;\nOSSL_PARAM *fromdata_params = NULL;\nOSSL_PARAM_BLD *bld = NULL;\nchar name_out[80];\nunsigned char seed_out[32];\n/*\n* DH key data was generated using the following:\n* openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048\n*                 -pkeyopt priv_len:224 -text\n*/\nstatic const unsigned char priv_data[] = {\n0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,\n0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,\n0x87, 0xe8, 0xa9, 0x7b,\n};\nstatic const unsigned char pub_data[] = {\n0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,\n0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,\n0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,\n0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,\n0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,\n0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,\n0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,\n0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,\n0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,\n0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,\n0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,\n0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,\n0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,\n0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,\n0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,\n0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,\n0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,\n0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,\n0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,\n0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,\n0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,\n0xcf, 0x33, 0x42, 0x83, 0x42\n};\nstatic const char group_name[] = \"ffdhe2048\";\nstatic const long priv_len = 224;\nif (!TEST_ptr(bld = OSSL_PARAM_BLD_new())\n|| !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))\n|| !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))\n|| !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,\nOSSL_PKEY_PARAM_GROUP_NAME,\ngroup_name, 0))\n|| !TEST_true(OSSL_PARAM_BLD_push_long(bld, OSSL_PKEY_PARAM_DH_PRIV_LEN,\npriv_len))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))\n|| !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))\ngoto err;\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\n|| !TEST_int_eq(EVP_PKEY_bits(pk), 2048)\n|| !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)\n|| !TEST_int_eq(EVP_PKEY_size(pk), 256))\ngoto err;"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -409,73 +409,76 @@ #ifndef OPENSSL_NO_DH static int test_fromdata_dh_named_group(void) {+    static const long priv_len = 224;+        || !TEST_true(OSSL_PARAM_BLD_push_long(bld, OSSL_PKEY_PARAM_DH_PRIV_LEN,+                                               priv_len))",
            "commit_date": "2020-10-15 08:30:49+02:00",
            "commit_hash": "ea7277fd2e27afa3a173ea30d567f45d7bb3d30d",
            "message": "TEST: fix the DH tests to reproduce the priv_len settings\nSome DH tests are done against files generated with '-pkeyopt priv_len:224'\nThis parameter must of course be reproduced when creating the key with\nEVP_PKEY_fromdata(), or there will be a default that's guaranteed to\ndiffer from the key parameters on file.\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13166)\nint ret = 0;\nint gindex = 0, pcounter = 0, hindex = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nEVP_PKEY *pk = NULL, *copy_pk = NULL;\nsize_t len;\nBIGNUM *pub = NULL, *priv = NULL;\nBIGNUM *pub_out = NULL, *priv_out = NULL;\nBIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;\nOSSL_PARAM *fromdata_params = NULL;\nOSSL_PARAM_BLD *bld = NULL;\nchar name_out[80];\nunsigned char seed_out[32];\n/*\n* DH key data was generated using the following:\n* openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048\n*                 -pkeyopt priv_len:224 -text\n*/\nstatic const unsigned char priv_data[] = {\n0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,\n0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,\n0x87, 0xe8, 0xa9, 0x7b,\n};\nstatic const unsigned char pub_data[] = {\n0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,\n0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,\n0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,\n0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,\n0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,\n0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,\n0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,\n0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,\n0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,\n0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,\n0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,\n0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,\n0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,\n0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,\n0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,\n0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,\n0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,\n0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,\n0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,\n0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,\n0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,\n0xcf, 0x33, 0x42, 0x83, 0x42\n};\nstatic const char group_name[] = \"ffdhe2048\";\nif (!TEST_ptr(bld = OSSL_PARAM_BLD_new())\n|| !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))\n|| !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))\n|| !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,\nOSSL_PKEY_PARAM_GROUP_NAME,\ngroup_name, 0))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))\n|| !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))\ngoto err;\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))\n|| !TEST_int_eq(EVP_PKEY_bits(pk), 2048)\n|| !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)\n|| !TEST_int_eq(EVP_PKEY_size(pk), 256))\ngoto err;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -394,73 +394,73 @@ #ifndef OPENSSL_NO_DH static int test_fromdata_dh_named_group(void) {-                                                      OSSL_PKEY_PARAM_DH_GROUP,+                                                      OSSL_PKEY_PARAM_GROUP_NAME,",
            "commit_date": "2020-05-20 14:46:22+01:00",
            "commit_hash": "023b188ca553aa4318d8e7021e3abbbb98833410",
            "message": "Make EVP_PKEY_CTX_[get|set]_group_name work for DH too\nThe previous commit added the EVP_PKEY_CTX_[get|set]_group_name\nfunctions to work with EC groups. We now extend that to also work for\nDH.\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/11914)\nint ret = 0;\nint gindex = 0, pcounter = 0, hindex = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nEVP_PKEY *pk = NULL, *copy_pk = NULL;\nsize_t len;\nBIGNUM *pub = NULL, *priv = NULL;\nBIGNUM *pub_out = NULL, *priv_out = NULL;\nBIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;\nOSSL_PARAM *fromdata_params = NULL;\nOSSL_PARAM_BLD *bld = NULL;\nchar name_out[80];\nunsigned char seed_out[32];\n/*\n* DH key data was generated using the following:\n* openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048\n*                 -pkeyopt priv_len:224 -text\n*/\nstatic const unsigned char priv_data[] = {\n0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,\n0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,\n0x87, 0xe8, 0xa9, 0x7b,\n};\nstatic const unsigned char pub_data[] = {\n0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,\n0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,\n0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,\n0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,\n0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,\n0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,\n0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,\n0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,\n0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,\n0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,\n0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,\n0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,\n0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,\n0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,\n0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,\n0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,\n0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,\n0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,\n0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,\n0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,\n0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,\n0xcf, 0x33, 0x42, 0x83, 0x42\n};\nstatic const char group_name[] = \"ffdhe2048\";\nif (!TEST_ptr(bld = OSSL_PARAM_BLD_new())\n|| !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))\n|| !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))\n|| !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,\ngroup_name, 0))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))\n|| !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))\ngoto err;\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))\n|| !TEST_int_eq(EVP_PKEY_bits(pk), 2048)\n|| !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)\n|| !TEST_int_eq(EVP_PKEY_size(pk), 256))\ngoto err;"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -394,73 +394,73 @@ #ifndef OPENSSL_NO_DH static int test_fromdata_dh_named_group(void) {-                                                      OSSL_PKEY_PARAM_FFC_GROUP,+                                                      OSSL_PKEY_PARAM_DH_GROUP,",
            "commit_date": "2020-05-26 13:53:07+10:00",
            "commit_hash": "b8086652650c0782bc8d63b620663e04a3c6a3a7",
            "message": "Update core_names.h fields and document most fields.\nRenamed some values in core_names i.e Some DH specific names were changed to use DH instead of FFC.\nAdded some strings values related to RSA keys.\nMoved set_params related docs out of EVP_PKEY_CTX_ctrl.pod into its own file.\nUpdated Keyexchange and signature code and docs.\nMoved some common DSA/DH docs into a shared EVP_PKEY-FFC.pod.\nMoved Ed25519.pod into EVP_SIGNATURE-ED25519.pod and reworked it.\nAdded some usage examples. As a result of the usage examples the following change was also made:\nec allows OSSL_PKEY_PARAM_USE_COFACTOR_ECDH as a settable gen parameter.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/11610)\nint ret = 0;\nint gindex = 0, pcounter = 0, hindex = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nEVP_PKEY *pk = NULL, *copy_pk = NULL;\nsize_t len;\nBIGNUM *pub = NULL, *priv = NULL;\nBIGNUM *pub_out = NULL, *priv_out = NULL;\nBIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;\nOSSL_PARAM *fromdata_params = NULL;\nOSSL_PARAM_BLD *bld = NULL;\nchar name_out[80];\nunsigned char seed_out[32];\n/*\n* DH key data was generated using the following:\n* openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048\n*                 -pkeyopt priv_len:224 -text\n*/\nstatic const unsigned char priv_data[] = {\n0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,\n0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,\n0x87, 0xe8, 0xa9, 0x7b,\n};\nstatic const unsigned char pub_data[] = {\n0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,\n0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,\n0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,\n0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,\n0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,\n0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,\n0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,\n0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,\n0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,\n0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,\n0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,\n0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,\n0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,\n0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,\n0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,\n0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,\n0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,\n0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,\n0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,\n0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,\n0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,\n0xcf, 0x33, 0x42, 0x83, 0x42\n};\nstatic const char group_name[] = \"ffdhe2048\";\nif (!TEST_ptr(bld = OSSL_PARAM_BLD_new())\n|| !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))\n|| !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))\n|| !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,\ngroup_name, 0))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))\n|| !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))\ngoto err;\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))\n|| !TEST_int_eq(EVP_PKEY_bits(pk), 2048)\n|| !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)\n|| !TEST_int_eq(EVP_PKEY_size(pk), 256))\ngoto err;"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -393,72 +393,73 @@ #ifndef OPENSSL_NO_DH static int test_fromdata_dh_named_group(void) {-     * openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048 -text+     * openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048+     *                 -pkeyopt priv_len:224 -text",
            "commit_date": "2020-04-20 11:07:38+10:00",
            "commit_hash": "738ee1819e3bb94723701fb505ce2971afe47a9b",
            "message": "Fix DH_get_nid() so that it does not cache values.\nDH_set0_pqg() is now responsible for caching the nid, q and length.\nDH with or without named safe prime groups now default to using the maximum private key length (BN_num_bits(q) - 1)\nwhen generating a DH private key. The code is now shared between fips and non fips mode for DH key generation.\nThe OSSL_PKEY_PARAM_DH_PRIV_LEN parameter can be used during keygen to override the maximum private key length to be\nin the range (2 * strength ... bits(q) - 1). Where the strength depends on the length of p.\nAdded q = (p - 1) / 2 safe prime BIGNUMS so that the code is data driven (To simplify adding new names).\nThe BIGNUMS were code generated.\nFix error in documented return value for DH_get_nid\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/11562)\nint ret = 0;\nint gindex = 0, pcounter = 0, hindex = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nEVP_PKEY *pk = NULL, *copy_pk = NULL;\nsize_t len;\nBIGNUM *pub = NULL, *priv = NULL;\nBIGNUM *pub_out = NULL, *priv_out = NULL;\nBIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;\nOSSL_PARAM *fromdata_params = NULL;\nOSSL_PARAM_BLD *bld = NULL;\nchar name_out[80];\nunsigned char seed_out[32];\n/*\n* DH key data was generated using the following:\n*/\nstatic const unsigned char priv_data[] = {\n0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,\n0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,\n0x87, 0xe8, 0xa9, 0x7b,\n};\nstatic const unsigned char pub_data[] = {\n0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,\n0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,\n0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,\n0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,\n0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,\n0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,\n0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,\n0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,\n0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,\n0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,\n0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,\n0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,\n0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,\n0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,\n0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,\n0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,\n0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,\n0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,\n0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,\n0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,\n0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,\n0xcf, 0x33, 0x42, 0x83, 0x42\n};\nstatic const char group_name[] = \"ffdhe2048\";\nif (!TEST_ptr(bld = OSSL_PARAM_BLD_new())\n|| !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))\n|| !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))\n|| !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,\nOSSL_PKEY_PARAM_FFC_GROUP,\ngroup_name, 0))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))\n|| !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))\ngoto err;\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))\n|| !TEST_int_eq(EVP_PKEY_bits(pk), 2048)\n|| !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)\n|| !TEST_int_eq(EVP_PKEY_size(pk), 256))\ngoto err;"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -393,41 +393,72 @@ #ifndef OPENSSL_NO_DH-/* Array indexes used in test_fromdata_dh */-#define PRIV_KEY        0-#define PUB_KEY         1-#define FFC_P           2-#define FFC_G           3--static int test_fromdata_dh(void)+static int test_fromdata_dh_named_group(void) {+    int gindex = 0, pcounter = 0, hindex = 0;+    size_t len;+    BIGNUM *pub = NULL, *priv = NULL;+    BIGNUM *pub_out = NULL, *priv_out = NULL;+    BIGNUM *p = NULL, *q = NULL, *g = NULL, *j = NULL;+    OSSL_PARAM *fromdata_params = NULL;+    OSSL_PARAM_BLD *bld = NULL;+    char name_out[80];+    unsigned char seed_out[32];+-     * 32-bit DH key, extracted from this command,-     * executed with OpenSSL 1.0.2:-     *-     * openssl dhparam -out dhp.pem 32-     * openssl genpkey -paramfile dhp.pem | openssl pkey -text+     * DH key data was generated using the following:+     * openssl genpkey -algorithm DH -pkeyopt group:ffdhe2048 -text-    static unsigned long key_numbers[] = {-        0x666c2b06,              /* priv-key */-        0x6fa6de50,              /* pub-key */-        0x8bb45f53,              /* P */-        0x2,                     /* G */+    static const unsigned char priv_data[] = {+        0x88, 0x85, 0xe7, 0x9f, 0xee, 0x6d, 0xc5, 0x7c, 0x78, 0xaf, 0x63, 0x5d,+        0x38, 0x2a, 0xd0, 0xed, 0x56, 0x4b, 0x47, 0x21, 0x2b, 0xfa, 0x55, 0xfa,+        0x87, 0xe8, 0xa9, 0x7b,-    OSSL_PARAM fromdata_params[] = {-        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_PRIV_KEY, &key_numbers[PRIV_KEY]),-        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_PUB_KEY, &key_numbers[PUB_KEY]),-        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_P, &key_numbers[FFC_P]),-        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_G, &key_numbers[FFC_G]),-        OSSL_PARAM_END+    static const unsigned char pub_data[] = {+        0x00, 0xd6, 0x2d, 0x77, 0xe0, 0xd3, 0x7d, 0xf8, 0xeb, 0x98, 0x50, 0xa1,+        0x82, 0x22, 0x65, 0xd5, 0xd9, 0xfe, 0xc9, 0x3f, 0xbe, 0x16, 0x83, 0xbd,+        0x33, 0xe9, 0xc6, 0x93, 0xcf, 0x08, 0xaf, 0x83, 0xfa, 0x80, 0x8a, 0x6c,+        0x64, 0xdf, 0x70, 0x64, 0xd5, 0x0a, 0x7c, 0x5a, 0x72, 0xda, 0x66, 0xe6,+        0xf9, 0xf5, 0x31, 0x21, 0x92, 0xb0, 0x60, 0x1a, 0xb5, 0xd3, 0xf0, 0xa5,+        0xfa, 0x48, 0x95, 0x2e, 0x38, 0xd9, 0xc5, 0xe6, 0xda, 0xfb, 0x6c, 0x03,+        0x9d, 0x4b, 0x69, 0xb7, 0x95, 0xe4, 0x5c, 0xc0, 0x93, 0x4f, 0x48, 0xd9,+        0x7e, 0x06, 0x22, 0xb2, 0xde, 0xf3, 0x79, 0x24, 0xed, 0xe1, 0xd1, 0x4a,+        0x57, 0xf1, 0x40, 0x86, 0x70, 0x42, 0x25, 0xc5, 0x27, 0x68, 0xc9, 0xfa,+        0xe5, 0x8e, 0x62, 0x7e, 0xff, 0x49, 0x6c, 0x5b, 0xb5, 0xba, 0xf9, 0xef,+        0x9a, 0x1a, 0x10, 0xd4, 0x81, 0x53, 0xcf, 0x83, 0x04, 0x18, 0x1c, 0xe1,+        0xdb, 0xe1, 0x65, 0xa9, 0x7f, 0xe1, 0x33, 0xeb, 0xc3, 0x4f, 0xe3, 0xb7,+        0x22, 0xf7, 0x1c, 0x09, 0x4f, 0xed, 0xc6, 0x07, 0x8e, 0x78, 0x05, 0x8f,+        0x7c, 0x96, 0xd9, 0x12, 0xe0, 0x81, 0x74, 0x1a, 0xe9, 0x13, 0xc0, 0x20,+        0x82, 0x65, 0xbb, 0x42, 0x3b, 0xed, 0x08, 0x6a, 0x84, 0x4f, 0xea, 0x77,+        0x14, 0x32, 0xf9, 0xed, 0xc2, 0x12, 0xd6, 0xc5, 0xc6, 0xb3, 0xe5, 0xf2,+        0x6e, 0xf6, 0x16, 0x7f, 0x37, 0xde, 0xbc, 0x09, 0xc7, 0x06, 0x6b, 0x12,+        0xbc, 0xad, 0x2d, 0x49, 0x25, 0xd5, 0xdc, 0xf4, 0x18, 0x14, 0xd2, 0xf0,+        0xf1, 0x1d, 0x1f, 0x3a, 0xaa, 0x15, 0x55, 0xbb, 0x0d, 0x7f, 0xbe, 0x67,+        0xa1, 0xa7, 0xf0, 0xaa, 0xb3, 0xfb, 0x41, 0x82, 0x39, 0x49, 0x93, 0xbc,+        0xa8, 0xee, 0x72, 0x13, 0x45, 0x65, 0x15, 0x42, 0x17, 0xaa, 0xd8, 0xab,+        0xcf, 0x33, 0x42, 0x83, 0x42+    static const char group_name[] = \"ffdhe2048\";++    if (!TEST_ptr(bld = OSSL_PARAM_BLD_new())+        || !TEST_ptr(pub = BN_bin2bn(pub_data, sizeof(pub_data), NULL))+        || !TEST_ptr(priv = BN_bin2bn(priv_data, sizeof(priv_data), NULL))+        || !TEST_true(OSSL_PARAM_BLD_push_utf8_string(bld,+                                                      OSSL_PKEY_PARAM_FFC_GROUP,+                                                      group_name, 0))+        || !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PUB_KEY, pub))+        || !TEST_true(OSSL_PARAM_BLD_push_BN(bld, OSSL_PKEY_PARAM_PRIV_KEY, priv))+        || !TEST_ptr(fromdata_params = OSSL_PARAM_BLD_to_param(bld)))+        goto err;-        || !TEST_int_eq(EVP_PKEY_bits(pk), 32)-        || !TEST_int_eq(EVP_PKEY_security_bits(pk), 0) /* Missing Q */-        || !TEST_int_eq(EVP_PKEY_size(pk), 4))+        || !TEST_int_eq(EVP_PKEY_bits(pk), 2048)+        || !TEST_int_eq(EVP_PKEY_security_bits(pk), 112)+        || !TEST_int_eq(EVP_PKEY_size(pk), 256))+        goto err;+",
            "commit_date": "2020-04-16 01:14:00+10:00",
            "commit_hash": "7165593ce5a07a6860d4d408ad640ee707172936",
            "message": "Add DH keygen to providers\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/11332)\nint ret = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\nEVP_PKEY *pk = NULL, *copy_pk = NULL;\n/*\n*/\n};\n};\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -324,41 +330,41 @@ #ifndef OPENSSL_NO_DH /* Array indexes used in test_fromdata_dh */ #define PRIV_KEY        0 #define PUB_KEY         1 #define FFC_P           2 #define FFC_G           3 static int test_fromdata_dh(void) {-    EVP_PKEY *pk = NULL;+    EVP_PKEY *pk = NULL, *copy_pk = NULL;",
            "commit_date": "2020-03-21 06:26:41+01:00",
            "commit_hash": "ff7262b4f4dfade7d2d6e05dcd3727ecc2bc7a5c",
            "message": "test/evp_pkey_provided_test.c: Add test of EVP_PKEY_copy_parameters()\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/11375)\nint ret = 0;\nEVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;\n/*\n* 32-bit DH key, extracted from this command,\n* executed with OpenSSL 1.0.2:\n*\n* openssl dhparam -out dhp.pem 32\n* openssl genpkey -paramfile dhp.pem | openssl pkey -text\n*/\nstatic unsigned long key_numbers[] = {\n0x666c2b06,              /* priv-key */\n0x6fa6de50,              /* pub-key */\n0x8bb45f53,              /* P */\n0x2,                     /* G */\n};\nOSSL_PARAM fromdata_params[] = {\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_PRIV_KEY, &key_numbers[PRIV_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_PUB_KEY, &key_numbers[PUB_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_P, &key_numbers[FFC_P]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_G, &key_numbers[FFC_G]),\nOSSL_PARAM_END\n};\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))\n|| !TEST_int_eq(EVP_PKEY_bits(pk), 32)\n|| !TEST_int_eq(EVP_PKEY_security_bits(pk), 0) /* Missing Q */\n|| !TEST_int_eq(EVP_PKEY_size(pk), 4))"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -324,41 +324,41 @@ #ifndef OPENSSL_NO_DH /* Array indexes used in test_fromdata_dh */ #define PRIV_KEY        0 #define PUB_KEY         1 #define FFC_P           2 #define FFC_G           3 static int test_fromdata_dh(void) {-    EVP_PKEY_CTX *ctx = NULL;+    EVP_PKEY_CTX *ctx = NULL, *key_ctx = NULL;",
            "commit_date": "2020-01-21 15:45:40+10:00",
            "commit_hash": "a54ff473df579dffbf70eec637d54e48370b5bdc",
            "message": "Add DH key validation to default provider\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/10911)\nint ret = 0;\nEVP_PKEY *pk = NULL;\n/*\n* 32-bit DH key, extracted from this command,\n* executed with OpenSSL 1.0.2:\n*\n* openssl dhparam -out dhp.pem 32\n* openssl genpkey -paramfile dhp.pem | openssl pkey -text\n*/\nstatic unsigned long key_numbers[] = {\n0x666c2b06,              /* priv-key */\n0x6fa6de50,              /* pub-key */\n0x8bb45f53,              /* P */\n0x2,                     /* G */\n};\nOSSL_PARAM fromdata_params[] = {\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_PRIV_KEY, &key_numbers[PRIV_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_PUB_KEY, &key_numbers[PUB_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_P, &key_numbers[FFC_P]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_G, &key_numbers[FFC_G]),\nOSSL_PARAM_END\n};\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))\n|| !TEST_int_eq(EVP_PKEY_bits(pk), 32)\n|| !TEST_int_eq(EVP_PKEY_security_bits(pk), 0) /* Missing Q */\n|| !TEST_int_eq(EVP_PKEY_size(pk), 4))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -155,41 +155,41 @@ #ifndef OPENSSL_NO_DH /* Array indexes used in test_fromdata_dh */ #define PRIV_KEY        0 #define PUB_KEY         1 #define FFC_P           2 #define FFC_G           3 static int test_fromdata_dh(void) {-        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PRIV_KEY, &key_numbers[PRIV_KEY]),-        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PUB_KEY, &key_numbers[PUB_KEY]),+        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_PRIV_KEY, &key_numbers[PRIV_KEY]),+        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_PUB_KEY, &key_numbers[PUB_KEY]),",
            "commit_date": "2020-01-27 16:57:03+00:00",
            "commit_hash": "90d3cb57c6caafbe031e32a99051386b8c5a90c0",
            "message": "Implement Provider side Key Management for X25519 and X448\nReviewed-by: Patrick Steuer <patrick.steuer@de.ibm.com>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/10964)\nint ret = 0;\nEVP_PKEY_CTX *ctx = NULL;\nEVP_PKEY *pk = NULL;\n/*\n* 32-bit DH key, extracted from this command,\n* executed with OpenSSL 1.0.2:\n*\n* openssl dhparam -out dhp.pem 32\n* openssl genpkey -paramfile dhp.pem | openssl pkey -text\n*/\nstatic unsigned long key_numbers[] = {\n0x666c2b06,              /* priv-key */\n0x6fa6de50,              /* pub-key */\n0x8bb45f53,              /* P */\n0x2,                     /* G */\n};\nOSSL_PARAM fromdata_params[] = {\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_P, &key_numbers[FFC_P]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_G, &key_numbers[FFC_G]),\nOSSL_PARAM_END\n};\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))\n|| !TEST_int_eq(EVP_PKEY_bits(pk), 32)\n|| !TEST_int_eq(EVP_PKEY_security_bits(pk), 0) /* Missing Q */\n|| !TEST_int_eq(EVP_PKEY_size(pk), 4))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -142,38 +145,41 @@ #ifndef OPENSSL_NO_DH /* Array indexes used in test_fromdata_dh */ #define PRIV_KEY        0 #define PUB_KEY         1 #define FFC_P           2 #define FFC_G           3 static int test_fromdata_dh(void) {-        || !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params)))+        || !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params))+        || !TEST_int_eq(EVP_PKEY_bits(pk), 32)+        || !TEST_int_eq(EVP_PKEY_security_bits(pk), 0) /* Missing Q */+        || !TEST_int_eq(EVP_PKEY_size(pk), 4))",
            "commit_date": "2020-01-08 03:50:33+01:00",
            "commit_hash": "81a624f2c215eb9def0917184b026b2e2db2dd54",
            "message": "TEST: Adapt test/evp_pkey_provided_test.c to check the key size\nThis is for the case where we build keys from user data\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\n(Merged from https://github.com/openssl/openssl/pull/10778)\nint ret = 0;\nEVP_PKEY_CTX *ctx = NULL;\nEVP_PKEY *pk = NULL;\n/*\n* 32-bit DH key, extracted from this command,\n* executed with OpenSSL 1.0.2:\n*\n* openssl dhparam -out dhp.pem 32\n* openssl genpkey -paramfile dhp.pem | openssl pkey -text\n*/\nstatic unsigned long key_numbers[] = {\n0x666c2b06,              /* priv-key */\n0x6fa6de50,              /* pub-key */\n0x8bb45f53,              /* P */\n0x2,                     /* G */\n};\nOSSL_PARAM fromdata_params[] = {\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PRIV_KEY, &key_numbers[PRIV_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PUB_KEY, &key_numbers[PUB_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_P, &key_numbers[FFC_P]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_G, &key_numbers[FFC_G]),\nOSSL_PARAM_END\n};\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -142,38 +142,38 @@ #ifndef OPENSSL_NO_DH /* Array indexes used in test_fromdata_dh */ #define PRIV_KEY        0 #define PUB_KEY         1 #define FFC_P           2 #define FFC_G           3 static int test_fromdata_dh(void) {-    if (!TEST_ptr(ctx = EVP_PKEY_CTX_new_provided(NULL, \"DH\", NULL)))+    if (!TEST_ptr(ctx = EVP_PKEY_CTX_new_from_name(NULL, \"DH\", NULL)))",
            "commit_date": "2020-01-12 11:32:12+10:00",
            "commit_hash": "e683582bf37de45a9512aea7ff33b9a3ebdf07f4",
            "message": "Add dsa signature alg to fips provider\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/10615)\nint ret = 0;\nEVP_PKEY_CTX *ctx = NULL;\nEVP_PKEY *pk = NULL;\n/*\n* 32-bit DH key, extracted from this command,\n* executed with OpenSSL 1.0.2:\n*\n* openssl dhparam -out dhp.pem 32\n* openssl genpkey -paramfile dhp.pem | openssl pkey -text\n*/\nstatic unsigned long key_numbers[] = {\n0x666c2b06,              /* priv-key */\n0x6fa6de50,              /* pub-key */\n0x8bb45f53,              /* P */\n0x2,                     /* G */\n};\nOSSL_PARAM fromdata_params[] = {\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PRIV_KEY, &key_numbers[PRIV_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PUB_KEY, &key_numbers[PUB_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_P, &key_numbers[FFC_P]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_G, &key_numbers[FFC_G]),\nOSSL_PARAM_END\n};\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params)))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- a/test/evp_pkey_provided_test.c+++ b/test/evp_pkey_provided_test.c@@ -142,37 +142,38 @@+#ifndef OPENSSL_NO_DH /* Array indexes used in test_fromdata_dh */ #define PRIV_KEY        0 #define PUB_KEY         1 #define FFC_P           2 #define FFC_G           3 static int test_fromdata_dh(void) {",
            "commit_date": "2019-12-18 11:14:29+00:00",
            "commit_hash": "285c691304890364a6126e9302415490b35130e5",
            "message": "Fix no-dh\nThe new serializer code broke no-dh builds so we add some more guards to fix it.\nReviewed-by: Bernd Edlinger <bernd.edlinger@hotmail.de>\n(Merged from https://github.com/openssl/openssl/pull/10644)\nint ret = 0;\nEVP_PKEY_CTX *ctx = NULL;\nEVP_PKEY *pk = NULL;\n/*\n* 32-bit DH key, extracted from this command,\n* executed with OpenSSL 1.0.2:\n*\n* openssl dhparam -out dhp.pem 32\n* openssl genpkey -paramfile dhp.pem | openssl pkey -text\n*/\nstatic unsigned long key_numbers[] = {\n0x666c2b06,              /* priv-key */\n0x6fa6de50,              /* pub-key */\n0x8bb45f53,              /* P */\n0x2,                     /* G */\n};\nOSSL_PARAM fromdata_params[] = {\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PRIV_KEY, &key_numbers[PRIV_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PUB_KEY, &key_numbers[PUB_KEY]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_P, &key_numbers[FFC_P]),\nOSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_G, &key_numbers[FFC_G]),\nOSSL_PARAM_END\n};\nif (!TEST_ptr(ctx = EVP_PKEY_CTX_new_provided(NULL, \"DH\", NULL)))\ngoto err;\nif (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))\n|| !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params)))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/evp_pkey_provided_test.c b/test/evp_pkey_provided_test.c--- /dev/null+++ b/test/evp_pkey_provided_test.c@@ -0,0 +142,37 @@+/* Array indexes used in test_fromdata_dh */+#define PRIV_KEY        0+#define PUB_KEY         1+#define FFC_P           2+#define FFC_G           3++static int test_fromdata_dh(void)+{+    int ret = 0;+    EVP_PKEY_CTX *ctx = NULL;+    EVP_PKEY *pk = NULL;+    /*+     * 32-bit DH key, extracted from this command,+     * executed with OpenSSL 1.0.2:+     *+     * openssl dhparam -out dhp.pem 32+     * openssl genpkey -paramfile dhp.pem | openssl pkey -text+     */+    static unsigned long key_numbers[] = {+        0x666c2b06,              /* priv-key */+        0x6fa6de50,              /* pub-key */+        0x8bb45f53,              /* P */+        0x2,                     /* G */+    };+    OSSL_PARAM fromdata_params[] = {+        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PRIV_KEY, &key_numbers[PRIV_KEY]),+        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_DH_PUB_KEY, &key_numbers[PUB_KEY]),+        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_P, &key_numbers[FFC_P]),+        OSSL_PARAM_ulong(OSSL_PKEY_PARAM_FFC_G, &key_numbers[FFC_G]),+        OSSL_PARAM_END+    };++    if (!TEST_ptr(ctx = EVP_PKEY_CTX_new_provided(NULL, \"DH\", NULL)))+        goto err;++    if (!TEST_true(EVP_PKEY_key_fromdata_init(ctx))+        || !TEST_true(EVP_PKEY_fromdata(ctx, &pk, fromdata_params)))",
            "commit_date": "2019-11-18 02:30:50+01:00",
            "commit_hash": "6ae5543c5f8476f4cae9c00209ef062746bbfd3c",
            "message": "TEST: add tests of text and PEM printout of a provider made key\nThis renames test/evp_fromdata_test.c to test/evp_pkey_provided_test.c,\nto encourage additional testing of provider made keys.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/10394)"
        }
    ],
    "git log -L1311,1345:test/ectest.c": [
        {
            "author": {
                "email": "bbrumley@gmail.com",
                "name": "Billy Brumley"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1315,35 +1263,35 @@ static int nistp_single_test(int idx) {-        || !TEST_ptr(NISTP = EC_GROUP_new(test->meth()))+        || !TEST_ptr(NISTP = EC_GROUP_new_by_curve_name(test->nid))",
            "commit_date": "2020-05-27 13:30:04+03:00",
            "commit_hash": "23ccae80bd58adfe89e3e345414684eb82bdb531",
            "message": "Move EC_METHOD to internal-only\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/11928)\nconst struct nistp_test_params *test = nistp_tests_params + idx;\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *x = NULL, *y = NULL;\nBIGNUM *n = NULL, *m = NULL, *order = NULL, *yplusone = NULL;\nEC_GROUP *NISTP = NULL;\nEC_POINT *G = NULL, *P = NULL, *Q = NULL, *Q_CHECK = NULL;\nint r = 0;\nTEST_note(\"NIST curve P-%d (optimised implementation):\",\ntest->degree);\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_ptr(x = BN_new())\n|| !TEST_ptr(y = BN_new())\n|| !TEST_ptr(m = BN_new())\n|| !TEST_ptr(n = BN_new())\n|| !TEST_ptr(order = BN_new())\n|| !TEST_ptr(yplusone = BN_new())\n|| !TEST_true(BN_hex2bn(&p, test->p))\n|| !TEST_int_eq(1, BN_check_prime(p, ctx, NULL))\n|| !TEST_true(BN_hex2bn(&a, test->a))\n|| !TEST_true(BN_hex2bn(&b, test->b))\n|| !TEST_true(EC_GROUP_set_curve(NISTP, p, a, b, ctx))\n|| !TEST_ptr(G = EC_POINT_new(NISTP))\n|| !TEST_ptr(P = EC_POINT_new(NISTP))\n|| !TEST_ptr(Q = EC_POINT_new(NISTP))\n|| !TEST_ptr(Q_CHECK = EC_POINT_new(NISTP))\n|| !TEST_true(BN_hex2bn(&x, test->Qx))"
        },
        {
            "author": {
                "email": "kurt@roeckx.be",
                "name": "Kurt Roeckx"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1305,35 +1305,35 @@ static int nistp_single_test(int idx) {-        || !TEST_int_eq(1, BN_is_prime_ex(p, BN_prime_checks, ctx, NULL))+        || !TEST_int_eq(1, BN_check_prime(p, ctx, NULL))",
            "commit_date": "2019-10-06 17:21:16+02:00",
            "commit_hash": "42619397eb5db1a77d077250b0841b9c9f2b8984",
            "message": "Add BN_check_prime()\nAdd a new API to test for primes that can't be misused, deprecated the\nold APIs.\nSuggested by Jake Massimo and Kenneth Paterson\nReviewed-by: Paul Dale <paul.dale@oracle.com>\nGH: #9272\nconst struct nistp_test_params *test = nistp_tests_params + idx;\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *x = NULL, *y = NULL;\nBIGNUM *n = NULL, *m = NULL, *order = NULL, *yplusone = NULL;\nEC_GROUP *NISTP = NULL;\nEC_POINT *G = NULL, *P = NULL, *Q = NULL, *Q_CHECK = NULL;\nint r = 0;\nTEST_note(\"NIST curve P-%d (optimised implementation):\",\ntest->degree);\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_ptr(x = BN_new())\n|| !TEST_ptr(y = BN_new())\n|| !TEST_ptr(m = BN_new())\n|| !TEST_ptr(n = BN_new())\n|| !TEST_ptr(order = BN_new())\n|| !TEST_ptr(yplusone = BN_new())\n|| !TEST_ptr(NISTP = EC_GROUP_new(test->meth()))\n|| !TEST_true(BN_hex2bn(&p, test->p))\n|| !TEST_true(BN_hex2bn(&a, test->a))\n|| !TEST_true(BN_hex2bn(&b, test->b))\n|| !TEST_true(EC_GROUP_set_curve(NISTP, p, a, b, ctx))\n|| !TEST_ptr(G = EC_POINT_new(NISTP))\n|| !TEST_ptr(P = EC_POINT_new(NISTP))\n|| !TEST_ptr(Q = EC_POINT_new(NISTP))\n|| !TEST_ptr(Q_CHECK = EC_POINT_new(NISTP))\n|| !TEST_true(BN_hex2bn(&x, test->Qx))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1280,35 +1267,35 @@ static int nistp_single_test(int idx) {-        || !TEST_true(EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx))+        || !TEST_true(EC_GROUP_set_curve(NISTP, p, a, b, ctx))",
            "commit_date": "2018-07-30 16:40:18+01:00",
            "commit_hash": "9cc570d4c419e2ca97e2173dc14c484195502dd4",
            "message": "Use the new non-curve type specific EC functions internally\nFixes #6646\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/6815)\nconst struct nistp_test_params *test = nistp_tests_params + idx;\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *x = NULL, *y = NULL;\nBIGNUM *n = NULL, *m = NULL, *order = NULL, *yplusone = NULL;\nEC_GROUP *NISTP = NULL;\nEC_POINT *G = NULL, *P = NULL, *Q = NULL, *Q_CHECK = NULL;\nint r = 0;\nTEST_note(\"NIST curve P-%d (optimised implementation):\",\ntest->degree);\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_ptr(x = BN_new())\n|| !TEST_ptr(y = BN_new())\n|| !TEST_ptr(m = BN_new())\n|| !TEST_ptr(n = BN_new())\n|| !TEST_ptr(order = BN_new())\n|| !TEST_ptr(yplusone = BN_new())\n|| !TEST_ptr(NISTP = EC_GROUP_new(test->meth()))\n|| !TEST_true(BN_hex2bn(&p, test->p))\n|| !TEST_int_eq(1, BN_is_prime_ex(p, BN_prime_checks, ctx, NULL))\n|| !TEST_true(BN_hex2bn(&a, test->a))\n|| !TEST_true(BN_hex2bn(&b, test->b))\n|| !TEST_ptr(G = EC_POINT_new(NISTP))\n|| !TEST_ptr(P = EC_POINT_new(NISTP))\n|| !TEST_ptr(Q = EC_POINT_new(NISTP))\n|| !TEST_ptr(Q_CHECK = EC_POINT_new(NISTP))\n|| !TEST_true(BN_hex2bn(&x, test->Qx))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1344,35 +1293,35 @@ static int nistp_single_test(int idx) {-    BIO_printf(bio_out, \"\\nNIST curve P-%d (optimised implementation):\\n\",-            test->degree);+    TEST_note(\"NIST curve P-%d (optimised implementation):\",+              test->degree);",
            "commit_date": "2017-06-12 10:01:17+10:00",
            "commit_hash": "3791646202bb4da21992b0aecae253d394507a9e",
            "message": "Add output routines to allow consistent formatting of memory, strings\nand bignums.  These have been refactored into their own file, along with\ntheir error displays.  The formatting follows the output format used\non error, except that bignums of sixty four bits or less are displayed\nin a more compact one line form.\nAdded a TEST_note function for producing output without file and line\ninformation.\nUpdate the three tests that call BN_print so they use the new test\ninfrastructure instead.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Rich Salz <rsalz@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3655)\nconst struct nistp_test_params *test = nistp_tests_params + idx;\nBN_CTX *ctx = NULL;\nBIGNUM *p = NULL, *a = NULL, *b = NULL, *x = NULL, *y = NULL;\nBIGNUM *n = NULL, *m = NULL, *order = NULL, *yplusone = NULL;\nEC_GROUP *NISTP = NULL;\nEC_POINT *G = NULL, *P = NULL, *Q = NULL, *Q_CHECK = NULL;\nint r = 0;\nif (!TEST_ptr(ctx = BN_CTX_new())\n|| !TEST_ptr(p = BN_new())\n|| !TEST_ptr(a = BN_new())\n|| !TEST_ptr(b = BN_new())\n|| !TEST_ptr(x = BN_new())\n|| !TEST_ptr(y = BN_new())\n|| !TEST_ptr(m = BN_new())\n|| !TEST_ptr(n = BN_new())\n|| !TEST_ptr(order = BN_new())\n|| !TEST_ptr(yplusone = BN_new())\n|| !TEST_ptr(NISTP = EC_GROUP_new(test->meth()))\n|| !TEST_true(BN_hex2bn(&p, test->p))\n|| !TEST_int_eq(1, BN_is_prime_ex(p, BN_prime_checks, ctx, NULL))\n|| !TEST_true(BN_hex2bn(&a, test->a))\n|| !TEST_true(BN_hex2bn(&b, test->b))\n|| !TEST_true(EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx))\n|| !TEST_ptr(G = EC_POINT_new(NISTP))\n|| !TEST_ptr(P = EC_POINT_new(NISTP))\n|| !TEST_ptr(Q = EC_POINT_new(NISTP))\n|| !TEST_ptr(Q_CHECK = EC_POINT_new(NISTP))\n|| !TEST_true(BN_hex2bn(&x, test->Qx))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1550,44 +1344,35 @@-static void nistp_single_test(const struct nistp_test_params *test)+static int nistp_single_test(int idx) {-    BN_CTX *ctx;-    BIGNUM *p, *a, *b, *x, *y, *n, *m, *order, *yplusone;-    EC_GROUP *NISTP;-    EC_POINT *G, *P, *Q, *Q_CHECK;+    const struct nistp_test_params *test = nistp_tests_params + idx;+    BN_CTX *ctx = NULL;+    BIGNUM *p = NULL, *a = NULL, *b = NULL, *x = NULL, *y = NULL;+    BIGNUM *n = NULL, *m = NULL, *order = NULL, *yplusone = NULL;+    EC_GROUP *NISTP = NULL;+    EC_POINT *G = NULL, *P = NULL, *Q = NULL, *Q_CHECK = NULL;+    int r = 0;-    fprintf(stdout, \"\\nNIST curve P-%d (optimised implementation):\\n\",+    BIO_printf(bio_out, \"\\nNIST curve P-%d (optimised implementation):\\n\",-    ctx = BN_CTX_new();-    p = BN_new();-    a = BN_new();-    b = BN_new();-    x = BN_new();-    y = BN_new();-    m = BN_new();-    n = BN_new();-    order = BN_new();-    yplusone = BN_new();--    NISTP = EC_GROUP_new(test->meth());-    if (!NISTP)-        ABORT;-    if (!BN_hex2bn(&p, test->p))-        ABORT;-    if (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL))-        ABORT;-    if (!BN_hex2bn(&a, test->a))-        ABORT;-    if (!BN_hex2bn(&b, test->b))-        ABORT;-    if (!EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx))-        ABORT;-    G = EC_POINT_new(NISTP);-    P = EC_POINT_new(NISTP);-    Q = EC_POINT_new(NISTP);-    Q_CHECK = EC_POINT_new(NISTP);-    if (!BN_hex2bn(&x, test->Qx))-        ABORT;-    if (!BN_hex2bn(&y, test->Qy))-        ABORT;-    if (!BN_add(yplusone, y, BN_value_one()))-        ABORT;+    if (!TEST_ptr(ctx = BN_CTX_new())+        || !TEST_ptr(p = BN_new())+        || !TEST_ptr(a = BN_new())+        || !TEST_ptr(b = BN_new())+        || !TEST_ptr(x = BN_new())+        || !TEST_ptr(y = BN_new())+        || !TEST_ptr(m = BN_new())+        || !TEST_ptr(n = BN_new())+        || !TEST_ptr(order = BN_new())+        || !TEST_ptr(yplusone = BN_new())++        || !TEST_ptr(NISTP = EC_GROUP_new(test->meth()))+        || !TEST_true(BN_hex2bn(&p, test->p))+        || !TEST_int_eq(1, BN_is_prime_ex(p, BN_prime_checks, ctx, NULL))+        || !TEST_true(BN_hex2bn(&a, test->a))+        || !TEST_true(BN_hex2bn(&b, test->b))+        || !TEST_true(EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx))+        || !TEST_ptr(G = EC_POINT_new(NISTP))+        || !TEST_ptr(P = EC_POINT_new(NISTP))+        || !TEST_ptr(Q = EC_POINT_new(NISTP))+        || !TEST_ptr(Q_CHECK = EC_POINT_new(NISTP))+        || !TEST_true(BN_hex2bn(&x, test->Qx))",
            "commit_date": "2017-04-28 14:06:11+10:00",
            "commit_hash": "2db85ac97a5dda90249f5e630e7b29c4196fc397",
            "message": "Conversion of the EC tests to use the framework.\nSome refactoring done as well.\nThe prime_field_tests() function needs splitting and refactoring still.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Andy Polyakov <appro@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/3340)\ntest->degree);"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/test/ectest.c b/test/ectest.c--- a/test/ectest.c+++ b/test/ectest.c@@ -1479,41 +1553,44 @@ static void nistp_single_test(const struct nistp_test_params *test) {-    BIGNUM *p, *a, *b, *x, *y, *n, *m, *order;+    BIGNUM *p, *a, *b, *x, *y, *n, *m, *order, *yplusone;+    yplusone = BN_new();+    if (!BN_add(yplusone, y, BN_value_one()))+        ABORT;",
            "commit_date": "2016-06-03 14:42:04+02:00",
            "commit_hash": "1e2012b7ff4a5f12273446b281775faa5c8a1858",
            "message": "RT 4242: reject invalid EC point coordinates\nWe already test in EC_POINT_oct2point that points are on the curve. To\nbe on the safe side, move this check to\nEC_POINT_set_affine_coordinates_* so as to also check point coordinates\nreceived through some other method.\nWe do not check projective coordinates, though, as\n- it's unlikely that applications would be receiving this primarily\ninternal representation from untrusted sources, and\n- it's possible that the projective setters are used in a setting where\nperformance matters.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nBN_CTX *ctx;\nEC_GROUP *NISTP;\nEC_POINT *G, *P, *Q, *Q_CHECK;\nfprintf(stdout, \"\\nNIST curve P-%d (optimised implementation):\\n\",\ntest->degree);\nctx = BN_CTX_new();\np = BN_new();\na = BN_new();\nb = BN_new();\nx = BN_new();\ny = BN_new();\nm = BN_new();\nn = BN_new();\norder = BN_new();\nNISTP = EC_GROUP_new(test->meth());\nif (!NISTP)\nABORT;\nif (!BN_hex2bn(&p, test->p))\nABORT;\nif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL))\nABORT;\nif (!BN_hex2bn(&a, test->a))\nABORT;\nif (!BN_hex2bn(&b, test->b))\nABORT;\nif (!EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx))\nABORT;\nG = EC_POINT_new(NISTP);\nP = EC_POINT_new(NISTP);\nQ = EC_POINT_new(NISTP);\nQ_CHECK = EC_POINT_new(NISTP);\nif (!BN_hex2bn(&x, test->Qx))\nABORT;\nif (!BN_hex2bn(&y, test->Qy))\nABORT;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1394,103 +1669,41 @@ static void nistp_single_test(const struct nistp_test_params *test)-\t{-\tBN_CTX *ctx;-\tBIGNUM *p, *a, *b, *x, *y, *n, *m, *order;-\tEC_GROUP *NISTP;-\tEC_POINT *G, *P, *Q, *Q_CHECK;--\tfprintf(stdout, \"\\nNIST curve P-%d (optimised implementation):\\n\", test->degree);-\tctx = BN_CTX_new();-\tp = BN_new();-\ta = BN_new();-\tb = BN_new();-\tx = BN_new(); y = BN_new();-\tm = BN_new(); n = BN_new(); order = BN_new();--\tNISTP = EC_GROUP_new(test->meth());-\tif(!NISTP) ABORT;-\tif (!BN_hex2bn(&p, test->p)) ABORT;-\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, test->a)) ABORT;-\tif (!BN_hex2bn(&b, test->b)) ABORT;-\tif (!EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx)) ABORT;-\tG = EC_POINT_new(NISTP);-\tP = EC_POINT_new(NISTP);-\tQ = EC_POINT_new(NISTP);-\tQ_CHECK = EC_POINT_new(NISTP);-\tif(!BN_hex2bn(&x, test->Qx)) ABORT;-\tif(!BN_hex2bn(&y, test->Qy)) ABORT;-\tif(!EC_POINT_set_affine_coordinates_GFp(NISTP, Q_CHECK, x, y, ctx)) ABORT;-\tif (!BN_hex2bn(&x, test->Gx)) ABORT;-\tif (!BN_hex2bn(&y, test->Gy)) ABORT;-\tif (!EC_POINT_set_affine_coordinates_GFp(NISTP, G, x, y, ctx)) ABORT;-\tif (!BN_hex2bn(&order, test->order)) ABORT;-\tif (!EC_GROUP_set_generator(NISTP, G, order, BN_value_one())) ABORT;--\tfprintf(stdout, \"verify degree ... \");-\tif (EC_GROUP_get_degree(NISTP) != test->degree) ABORT;-\tfprintf(stdout, \"ok\\n\");--\tfprintf(stdout, \"NIST test vectors ... \");-\tif (!BN_hex2bn(&n, test->d)) ABORT;-\t/* fixed point multiplication */-\tEC_POINT_mul(NISTP, Q, n, NULL, NULL, ctx);-\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT;-\t/* random point multiplication */-\tEC_POINT_mul(NISTP, Q, NULL, G, n, ctx);-\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT;--\t/* set generator to P = 2*G, where G is the standard generator */-\tif (!EC_POINT_dbl(NISTP, P, G, ctx)) ABORT;-\tif (!EC_GROUP_set_generator(NISTP, P, order, BN_value_one())) ABORT;-\t/* set the scalar to m=n/2, where n is the NIST test scalar */-\tif (!BN_rshift(m, n, 1)) ABORT;--\t/* test the non-standard generator */-\t/* fixed point multiplication */-\tEC_POINT_mul(NISTP, Q, m, NULL, NULL, ctx);-\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT;-\t/* random point multiplication */-\tEC_POINT_mul(NISTP, Q, NULL, P, m, ctx);-\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT;--\t/* now repeat all tests with precomputation */-\tif (!EC_GROUP_precompute_mult(NISTP, ctx)) ABORT;--\t/* fixed point multiplication */-\tEC_POINT_mul(NISTP, Q, m, NULL, NULL, ctx);-\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT;-\t/* random point multiplication */-\tEC_POINT_mul(NISTP, Q, NULL, P, m, ctx);-\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT;--\t/* reset generator */-\tif (!EC_GROUP_set_generator(NISTP, G, order, BN_value_one())) ABORT;-\t/* fixed point multiplication */-\tEC_POINT_mul(NISTP, Q, n, NULL, NULL, ctx);-\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT;-\t/* random point multiplication */-\tEC_POINT_mul(NISTP, Q, NULL, G, n, ctx);-\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT;--\tfprintf(stdout, \"ok\\n\");-\tgroup_order_tests(NISTP);-#if 0-\ttimings(NISTP, TIMING_BASE_PT, ctx);-\ttimings(NISTP, TIMING_RAND_PT, ctx);-#endif-\tEC_GROUP_free(NISTP);-\tEC_POINT_free(G);-\tEC_POINT_free(P);-\tEC_POINT_free(Q);-\tEC_POINT_free(Q_CHECK);-\tBN_free(n);-\tBN_free(m);-\tBN_free(p);-\tBN_free(a);-\tBN_free(b);-\tBN_free(x);-\tBN_free(y);-\tBN_free(order);-\tBN_CTX_free(ctx);-\t}+{+    BN_CTX *ctx;+    BIGNUM *p, *a, *b, *x, *y, *n, *m, *order;+    EC_GROUP *NISTP;+    EC_POINT *G, *P, *Q, *Q_CHECK;++    fprintf(stdout, \"\\nNIST curve P-%d (optimised implementation):\\n\",+            test->degree);+    ctx = BN_CTX_new();+    p = BN_new();+    a = BN_new();+    b = BN_new();+    x = BN_new();+    y = BN_new();+    m = BN_new();+    n = BN_new();+    order = BN_new();++    NISTP = EC_GROUP_new(test->meth());+    if (!NISTP)+        ABORT;+    if (!BN_hex2bn(&p, test->p))+        ABORT;+    if (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL))+        ABORT;+    if (!BN_hex2bn(&a, test->a))+        ABORT;+    if (!BN_hex2bn(&b, test->b))+        ABORT;+    if (!EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx))+        ABORT;+    G = EC_POINT_new(NISTP);+    P = EC_POINT_new(NISTP);+    Q = EC_POINT_new(NISTP);+    Q_CHECK = EC_POINT_new(NISTP);+    if (!BN_hex2bn(&x, test->Qx))+        ABORT;+    if (!BN_hex2bn(&y, test->Qy))+        ABORT;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "emilia@openssl.org",
                "name": "Emilia Kasper"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1369,103 +1369,103 @@-void nistp_single_test(const struct nistp_test_params *test)+static void nistp_single_test(const struct nistp_test_params *test) \t{ \tBN_CTX *ctx; \tBIGNUM *p, *a, *b, *x, *y, *n, *m, *order; \tEC_GROUP *NISTP; \tEC_POINT *G, *P, *Q, *Q_CHECK; \tfprintf(stdout, \"\\nNIST curve P-%d (optimised implementation):\\n\", test->degree); \tctx = BN_CTX_new(); \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tx = BN_new(); y = BN_new(); \tm = BN_new(); n = BN_new(); order = BN_new(); \tNISTP = EC_GROUP_new(test->meth()); \tif(!NISTP) ABORT; \tif (!BN_hex2bn(&p, test->p)) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, test->a)) ABORT; \tif (!BN_hex2bn(&b, test->b)) ABORT; \tif (!EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx)) ABORT; \tG = EC_POINT_new(NISTP); \tP = EC_POINT_new(NISTP); \tQ = EC_POINT_new(NISTP); \tQ_CHECK = EC_POINT_new(NISTP); \tif(!BN_hex2bn(&x, test->Qx)) ABORT; \tif(!BN_hex2bn(&y, test->Qy)) ABORT; \tif(!EC_POINT_set_affine_coordinates_GFp(NISTP, Q_CHECK, x, y, ctx)) ABORT; \tif (!BN_hex2bn(&x, test->Gx)) ABORT; \tif (!BN_hex2bn(&y, test->Gy)) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(NISTP, G, x, y, ctx)) ABORT; \tif (!BN_hex2bn(&order, test->order)) ABORT; \tif (!EC_GROUP_set_generator(NISTP, G, order, BN_value_one())) ABORT; \tfprintf(stdout, \"verify degree ... \"); \tif (EC_GROUP_get_degree(NISTP) != test->degree) ABORT; \tfprintf(stdout, \"ok\\n\"); \tfprintf(stdout, \"NIST test vectors ... \"); \tif (!BN_hex2bn(&n, test->d)) ABORT; \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP, Q, n, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP, Q, NULL, G, n, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* set generator to P = 2*G, where G is the standard generator */ \tif (!EC_POINT_dbl(NISTP, P, G, ctx)) ABORT; \tif (!EC_GROUP_set_generator(NISTP, P, order, BN_value_one())) ABORT; \t/* set the scalar to m=n/2, where n is the NIST test scalar */ \tif (!BN_rshift(m, n, 1)) ABORT; \t/* test the non-standard generator */ \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP, Q, m, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP, Q, NULL, P, m, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* now repeat all tests with precomputation */ \tif (!EC_GROUP_precompute_mult(NISTP, ctx)) ABORT; \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP, Q, m, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP, Q, NULL, P, m, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* reset generator */ \tif (!EC_GROUP_set_generator(NISTP, G, order, BN_value_one())) ABORT; \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP, Q, n, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP, Q, NULL, G, n, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tgroup_order_tests(NISTP); #if 0 \ttimings(NISTP, TIMING_BASE_PT, ctx); \ttimings(NISTP, TIMING_RAND_PT, ctx); #endif \tEC_GROUP_free(NISTP); \tEC_POINT_free(G); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(Q_CHECK); \tBN_free(n); \tBN_free(m); \tBN_free(p); \tBN_free(a); \tBN_free(b); \tBN_free(x); \tBN_free(y); \tBN_free(order); \tBN_CTX_free(ctx); \t}",
            "commit_date": "2014-12-15 16:37:13+01:00",
            "commit_hash": "b597aab84e4258ffee2430113f0cac8900e0a499",
            "message": "Build fixes\nVarious build fixes, mostly uncovered by clang's unused-const-variable\nand unused-function errors.\nReviewed-by: Kurt Roeckx <kurt@openssl.org>\n(cherry picked from commit 0e1c318ece3c82e96ae95a34a1badf58198d6b28)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1331,101 +1332,103 @@ void nistp_single_test(const struct nistp_test_params *test) \t{-\tfprintf(stdout, \"\\nNIST curve P-%d (optimised implementation):\\n\", test->degree);+\tBN_CTX *ctx; \tBIGNUM *p, *a, *b, *x, *y, *n, *m, *order;+\tEC_GROUP *NISTP;+\tEC_POINT *G, *P, *Q, *Q_CHECK;++\tfprintf(stdout, \"\\nNIST curve P-%d (optimised implementation):\\n\", test->degree);+\tctx = BN_CTX_new(); \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tx = BN_new(); y = BN_new(); \tm = BN_new(); n = BN_new(); order = BN_new();-\tBN_CTX *ctx = BN_CTX_new();-\tEC_GROUP *NISTP;-\tEC_POINT *G, *P, *Q, *Q_CHECK; \tNISTP = EC_GROUP_new(test->meth()); \tif(!NISTP) ABORT; \tif (!BN_hex2bn(&p, test->p)) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, test->a)) ABORT; \tif (!BN_hex2bn(&b, test->b)) ABORT; \tif (!EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx)) ABORT; \tG = EC_POINT_new(NISTP); \tP = EC_POINT_new(NISTP); \tQ = EC_POINT_new(NISTP); \tQ_CHECK = EC_POINT_new(NISTP); \tif(!BN_hex2bn(&x, test->Qx)) ABORT; \tif(!BN_hex2bn(&y, test->Qy)) ABORT; \tif(!EC_POINT_set_affine_coordinates_GFp(NISTP, Q_CHECK, x, y, ctx)) ABORT; \tif (!BN_hex2bn(&x, test->Gx)) ABORT; \tif (!BN_hex2bn(&y, test->Gy)) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(NISTP, G, x, y, ctx)) ABORT; \tif (!BN_hex2bn(&order, test->order)) ABORT; \tif (!EC_GROUP_set_generator(NISTP, G, order, BN_value_one())) ABORT; \tfprintf(stdout, \"verify degree ... \"); \tif (EC_GROUP_get_degree(NISTP) != test->degree) ABORT; \tfprintf(stdout, \"ok\\n\"); \tfprintf(stdout, \"NIST test vectors ... \"); \tif (!BN_hex2bn(&n, test->d)) ABORT; \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP, Q, n, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP, Q, NULL, G, n, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* set generator to P = 2*G, where G is the standard generator */ \tif (!EC_POINT_dbl(NISTP, P, G, ctx)) ABORT; \tif (!EC_GROUP_set_generator(NISTP, P, order, BN_value_one())) ABORT; \t/* set the scalar to m=n/2, where n is the NIST test scalar */ \tif (!BN_rshift(m, n, 1)) ABORT; \t/* test the non-standard generator */ \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP, Q, m, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP, Q, NULL, P, m, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* now repeat all tests with precomputation */ \tif (!EC_GROUP_precompute_mult(NISTP, ctx)) ABORT; \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP, Q, m, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP, Q, NULL, P, m, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* reset generator */ \tif (!EC_GROUP_set_generator(NISTP, G, order, BN_value_one())) ABORT; \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP, Q, n, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP, Q, NULL, G, n, ctx); \tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tgroup_order_tests(NISTP); #if 0 \ttimings(NISTP, TIMING_BASE_PT, ctx); \ttimings(NISTP, TIMING_RAND_PT, ctx); #endif \tEC_GROUP_free(NISTP); \tEC_POINT_free(G); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(Q_CHECK); \tBN_free(n); \tBN_free(m); \tBN_free(p); \tBN_free(a); \tBN_free(b); \tBN_free(x); \tBN_free(y); \tBN_free(order); \tBN_CTX_free(ctx); \t}",
            "commit_date": "2011-10-19 08:59:53+00:00",
            "commit_hash": "e0d6132b8c2803f62a492b3d5fcdaee046292dbb",
            "message": "Fix warnings.\nAlso, use the common Configure mechanism for enabling/disabling the 64-bit ECC code."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1270,101 +1331,101 @@-#ifdef EC_NISTP224_64_GCC_128-void nistp224_test()++void nistp_single_test(const struct nistp_test_params *test) \t{-\tfprintf(stdout, \"\\nNIST curve P-224 (optimised implementation):\\n\");+\tfprintf(stdout, \"\\nNIST curve P-%d (optimised implementation):\\n\", test->degree); \tBIGNUM *p, *a, *b, *x, *y, *n, *m, *order; \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tx = BN_new(); y = BN_new(); \tm = BN_new(); n = BN_new(); order = BN_new(); \tBN_CTX *ctx = BN_CTX_new();-\tEC_GROUP *NISTP224;+\tEC_GROUP *NISTP; \tEC_POINT *G, *P, *Q, *Q_CHECK;-\tNISTP224 = EC_GROUP_new(EC_GFp_nistp224_method());-\tif(!NISTP224) ABORT;-\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT;+\tNISTP = EC_GROUP_new(test->meth());+\tif(!NISTP) ABORT;+\tif (!BN_hex2bn(&p, test->p)) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;-\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT;-\tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT;-\tif (!EC_GROUP_set_curve_GFp(NISTP224, p, a, b, ctx)) ABORT;-\tG = EC_POINT_new(NISTP224);-\tP = EC_POINT_new(NISTP224);-\tQ = EC_POINT_new(NISTP224);-\tQ_CHECK = EC_POINT_new(NISTP224);-\tif(!BN_hex2bn(&x, \"E84FB0B8E7000CB657D7973CF6B42ED78B301674276DF744AF130B3E\")) ABORT;-\tif(!BN_hex2bn(&y, \"4376675C6FC5612C21A0FF2D2A89D2987DF7A2BC52183B5982298555\")) ABORT;-\tif(!EC_POINT_set_affine_coordinates_GFp(NISTP224, Q_CHECK, x, y, ctx)) ABORT;-\tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT;-\tif (!BN_hex2bn(&y, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT;-\tif (!EC_POINT_set_affine_coordinates_GFp(NISTP224, G, x, y, ctx)) ABORT;-\tif (!BN_hex2bn(&order, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT;-\tif (!EC_GROUP_set_generator(NISTP224, G, order, BN_value_one())) ABORT;+\tif (!BN_hex2bn(&a, test->a)) ABORT;+\tif (!BN_hex2bn(&b, test->b)) ABORT;+\tif (!EC_GROUP_set_curve_GFp(NISTP, p, a, b, ctx)) ABORT;+\tG = EC_POINT_new(NISTP);+\tP = EC_POINT_new(NISTP);+\tQ = EC_POINT_new(NISTP);+\tQ_CHECK = EC_POINT_new(NISTP);+\tif(!BN_hex2bn(&x, test->Qx)) ABORT;+\tif(!BN_hex2bn(&y, test->Qy)) ABORT;+\tif(!EC_POINT_set_affine_coordinates_GFp(NISTP, Q_CHECK, x, y, ctx)) ABORT;+\tif (!BN_hex2bn(&x, test->Gx)) ABORT;+\tif (!BN_hex2bn(&y, test->Gy)) ABORT;+\tif (!EC_POINT_set_affine_coordinates_GFp(NISTP, G, x, y, ctx)) ABORT;+\tif (!BN_hex2bn(&order, test->order)) ABORT;+\tif (!EC_GROUP_set_generator(NISTP, G, order, BN_value_one())) ABORT; \tfprintf(stdout, \"verify degree ... \");-\tif (EC_GROUP_get_degree(NISTP224) != 224) ABORT;+\tif (EC_GROUP_get_degree(NISTP) != test->degree) ABORT; \tfprintf(stdout, \"ok\\n\"); \tfprintf(stdout, \"NIST test vectors ... \");-\tif (!BN_hex2bn(&n, \"3F0C488E987C80BE0FEE521F8D90BE6034EC69AE11CA72AA777481E8\")) ABORT;+\tif (!BN_hex2bn(&n, test->d)) ABORT; \t/* fixed point multiplication */-\tEC_POINT_mul(NISTP224, Q, n, NULL, NULL, ctx);-\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\tEC_POINT_mul(NISTP, Q, n, NULL, NULL, ctx);+\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */-\tEC_POINT_mul(NISTP224, Q, NULL, G, n, ctx);-\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\tEC_POINT_mul(NISTP, Q, NULL, G, n, ctx);+\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* set generator to P = 2*G, where G is the standard generator */-\tif (!EC_POINT_dbl(NISTP224, P, G, ctx)) ABORT;-\tif (!EC_GROUP_set_generator(NISTP224, P, order, BN_value_one())) ABORT;+\tif (!EC_POINT_dbl(NISTP, P, G, ctx)) ABORT;+\tif (!EC_GROUP_set_generator(NISTP, P, order, BN_value_one())) ABORT; \t/* set the scalar to m=n/2, where n is the NIST test scalar */ \tif (!BN_rshift(m, n, 1)) ABORT; \t/* test the non-standard generator */ \t/* fixed point multiplication */-\tEC_POINT_mul(NISTP224, Q, m, NULL, NULL, ctx);-\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\tEC_POINT_mul(NISTP, Q, m, NULL, NULL, ctx);+\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */-\tEC_POINT_mul(NISTP224, Q, NULL, P, m, ctx);-\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\tEC_POINT_mul(NISTP, Q, NULL, P, m, ctx);+\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* now repeat all tests with precomputation */-\tif (!EC_GROUP_precompute_mult(NISTP224, ctx)) ABORT;+\tif (!EC_GROUP_precompute_mult(NISTP, ctx)) ABORT; \t/* fixed point multiplication */-\tEC_POINT_mul(NISTP224, Q, m, NULL, NULL, ctx);-\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\tEC_POINT_mul(NISTP, Q, m, NULL, NULL, ctx);+\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */-\tEC_POINT_mul(NISTP224, Q, NULL, P, m, ctx);-\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\tEC_POINT_mul(NISTP, Q, NULL, P, m, ctx);+\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* reset generator */-\tif (!EC_GROUP_set_generator(NISTP224, G, order, BN_value_one())) ABORT;+\tif (!EC_GROUP_set_generator(NISTP, G, order, BN_value_one())) ABORT; \t/* fixed point multiplication */-\tEC_POINT_mul(NISTP224, Q, n, NULL, NULL, ctx);-\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\tEC_POINT_mul(NISTP, Q, n, NULL, NULL, ctx);+\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */-\tEC_POINT_mul(NISTP224, Q, NULL, G, n, ctx);-\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\tEC_POINT_mul(NISTP, Q, NULL, G, n, ctx);+\tif (0 != EC_POINT_cmp(NISTP, Q, Q_CHECK, ctx)) ABORT; \tfprintf(stdout, \"ok\\n\");-\tgroup_order_tests(NISTP224);+\tgroup_order_tests(NISTP); #if 0-\ttimings(NISTP224, TIMING_BASE_PT, ctx);-\ttimings(NISTP224, TIMING_RAND_PT, ctx);+\ttimings(NISTP, TIMING_BASE_PT, ctx);+\ttimings(NISTP, TIMING_RAND_PT, ctx); #endif-\tEC_GROUP_free(NISTP224);+\tEC_GROUP_free(NISTP); \tEC_POINT_free(G); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(Q_CHECK); \tBN_free(n); \tBN_free(m); \tBN_free(p); \tBN_free(a); \tBN_free(b); \tBN_free(x); \tBN_free(y); \tBN_free(order); \tBN_CTX_free(ctx); \t}",
            "commit_date": "2011-10-18 19:43:16+00:00",
            "commit_hash": "3e00b4c9db42818c621f609e70569c7d9ae85717",
            "message": "Improve optional 64-bit NIST-P224 implementation, and add NIST-P256 and\nNIST-P521. (Now -DEC_NISTP_64_GCC_128 enables all three of these;\n-DEC_NISTP224_64_GCC_128 no longer works.)\nSubmitted by: Google Inc."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1267,99 +1268,101 @@ #ifdef EC_NISTP224_64_GCC_128 void nistp224_test() \t{ \tfprintf(stdout, \"\\nNIST curve P-224 (optimised implementation):\\n\"); \tBIGNUM *p, *a, *b, *x, *y, *n, *m, *order; \tp = BN_new(); \ta = BN_new(); \tb = BN_new(); \tx = BN_new(); y = BN_new(); \tm = BN_new(); n = BN_new(); order = BN_new(); \tBN_CTX *ctx = BN_CTX_new();-\tEC_GROUP *NISTP224 = NULL;+\tEC_GROUP *NISTP224;+\tEC_POINT *G, *P, *Q, *Q_CHECK;+ \tNISTP224 = EC_GROUP_new(EC_GFp_nistp224_method()); \tif(!NISTP224) ABORT; \tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT; \tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT; \tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT; \tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT; \tif (!EC_GROUP_set_curve_GFp(NISTP224, p, a, b, ctx)) ABORT;-\tEC_POINT *G = EC_POINT_new(NISTP224);-\tEC_POINT *P = EC_POINT_new(NISTP224);-\tEC_POINT *Q = EC_POINT_new(NISTP224);-\tEC_POINT *Q_CHECK = EC_POINT_new(NISTP224);+\tG = EC_POINT_new(NISTP224);+\tP = EC_POINT_new(NISTP224);+\tQ = EC_POINT_new(NISTP224);+\tQ_CHECK = EC_POINT_new(NISTP224); \tif(!BN_hex2bn(&x, \"E84FB0B8E7000CB657D7973CF6B42ED78B301674276DF744AF130B3E\")) ABORT; \tif(!BN_hex2bn(&y, \"4376675C6FC5612C21A0FF2D2A89D2987DF7A2BC52183B5982298555\")) ABORT; \tif(!EC_POINT_set_affine_coordinates_GFp(NISTP224, Q_CHECK, x, y, ctx)) ABORT; \tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT; \tif (!BN_hex2bn(&y, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT; \tif (!EC_POINT_set_affine_coordinates_GFp(NISTP224, G, x, y, ctx)) ABORT; \tif (!BN_hex2bn(&order, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT; \tif (!EC_GROUP_set_generator(NISTP224, G, order, BN_value_one())) ABORT; \tfprintf(stdout, \"verify degree ... \"); \tif (EC_GROUP_get_degree(NISTP224) != 224) ABORT; \tfprintf(stdout, \"ok\\n\"); \tfprintf(stdout, \"NIST test vectors ... \"); \tif (!BN_hex2bn(&n, \"3F0C488E987C80BE0FEE521F8D90BE6034EC69AE11CA72AA777481E8\")) ABORT; \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP224, Q, n, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP224, Q, NULL, G, n, ctx); \tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT; \t/* set generator to P = 2*G, where G is the standard generator */ \tif (!EC_POINT_dbl(NISTP224, P, G, ctx)) ABORT; \tif (!EC_GROUP_set_generator(NISTP224, P, order, BN_value_one())) ABORT; \t/* set the scalar to m=n/2, where n is the NIST test scalar */ \tif (!BN_rshift(m, n, 1)) ABORT; \t/* test the non-standard generator */ \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP224, Q, m, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP224, Q, NULL, P, m, ctx); \tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT; \t/* now repeat all tests with precomputation */ \tif (!EC_GROUP_precompute_mult(NISTP224, ctx)) ABORT; \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP224, Q, m, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP224, Q, NULL, P, m, ctx); \tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT; \t/* reset generator */ \tif (!EC_GROUP_set_generator(NISTP224, G, order, BN_value_one())) ABORT; \t/* fixed point multiplication */ \tEC_POINT_mul(NISTP224, Q, n, NULL, NULL, ctx); \tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT; \t/* random point multiplication */ \tEC_POINT_mul(NISTP224, Q, NULL, G, n, ctx); \tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT; \tfprintf(stdout, \"ok\\n\"); \tgroup_order_tests(NISTP224); #if 0 \ttimings(NISTP224, TIMING_BASE_PT, ctx); \ttimings(NISTP224, TIMING_RAND_PT, ctx); #endif \tEC_GROUP_free(NISTP224); \tEC_POINT_free(G); \tEC_POINT_free(P); \tEC_POINT_free(Q); \tEC_POINT_free(Q_CHECK); \tBN_free(n); \tBN_free(m); \tBN_free(p); \tBN_free(a); \tBN_free(b); \tBN_free(x); \tBN_free(y); \tBN_free(order); \tBN_CTX_free(ctx); \t}",
            "commit_date": "2010-08-27 12:07:35+00:00",
            "commit_hash": "eb8ef241eba2ea4194b25ec9f0c60b3adfc0af5c",
            "message": "C conformity fixes: Move declarations before statements in all blocks."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/ec/ectest.c b/crypto/ec/ectest.c--- a/crypto/ec/ectest.c+++ b/crypto/ec/ectest.c@@ -1297,0 +1267,99 @@+#ifdef EC_NISTP224_64_GCC_128+void nistp224_test()+\t{+\tfprintf(stdout, \"\\nNIST curve P-224 (optimised implementation):\\n\");+\tBIGNUM *p, *a, *b, *x, *y, *n, *m, *order;+\tp = BN_new();+\ta = BN_new();+\tb = BN_new();+\tx = BN_new(); y = BN_new();+\tm = BN_new(); n = BN_new(); order = BN_new();+\tBN_CTX *ctx = BN_CTX_new();+\tEC_GROUP *NISTP224 = NULL;+\tNISTP224 = EC_GROUP_new(EC_GFp_nistp224_method());+\tif(!NISTP224) ABORT;+\tif (!BN_hex2bn(&p, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\")) ABORT;+\tif (1 != BN_is_prime_ex(p, BN_prime_checks, ctx, NULL)) ABORT;+\tif (!BN_hex2bn(&a, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\")) ABORT;+\tif (!BN_hex2bn(&b, \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\")) ABORT;+\tif (!EC_GROUP_set_curve_GFp(NISTP224, p, a, b, ctx)) ABORT;+\tEC_POINT *G = EC_POINT_new(NISTP224);+\tEC_POINT *P = EC_POINT_new(NISTP224);+\tEC_POINT *Q = EC_POINT_new(NISTP224);+\tEC_POINT *Q_CHECK = EC_POINT_new(NISTP224);+\tif(!BN_hex2bn(&x, \"E84FB0B8E7000CB657D7973CF6B42ED78B301674276DF744AF130B3E\")) ABORT;+\tif(!BN_hex2bn(&y, \"4376675C6FC5612C21A0FF2D2A89D2987DF7A2BC52183B5982298555\")) ABORT;+\tif(!EC_POINT_set_affine_coordinates_GFp(NISTP224, Q_CHECK, x, y, ctx)) ABORT;+\tif (!BN_hex2bn(&x, \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\")) ABORT;+\tif (!BN_hex2bn(&y, \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\")) ABORT;+\tif (!EC_POINT_set_affine_coordinates_GFp(NISTP224, G, x, y, ctx)) ABORT;+\tif (!BN_hex2bn(&order, \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\")) ABORT;+\tif (!EC_GROUP_set_generator(NISTP224, G, order, BN_value_one())) ABORT;++\tfprintf(stdout, \"verify degree ... \");+\tif (EC_GROUP_get_degree(NISTP224) != 224) ABORT;+\tfprintf(stdout, \"ok\\n\");++\tfprintf(stdout, \"NIST test vectors ... \");+\tif (!BN_hex2bn(&n, \"3F0C488E987C80BE0FEE521F8D90BE6034EC69AE11CA72AA777481E8\")) ABORT;+\t/* fixed point multiplication */+\tEC_POINT_mul(NISTP224, Q, n, NULL, NULL, ctx);+\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\t/* random point multiplication */+\tEC_POINT_mul(NISTP224, Q, NULL, G, n, ctx);+\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;++\t/* set generator to P = 2*G, where G is the standard generator */+\tif (!EC_POINT_dbl(NISTP224, P, G, ctx)) ABORT;+\tif (!EC_GROUP_set_generator(NISTP224, P, order, BN_value_one())) ABORT;+\t/* set the scalar to m=n/2, where n is the NIST test scalar */+\tif (!BN_rshift(m, n, 1)) ABORT;++\t/* test the non-standard generator */+\t/* fixed point multiplication */+\tEC_POINT_mul(NISTP224, Q, m, NULL, NULL, ctx);+\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\t/* random point multiplication */+\tEC_POINT_mul(NISTP224, Q, NULL, P, m, ctx);+\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;++\t/* now repeat all tests with precomputation */+\tif (!EC_GROUP_precompute_mult(NISTP224, ctx)) ABORT;++\t/* fixed point multiplication */+\tEC_POINT_mul(NISTP224, Q, m, NULL, NULL, ctx);+\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\t/* random point multiplication */+\tEC_POINT_mul(NISTP224, Q, NULL, P, m, ctx);+\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;++\t/* reset generator */+\tif (!EC_GROUP_set_generator(NISTP224, G, order, BN_value_one())) ABORT;+\t/* fixed point multiplication */+\tEC_POINT_mul(NISTP224, Q, n, NULL, NULL, ctx);+\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;+\t/* random point multiplication */+\tEC_POINT_mul(NISTP224, Q, NULL, G, n, ctx);+\tif (0 != EC_POINT_cmp(NISTP224, Q, Q_CHECK, ctx)) ABORT;++\tfprintf(stdout, \"ok\\n\");+\tgroup_order_tests(NISTP224);+#if 0+\ttimings(NISTP224, TIMING_BASE_PT, ctx);+\ttimings(NISTP224, TIMING_RAND_PT, ctx);+#endif+\tEC_GROUP_free(NISTP224);+\tEC_POINT_free(G);+\tEC_POINT_free(P);+\tEC_POINT_free(Q);+\tEC_POINT_free(Q_CHECK);+\tBN_free(n);+\tBN_free(m);+\tBN_free(p);+\tBN_free(a);+\tBN_free(b);+\tBN_free(x);+\tBN_free(y);+\tBN_free(order);+\tBN_CTX_free(ctx);+\t}",
            "commit_date": "2010-08-26 14:29:55+00:00",
            "commit_hash": "04daec862ced4e5e3921724b7a59c432fa9cbab3",
            "message": "New 64-bit optimized implementation EC_GFp_nistp224_method().\nThis will only be compiled in if explicitly requested\n(#ifdef EC_NISTP224_64_GCC_128).\nSubmitted by: Emilia Kasper (Google)"
        }
    ],
    "git log -L2418,2446:crypto/evp/p_lib.c": [
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c--- a/crypto/evp/p_lib.c+++ b/crypto/evp/p_lib.c@@ -2218,29 +2253,29 @@ int EVP_PKEY_get_field_type(const EVP_PKEY *pkey) {-#ifndef OPENSSL_NO_EC+# ifndef OPENSSL_NO_EC-#else+# else-#endif+# endif",
            "commit_date": "2021-03-16 18:29:19+01:00",
            "commit_hash": "0e2f87c03e1a288f5f58627b373a25f83c59318a",
            "message": "Added functions for printing EVP_PKEYs to FILE *\nFixes #14172\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14577)\nchar fstr[80];\nsize_t fstrlen;\nif (pkey == NULL)\nreturn 0;\nif (pkey->keymgmt == NULL\n|| pkey->keydata == NULL) {\n/* Might work through the legacy route */\nconst EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);\nconst EC_GROUP *grp;\nif (ec == NULL)\nreturn 0;\ngrp = EC_KEY_get0_group(ec);\nif (grp == NULL)\nreturn 0;\nreturn EC_GROUP_get_field_type(grp);\nreturn 0;\n}\nif (!EVP_PKEY_get_utf8_string_param(pkey, OSSL_PKEY_PARAM_EC_FIELD_TYPE,"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c--- a/crypto/evp/p_lib.c+++ b/crypto/evp/p_lib.c@@ -2196,29 +2208,29 @@ int EVP_PKEY_get_field_type(const EVP_PKEY *pkey) { #ifndef OPENSSL_NO_EC-        EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);+        const EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey); #else #endif",
            "commit_date": "2021-03-02 15:52:00+00:00",
            "commit_hash": "7bc0fdd3fd4535e06c35b92d71afab9a6de94cc5",
            "message": "Make the EVP_PKEY_get0* functions have a const return type\nOTC have decided that the EVP_PKEY_get0* functions should have a const\nreturn type. This is a breaking change to emphasise that these values\nshould be considered as immutable.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14319)\nchar fstr[80];\nsize_t fstrlen;\nif (pkey == NULL)\nreturn 0;\nif (pkey->keymgmt == NULL\n|| pkey->keydata == NULL) {\n/* Might work through the legacy route */\nconst EC_GROUP *grp;\nif (ec == NULL)\nreturn 0;\ngrp = EC_KEY_get0_group(ec);\nif (grp == NULL)\nreturn 0;\nreturn EC_GROUP_get_field_type(grp);\nreturn 0;\n}\nif (!EVP_PKEY_get_utf8_string_param(pkey, OSSL_PKEY_PARAM_EC_FIELD_TYPE,"
        },
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c--- a/crypto/evp/p_lib.c+++ b/crypto/evp/p_lib.c@@ -2255,27 +2257,29 @@ int EVP_PKEY_get_field_type(const EVP_PKEY *pkey) { #ifndef OPENSSL_NO_EC+        if (grp == NULL)+            return 0; #else #endif",
            "commit_date": "2021-01-22 13:59:54+01:00",
            "commit_hash": "82a46200911f2bb1af00b6921c0db9738825aa76",
            "message": "Add checks for NULL return from EC_KEY_get0_group()\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13139)\nchar fstr[80];\nsize_t fstrlen;\nif (pkey == NULL)\nreturn 0;\nif (pkey->keymgmt == NULL\n|| pkey->keydata == NULL) {\n/* Might work through the legacy route */\nEC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);\nconst EC_GROUP *grp;\nif (ec == NULL)\nreturn 0;\ngrp = EC_KEY_get0_group(ec);\nreturn EC_GROUP_get_field_type(grp);\nreturn 0;\n}\nif (!EVP_PKEY_get_utf8_string_param(pkey, OSSL_PKEY_PARAM_EC_FIELD_TYPE,"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c--- a/crypto/evp/p_lib.c+++ b/crypto/evp/p_lib.c@@ -2214,0 +2255,27 @@++int EVP_PKEY_get_field_type(const EVP_PKEY *pkey)+{+    char fstr[80];+    size_t fstrlen;++    if (pkey == NULL)+        return 0;++    if (pkey->keymgmt == NULL+            || pkey->keydata == NULL) {+#ifndef OPENSSL_NO_EC+        /* Might work through the legacy route */+        EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);+        const EC_GROUP *grp;++        if (ec == NULL)+            return 0;+        grp = EC_KEY_get0_group(ec);++        return EC_GROUP_get_field_type(grp);+#else+        return 0;+#endif+    }++    if (!EVP_PKEY_get_utf8_string_param(pkey, OSSL_PKEY_PARAM_EC_FIELD_TYPE,",
            "commit_date": "2021-01-18 16:05:43+00:00",
            "commit_hash": "3d34bedfd7fb9120b6eb7b05c25cd0c3de14c562",
            "message": "Add EVP_PKEY functions to get EC conv form and field type\nlibssl at the moment downgrades an EVP_PKEY to an EC_KEY object in order\nto get the conv form and field type. Instead we provide EVP_PKEY level\nfunctions to do this.\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13139)"
        }
    ],
    "git log -L2378,2402:crypto/evp/p_lib.c": [
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c--- a/crypto/evp/p_lib.c+++ b/crypto/evp/p_lib.c@@ -2178,25 +2213,25 @@ #ifndef FIPS_MODULE int EVP_PKEY_get_ec_point_conv_form(const EVP_PKEY *pkey) {-#ifndef OPENSSL_NO_EC+# ifndef OPENSSL_NO_EC-#else+# else-#endif+# endif",
            "commit_date": "2021-03-16 18:29:19+01:00",
            "commit_hash": "0e2f87c03e1a288f5f58627b373a25f83c59318a",
            "message": "Added functions for printing EVP_PKEYs to FILE *\nFixes #14172\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14577)\nchar name[80];\nsize_t name_len;\nif (pkey == NULL)\nreturn 0;\nif (pkey->keymgmt == NULL\n|| pkey->keydata == NULL) {\n/* Might work through the legacy route */\nconst EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);\nif (ec == NULL)\nreturn 0;\nreturn EC_KEY_get_conv_form(ec);\nreturn 0;\n}\nif (!EVP_PKEY_get_utf8_string_param(pkey,"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c--- a/crypto/evp/p_lib.c+++ b/crypto/evp/p_lib.c@@ -2156,25 +2168,25 @@ #ifndef FIPS_MODULE int EVP_PKEY_get_ec_point_conv_form(const EVP_PKEY *pkey) { #ifndef OPENSSL_NO_EC-        EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);+        const EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey); #else #endif",
            "commit_date": "2021-03-02 15:52:00+00:00",
            "commit_hash": "7bc0fdd3fd4535e06c35b92d71afab9a6de94cc5",
            "message": "Make the EVP_PKEY_get0* functions have a const return type\nOTC have decided that the EVP_PKEY_get0* functions should have a const\nreturn type. This is a breaking change to emphasise that these values\nshould be considered as immutable.\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14319)\nchar name[80];\nsize_t name_len;\nif (pkey == NULL)\nreturn 0;\nif (pkey->keymgmt == NULL\n|| pkey->keydata == NULL) {\n/* Might work through the legacy route */\nif (ec == NULL)\nreturn 0;\nreturn EC_KEY_get_conv_form(ec);\nreturn 0;\n}\nif (!EVP_PKEY_get_utf8_string_param(pkey,"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/evp/p_lib.c b/crypto/evp/p_lib.c--- a/crypto/evp/p_lib.c+++ b/crypto/evp/p_lib.c@@ -2214,0 +2215,25 @@+#ifndef FIPS_MODULE+int EVP_PKEY_get_ec_point_conv_form(const EVP_PKEY *pkey)+{+    char name[80];+    size_t name_len;++    if (pkey == NULL)+        return 0;++    if (pkey->keymgmt == NULL+            || pkey->keydata == NULL) {+#ifndef OPENSSL_NO_EC+        /* Might work through the legacy route */+        EC_KEY *ec = EVP_PKEY_get0_EC_KEY(pkey);++        if (ec == NULL)+            return 0;++        return EC_KEY_get_conv_form(ec);+#else+        return 0;+#endif+    }++    if (!EVP_PKEY_get_utf8_string_param(pkey,",
            "commit_date": "2021-01-18 16:05:43+00:00",
            "commit_hash": "3d34bedfd7fb9120b6eb7b05c25cd0c3de14c562",
            "message": "Add EVP_PKEY functions to get EC conv form and field type\nlibssl at the moment downgrades an EVP_PKEY to an EC_KEY object in order\nto get the conv form and field type. Instead we provide EVP_PKEY level\nfunctions to do this.\nReviewed-by: Tomas Mraz <tomas@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13139)"
        }
    ],
    "git log -L12,137:crypto/bn/bn_sqrt.c": [
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,125 +12,126 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number- * Theory\", algorithm 1.5.1). 'p' must be prime!+ * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or+ * an incorrect \"result\" will be returned.  */ {",
            "commit_date": "2022-02-28 18:26:21+01:00",
            "commit_hash": "9eafb53614bf65797db25f467946e735e1b43dc9",
            "message": "Fix possible infinite loop in BN_mod_sqrt()\nThe calculation in some cases does not finish for non-prime p.\nThis fixes CVE-2022-0778.\nBased on patch by David Benjamin <davidben@google.com>.\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nint used_ctx = 0;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nused_ctx = 1;\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* Subject: Square Roots and Cognate Matters modulo p=8n+5.\n* URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))"
        },
        {
            "author": {
                "email": "agustingianni@gmail.com",
                "name": "Agustin Gianni"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,123 +12,125 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {+    int used_ctx = 0;+    used_ctx = 1;",
            "commit_date": "2021-01-08 16:04:05+01:00",
            "commit_hash": "48116c2d0fbb1db875e2bc703c08089bf3c5c5c3",
            "message": "Fix incorrect use of BN_CTX API\nIn some edge cases BN_CTX_end was being called without first calling\nBN_CTX_start. This creates a situation where the state of the big\nnumber allocator is corrupted and may lead to crashes.\nFixes #13812\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/13813)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* Subject: Square Roots and Cognate Matters modulo p=8n+5.\n* URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,123 +12,123 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);",
            "commit_date": "2020-11-04 12:23:19+01:00",
            "commit_hash": "9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2",
            "message": "Convert all {NAME}err() in crypto/ to their corresponding ERR_raise() call\nThis includes error reporting for libcrypto sub-libraries in surprising\nplaces.\nThis was done using util/err-to-raise\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13318)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* Subject: Square Roots and Cognate Matters modulo p=8n+5.\n* URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))"
        },
        {
            "author": {
                "email": "bernd.edlinger@hotmail.de",
                "name": "Bernd Edlinger"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,122 +12,123 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-         * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+         * Subject: Square Roots and Cognate Matters modulo p=8n+5.+         * URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026",
            "commit_date": "2019-06-10 10:24:35+02:00",
            "commit_hash": "e98e586b31386af2b2212729da85561a207e7af3",
            "message": "Fix a URL to the NMBRTHRY list archive\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/9123)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))"
        },
        {
            "author": {
                "email": "kunnpuu@gmail.com",
                "name": "KaoruToda"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,122 +12,122 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-        return (NULL);+        return NULL;",
            "commit_date": "2017-10-17 23:04:09+09:00",
            "commit_hash": "26a7d938c9bf932a55cb5e4e02abb48fe395c5cd",
            "message": "Remove parentheses of return.\nSince return is inconsistent, I removed unnecessary parentheses and\nunified them.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4541)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -62,122 +62,122 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-                /*--                 * |p| == 5  (mod 8)-                 *-                 * In this case  2  is always a non-square since-                 * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.-                 * So if  a  really is a square, then  2*a  is a non-square.-                 * Thus for-                 *      b := (2*a)^((|p|-5)/8),-                 *      i := (2*a)*b^2-                 * we have-                 *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)-                 *         = (2*a)^((p-1)/2)-                 *         = -1;-                 * so if we set-                 *      x := a*b*(i-1),-                 * then-                 *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)-                 *         = a^2 * b^2 * (-2*i)-                 *         = a*(-i)*(2*a*b^2)-                 *         = a*(-i)*i-                 *         = a.-                 *-                 * (This is due to A.O.L. Atkin,-                 * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,-                 * November 1992.)-                 */+        /*-+         * |p| == 5  (mod 8)+         *+         * In this case  2  is always a non-square since+         * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+         * So if  a  really is a square, then  2*a  is a non-square.+         * Thus for+         *      b := (2*a)^((|p|-5)/8),+         *      i := (2*a)*b^2+         * we have+         *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)+         *         = (2*a)^((p-1)/2)+         *         = -1;+         * so if we set+         *      x := a*b*(i-1),+         * then+         *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+         *         = a^2 * b^2 * (-2*i)+         *         = a*(-i)*(2*a*b^2)+         *         = a*(-i)*i+         *         = a.+         *+         * (This is due to A.O.L. Atkin,+         * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+         * November 1992.)+         */",
            "commit_date": "2015-01-17 00:06:54+00:00",
            "commit_hash": "35a1cc90bc1795e8893c11e442790ee7f659fffb",
            "message": "More comment realignment\nReviewed-by: Tim Hudson <tjh@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn (NULL);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -62,122 +62,122 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-                /*--                 * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse-                 * modulo  (|p|-1)/2,  and square roots can be computed-                 * directly by modular exponentiation.-                 * We have-                 *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),-                 * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.-                 */+        /*-+         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+         * modulo  (|p|-1)/2,  and square roots can be computed+         * directly by modular exponentiation.+         * We have+         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.+         */",
            "commit_date": "2015-01-05 11:30:03+00:00",
            "commit_hash": "50e735f9e5d220cdad7db690188b82a69ddcb39e",
            "message": "Re-align some comments after running the reformat script.\nThis should be a one off operation (subsequent invokation of the\nscript should not move them)\nReviewed-by: Tim Hudson <tjh@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn (NULL);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,308 +62,122 @@--BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) -/* Returns 'ret' such that- *      ret^2 == a (mod p),- * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course- * in Algebraic Computational Number Theory\", algorithm 1.5.1).- * 'p' must be prime!+BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)+/*+ * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks+ * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number+ * Theory\", algorithm 1.5.1). 'p' must be prime!  */-\t{-\tBIGNUM *ret = in;-\tint err = 1;-\tint r;-\tBIGNUM *A, *b, *q, *t, *x, *y;-\tint e, i, j;-\t-\tif (!BN_is_odd(p) || BN_abs_is_word(p, 1))-\t\t{-\t\tif (BN_abs_is_word(p, 2))-\t\t\t{-\t\t\tif (ret == NULL)-\t\t\t\tret = BN_new();-\t\t\tif (ret == NULL)-\t\t\t\tgoto end;-\t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0)))-\t\t\t\t{-\t\t\t\tif (ret != in)-\t\t\t\t\tBN_free(ret);-\t\t\t\treturn NULL;-\t\t\t\t}-\t\t\tbn_check_top(ret);-\t\t\treturn ret;-\t\t\t}--\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\treturn(NULL);-\t\t}--\tif (BN_is_zero(a) || BN_is_one(a))-\t\t{-\t\tif (ret == NULL)-\t\t\tret = BN_new();-\t\tif (ret == NULL)-\t\t\tgoto end;-\t\tif (!BN_set_word(ret, BN_is_one(a)))-\t\t\t{-\t\t\tif (ret != in)-\t\t\t\tBN_free(ret);-\t\t\treturn NULL;-\t\t\t}-\t\tbn_check_top(ret);-\t\treturn ret;-\t\t}--\tBN_CTX_start(ctx);-\tA = BN_CTX_get(ctx);-\tb = BN_CTX_get(ctx);-\tq = BN_CTX_get(ctx);-\tt = BN_CTX_get(ctx);-\tx = BN_CTX_get(ctx);-\ty = BN_CTX_get(ctx);-\tif (y == NULL) goto end;-\t-\tif (ret == NULL)-\t\tret = BN_new();-\tif (ret == NULL) goto end;--\t/* A = a mod p */-\tif (!BN_nnmod(A, a, p, ctx)) goto end;--\t/* now write  |p| - 1  as  2^e*q  where  q  is odd */-\te = 1;-\twhile (!BN_is_bit_set(p, e))-\t\te++;-\t/* we'll set  q  later (if needed) */--\tif (e == 1)-\t\t{-\t\t/*--\t\t * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse-\t\t * modulo  (|p|-1)/2,  and square roots can be computed-\t\t * directly by modular exponentiation.-\t\t * We have-\t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),-\t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.-\t\t */-\t\tif (!BN_rshift(q, p, 2)) goto end;-\t\tq->neg = 0;-\t\tif (!BN_add_word(q, 1)) goto end;-\t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end;-\t\terr = 0;-\t\tgoto vrfy;-\t\t}-\t-\tif (e == 2)-\t\t{-\t\t/*--\t\t * |p| == 5  (mod 8)-\t\t *-\t\t * In this case  2  is always a non-square since-\t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.-\t\t * So if  a  really is a square, then  2*a  is a non-square.-\t\t * Thus for-\t\t *      b := (2*a)^((|p|-5)/8),-\t\t *      i := (2*a)*b^2-\t\t * we have-\t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)-\t\t *         = (2*a)^((p-1)/2)-\t\t *         = -1;-\t\t * so if we set-\t\t *      x := a*b*(i-1),-\t\t * then-\t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)-\t\t *         = a^2 * b^2 * (-2*i)-\t\t *         = a*(-i)*(2*a*b^2)-\t\t *         = a*(-i)*i-\t\t *         = a.-\t\t *-\t\t * (This is due to A.O.L. Atkin, -\t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,-\t\t * November 1992.)-\t\t */--\t\t/* t := 2*a */-\t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end;--\t\t/* b := (2*a)^((|p|-5)/8) */-\t\tif (!BN_rshift(q, p, 3)) goto end;-\t\tq->neg = 0;-\t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end;--\t\t/* y := b^2 */-\t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end;--\t\t/* t := (2*a)*b^2 - 1*/-\t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;-\t\tif (!BN_sub_word(t, 1)) goto end;--\t\t/* x = a*b*t */-\t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end;-\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;--\t\tif (!BN_copy(ret, x)) goto end;-\t\terr = 0;-\t\tgoto vrfy;-\t\t}-\t-\t/* e > 2, so we really have to use the Tonelli/Shanks algorithm.-\t * First, find some  y  that is not a square. */-\tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */-\tq->neg = 0;-\ti = 2;-\tdo-\t\t{-\t\t/* For efficiency, try small numbers first;-\t\t * if this fails, try random numbers.-\t\t */-\t\tif (i < 22)-\t\t\t{-\t\t\tif (!BN_set_word(y, i)) goto end;-\t\t\t}-\t\telse-\t\t\t{-\t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end;-\t\t\tif (BN_ucmp(y, p) >= 0)-\t\t\t\t{-\t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end;-\t\t\t\t}-\t\t\t/* now 0 <= y < |p| */-\t\t\tif (BN_is_zero(y))-\t\t\t\tif (!BN_set_word(y, i)) goto end;-\t\t\t}-\t\t-\t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */-\t\tif (r < -1) goto end;-\t\tif (r == 0)-\t\t\t{-\t\t\t/* m divides p */-\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\t\tgoto end;-\t\t\t}-\t\t}-\twhile (r == 1 && ++i < 82);-\t-\tif (r != -1)-\t\t{-\t\t/* Many rounds and still no non-square -- this is more likely-\t\t * a bug than just bad luck.-\t\t * Even if  p  is not prime, we should have found some  y-\t\t * such that r == -1.-\t\t */-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);-\t\tgoto end;-\t\t}--\t/* Here's our actual 'q': */-\tif (!BN_rshift(q, q, e)) goto end;--\t/* Now that we have some non-square, we can find an element-\t * of order  2^e  by computing its q'th power. */-\tif (!BN_mod_exp(y, y, q, p, ctx)) goto end;-\tif (BN_is_one(y))-\t\t{-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\tgoto end;-\t\t}--\t/*--\t * Now we know that (if  p  is indeed prime) there is an integer-\t * k,  0 <= k < 2^e,  such that-\t *-\t *      a^q * y^k == 1   (mod p).-\t *-\t * As  a^q  is a square and  y  is not,  k  must be even.-\t * q+1  is even, too, so there is an element-\t *-\t *     X := a^((q+1)/2) * y^(k/2),-\t *-\t * and it satisfies-\t *-\t *     X^2 = a^q * a     * y^k-\t *         = a,-\t *-\t * so it is the square root that we are looking for.-\t */-\t-\t/* t := (q-1)/2  (note that  q  is odd) */-\tif (!BN_rshift1(t, q)) goto end;-\t-\t/* x := a^((q-1)/2) */-\tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */-\t\t{-\t\tif (!BN_nnmod(t, A, p, ctx)) goto end;-\t\tif (BN_is_zero(t))-\t\t\t{-\t\t\t/* special case: a == 0  (mod p) */-\t\t\tBN_zero(ret);-\t\t\terr = 0;-\t\t\tgoto end;-\t\t\t}-\t\telse-\t\t\tif (!BN_one(x)) goto end;-\t\t}-\telse-\t\t{-\t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end;-\t\tif (BN_is_zero(x))-\t\t\t{-\t\t\t/* special case: a == 0  (mod p) */-\t\t\tBN_zero(ret);-\t\t\terr = 0;-\t\t\tgoto end;-\t\t\t}-\t\t}--\t/* b := a*x^2  (= a^q) */-\tif (!BN_mod_sqr(b, x, p, ctx)) goto end;-\tif (!BN_mod_mul(b, b, A, p, ctx)) goto end;-\t-\t/* x := a*x    (= a^((q+1)/2)) */-\tif (!BN_mod_mul(x, x, A, p, ctx)) goto end;--\twhile (1)-\t\t{-\t\t/*- -\t\t * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E-\t\t * where  E  refers to the original value of  e,  which we-\t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).-\t\t *-\t\t * We have  a*b = x^2,-\t\t *    y^2^(e-1) = -1,-\t\t *    b^2^(e-1) = 1.-\t\t */--\t\tif (BN_is_one(b))-\t\t\t{-\t\t\tif (!BN_copy(ret, x)) goto end;-\t\t\terr = 0;-\t\t\tgoto vrfy;-\t\t\t}---\t\t/* find smallest  i  such that  b^(2^i) = 1 */-\t\ti = 1;-\t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end;-\t\twhile (!BN_is_one(t))-\t\t\t{-\t\t\ti++;-\t\t\tif (i == e)-\t\t\t\t{-\t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);-\t\t\t\tgoto end;-\t\t\t\t}-\t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end;-\t\t\t}-\t\t--\t\t/* t := y^2^(e - i - 1) */-\t\tif (!BN_copy(t, y)) goto end;-\t\tfor (j = e - i - 1; j > 0; j--)-\t\t\t{-\t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end;-\t\t\t}-\t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end;-\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;-\t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end;-\t\te = i;-\t\t}+{+    BIGNUM *ret = in;+    int err = 1;+    int r;+    BIGNUM *A, *b, *q, *t, *x, *y;+    int e, i, j;++    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {+        if (BN_abs_is_word(p, 2)) {+            if (ret == NULL)+                ret = BN_new();+            if (ret == NULL)+                goto end;+            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {+                if (ret != in)+                    BN_free(ret);+                return NULL;+            }+            bn_check_top(ret);+            return ret;+        }++        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+        return (NULL);+    }++    if (BN_is_zero(a) || BN_is_one(a)) {+        if (ret == NULL)+            ret = BN_new();+        if (ret == NULL)+            goto end;+        if (!BN_set_word(ret, BN_is_one(a))) {+            if (ret != in)+                BN_free(ret);+            return NULL;+        }+        bn_check_top(ret);+        return ret;+    }++    BN_CTX_start(ctx);+    A = BN_CTX_get(ctx);+    b = BN_CTX_get(ctx);+    q = BN_CTX_get(ctx);+    t = BN_CTX_get(ctx);+    x = BN_CTX_get(ctx);+    y = BN_CTX_get(ctx);+    if (y == NULL)+        goto end;++    if (ret == NULL)+        ret = BN_new();+    if (ret == NULL)+        goto end;++    /* A = a mod p */+    if (!BN_nnmod(A, a, p, ctx))+        goto end;++    /* now write  |p| - 1  as  2^e*q  where  q  is odd */+    e = 1;+    while (!BN_is_bit_set(p, e))+        e++;+    /* we'll set  q  later (if needed) */++    if (e == 1) {+                /*-+                 * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+                 * modulo  (|p|-1)/2,  and square roots can be computed+                 * directly by modular exponentiation.+                 * We have+                 *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+                 * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.+                 */+        if (!BN_rshift(q, p, 2))+            goto end;+        q->neg = 0;+        if (!BN_add_word(q, 1))+            goto end;+        if (!BN_mod_exp(ret, A, q, p, ctx))+            goto end;+        err = 0;+        goto vrfy;+    }++    if (e == 2) {+                /*-+                 * |p| == 5  (mod 8)+                 *+                 * In this case  2  is always a non-square since+                 * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+                 * So if  a  really is a square, then  2*a  is a non-square.+                 * Thus for+                 *      b := (2*a)^((|p|-5)/8),+                 *      i := (2*a)*b^2+                 * we have+                 *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)+                 *         = (2*a)^((p-1)/2)+                 *         = -1;+                 * so if we set+                 *      x := a*b*(i-1),+                 * then+                 *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+                 *         = a^2 * b^2 * (-2*i)+                 *         = a*(-i)*(2*a*b^2)+                 *         = a*(-i)*i+                 *         = a.+                 *+                 * (This is due to A.O.L. Atkin,+                 * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+                 * November 1992.)+                 */++        /* t := 2*a */+        if (!BN_mod_lshift1_quick(t, A, p))",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "tjh@openssl.org",
                "name": "Tim Hudson"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,304 +60,308 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tif (ret != in) \t\t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tif (ret != in) \t\t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{-\t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+\t\t/*-+\t\t * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{-\t\t/* |p| == 5  (mod 8)+\t\t/*-+\t\t * |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t}-\t/* Now we know that (if  p  is indeed prime) there is an integer+\t/*-+\t * Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{-\t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E+\t\t/*- +\t\t * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2014-12-28 12:48:40+10:00",
            "commit_hash": "1d97c8435171a7af575f73c526d79e1ef0ee5960",
            "message": "mark all block comments that need format preserving so that\nindent will not alter them when reformatting comments\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,304 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{-\t\t\t\tBN_free(ret);+\t\t\t\tif (ret != in)+\t\t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{-\t\t\tBN_free(ret);+\t\t\tif (ret != in)+\t\t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2005-08-23 04:14:40+00:00",
            "commit_hash": "7534d131d676431f1299618dfe0decd1a42680bb",
            "message": "avoid potential spurious BN_free()\nSubmitted by: David Heine <dlheine@suif.Stanford.EDU>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */-\t\t\tif (!BN_zero(ret)) goto end;+\t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */-\t\t\tif (!BN_zero(ret)) goto end;+\t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2004-03-13 23:57:20+00:00",
            "commit_hash": "b6358c89a10128692875fb92921b663c4d079a1e",
            "message": "Convert openssl code not to assume the deprecated form of BN_zero().\nRemove certain redundant BN_zero() initialisations, because BN_CTX_get(),\nBN_init(), [etc] already initialise to zero.\nCorrect error checking in bn_sqr.c, and be less wishy-wash about how/why\nthe result's 'top' value is set (note also, 'max' is always > 0 at this\npoint)."
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,300 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t}+\t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t}+\t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2003-11-04 22:54:49+00:00",
            "commit_hash": "d870740cd75dd4f0cb66fb8c32653a7d47369706",
            "message": "Put the first stage of my bignum debugging adventures into CVS. This code\nis itself experimental, and in addition may cause execution to break on\nexisting openssl \"bugs\" that previously were harmless or at least\ninvisible."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,300 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!- * If 'a' is not a square, this is not necessarily detected by- * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 15:13:10+00:00",
            "commit_hash": "d3bcbba45c4f161d88e30fd8b0434e8e24202681",
            "message": "remove obsolete part of comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,312 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  * If 'a' is not a square, this is not necessarily detected by  * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t}-#if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */-\tr = BN_kronecker(a, p, ctx);-\tif (r < -1) return NULL;-\tif (r == -1)-\t\t{-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);-\t\treturn(NULL);-\t\t}-#endif- \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 15:07:08+00:00",
            "commit_hash": "0903e56196a1a265dd9397e1e09a22aa4766914e",
            "message": "remove obsoleted disabled code"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,315 +60,312 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  * If 'a' is not a square, this is not necessarily detected by  * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r;-\tBIGNUM *b, *q, *t, *x, *y;+\tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx);+\tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end;+\t/* A = a mod p */+\tif (!BN_nnmod(A, a, p, ctx)) goto end;+ \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end;-\t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end;+\t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0;-\t\tgoto end;+\t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */-\t\t/* make sure that  a  is reduced modulo p */-\t\tif (a->neg || BN_ucmp(a, p) >= 0)-\t\t\t{-\t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end;-\t\t\ta = x; /* use x as temporary variable */-\t\t\t}- \t\t/* t := 2*a */-\t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;+\t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */-\t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0;-\t\tgoto end;+\t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{-\t\tif (!BN_nnmod(t, a, p, ctx)) goto end;+\t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{-\t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end;+\t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end;-\tif (!BN_mod_mul(b, b, a, p, ctx)) goto end;+\tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */-\tif (!BN_mod_mul(x, x, a, p, ctx)) goto end;+\tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0;-\t\t\tgoto end;+\t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 14:57:53+00:00",
            "commit_hash": "6fb60a84dd1ec81953917e0444dab50186617432",
            "message": "Change BN_mod_sqrt() so that it verifies that the input value is\nreally the square of the return value."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,313 +60,315 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!+ * If 'a' is not a square, this is not necessarily detected by+ * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2001-03-08 16:53:30+00:00",
            "commit_hash": "ff612904d277b6e4f8118913e1278a1afc75e073",
            "message": "Comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,314 +60,313 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++;-\tif (e > 2)-\t\t{-\t\t/* we don't need this  q  if  e = 1 or 2 */-\t\tif (!BN_rshift(q, p, e)) goto end;-\t\tq->neg = 0;-\t\t}+\t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{-\t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse-\t\t * modulo  (p-1)/2,  and square roots can be computed+\t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+\t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have-\t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),-\t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1.+\t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+\t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{-\t\t/* p == 5  (mod 8)+\t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for-\t\t *      b := (2*a)^((p-5)/8),+\t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have-\t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2)+\t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;-\t\t/* b := (2*a)^((p-5)/8) */+\t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */+\tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */+\tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t}-\t\tr = BN_kronecker(y, p, ctx);+\t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t}+\t/* Here's our actual 'q': */+\tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-07 08:48:58+00:00",
            "commit_hash": "80d89e6a6aa6d9520336c78877c3cccb54c881cd",
            "message": "Sign-related fixes (and tests).\nBN_mod_exp_mont does not work properly yet if modulus m\nis negative (we want computations to be carried out\nmodulo |m|)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,310 +60,314 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (e > 2)+\t\t{ \t\t/* we don't need this  q  if  e = 1 or 2 */ \t\tif (!BN_rshift(q, p, e)) goto end;-\tq->neg = 0;+\t\tq->neg = 0;+\t\t} \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end;+\t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* p == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((p-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((p-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end;+\t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-07 07:55:26+00:00",
            "commit_hash": "bc5f2740d2a427d5e16bfb12aa8b70d5a5adcfc8",
            "message": "Move 'q->neg = 0' to those places where it is needed\n(just in cases someone uses a negative modulus)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,310 +60,310 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (e > 2) \t\t/* we don't need this  q  if  e = 1 or 2 */ \t\tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* p == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((p-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((p-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;-\t\tif (!BN_sub_word(t, 1)) goto end; /* cannot become negative */+\t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-06 21:33:58+00:00",
            "commit_hash": "aa66eba7c8c7496db92b80da19688d6f96a40b96",
            "message": "BN_mod_sqrt documentation/comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,236 +60,310 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t}+\tif (BN_is_zero(a) || BN_is_one(a))+\t\t{+\t\tif (ret == NULL)+\t\t\tret = BN_new();+\t\tif (ret == NULL)+\t\t\tgoto end;+\t\tif (!BN_set_word(ret, BN_is_one(a)))+\t\t\t{+\t\t\tBN_free(ret);+\t\t\treturn NULL;+\t\t\t}+\t\treturn ret;+\t\t}+ #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++;-\tif (!BN_rshift(q, p, e)) goto end;+\tif (e > 2)+\t\t/* we don't need this  q  if  e = 1 or 2 */+\t\tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),-\t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2.+\t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */-\t\tif (!BN_add_word(q,1)) goto end;-\t\tif (!BN_rshift1(q,q)) goto end;+\t\tif (!BN_rshift(q, p, 2)) goto end;+\t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t}-\t/* e > 1, so we really have to use the Tonelli/Shanks algorithm.+\tif (e == 2)+\t\t{+\t\t/* p == 5  (mod 8)+\t\t *+\t\t * In this case  2  is always a non-square since+\t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+\t\t * So if  a  really is a square, then  2*a  is a non-square.+\t\t * Thus for+\t\t *      b := (2*a)^((p-5)/8),+\t\t *      i := (2*a)*b^2+\t\t * we have+\t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2)+\t\t *         = (2*a)^((p-1)/2)+\t\t *         = -1;+\t\t * so if we set+\t\t *      x := a*b*(i-1),+\t\t * then+\t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+\t\t *         = a^2 * b^2 * (-2*i)+\t\t *         = a*(-i)*(2*a*b^2)+\t\t *         = a*(-i)*i+\t\t *         = a.+\t\t *+\t\t * (This is due to A.O.L. Atkin, +\t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+\t\t * November 1992.)+\t\t */++\t\t/* make sure that  a  is reduced modulo p */+\t\tif (a->neg || BN_ucmp(a, p) >= 0)+\t\t\t{+\t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end;+\t\t\ta = x; /* use x as temporary variable */+\t\t\t}++\t\t/* t := 2*a */+\t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;++\t\t/* b := (2*a)^((p-5)/8) */+\t\tif (!BN_rshift(q, p, 3)) goto end;+\t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end;++\t\t/* y := b^2 */+\t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end;++\t\t/* t := (2*a)*b^2 - 1*/+\t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;+\t\tif (!BN_sub_word(t, 1)) goto end; /* cannot become negative */++\t\t/* x = a*b*t */+\t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;++\t\tif (!BN_copy(ret, x)) goto end;+\t\terr = 0;+\t\tgoto end;+\t\t}+\t+\t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-06 12:25:33+00:00",
            "commit_hash": "bac685417a0890642bada45bfaf1e44de9c92beb",
            "message": "Faster BN_mod_sqrt algorithm for p == 5 (8)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,236 +60,236 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2. \t\t */ \t\tif (!BN_add_word(q,1)) goto end; \t\tif (!BN_rshift1(q,q)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 1, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */-\ti = 1;+\ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */-\t\tif (i < 20)+\t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t}-\twhile (r == 1 && i++ < 80);+\twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-11-30 09:45:26+00:00",
            "commit_hash": "25439b76adb66fe0ce6e012a9af1e1ce969a1479",
            "message": "Move reduction step from BN_mod_exp to BN_mod_exp_mont_word.\nFix BN_mod_exp_simple for a==0 (mod m).\nSkip useless round in BN_mod_sqrt (1 is always a square, no need\nto test BN_kronecker for it)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -1,1 +60,236 @@-XXX+++BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) +/* Returns 'ret' such that+ *      ret^2 == a (mod p),+ * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course+ * in Algebraic Computational Number Theory\", algorithm 1.5.1).+ * 'p' must be prime!+ */+\t{+\tBIGNUM *ret = in;+\tint err = 1;+\tint r;+\tBIGNUM *b, *q, *t, *x, *y;+\tint e, i, j;+\t+\tif (!BN_is_odd(p) || BN_abs_is_word(p, 1))+\t\t{+\t\tif (BN_abs_is_word(p, 2))+\t\t\t{+\t\t\tif (ret == NULL)+\t\t\t\tret = BN_new();+\t\t\tif (ret == NULL)+\t\t\t\tgoto end;+\t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0)))+\t\t\t\t{+\t\t\t\tBN_free(ret);+\t\t\t\treturn NULL;+\t\t\t\t}+\t\t\treturn ret;+\t\t\t}++\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\treturn(NULL);+\t\t}++#if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */+\tr = BN_kronecker(a, p, ctx);+\tif (r < -1) return NULL;+\tif (r == -1)+\t\t{+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);+\t\treturn(NULL);+\t\t}+#endif++\tBN_CTX_start(ctx);+\tb = BN_CTX_get(ctx);+\tq = BN_CTX_get(ctx);+\tt = BN_CTX_get(ctx);+\tx = BN_CTX_get(ctx);+\ty = BN_CTX_get(ctx);+\tif (y == NULL) goto end;+\t+\tif (ret == NULL)+\t\tret = BN_new();+\tif (ret == NULL) goto end;++\t/* now write  |p| - 1  as  2^e*q  where  q  is odd */+\te = 1;+\twhile (!BN_is_bit_set(p, e))+\t\te++;+\tif (!BN_rshift(q, p, e)) goto end;+\tq->neg = 0;++\tif (e == 1)+\t\t{+\t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse+\t\t * modulo  (p-1)/2,  and square roots can be computed+\t\t * directly by modular exponentiation.+\t\t * We have+\t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),+\t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2.+\t\t */+\t\tif (!BN_add_word(q,1)) goto end;+\t\tif (!BN_rshift1(q,q)) goto end;+\t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end;+\t\terr = 0;+\t\tgoto end;+\t\t}+\t+\t/* e > 1, so we really have to use the Tonelli/Shanks algorithm.+\t * First, find some  y  that is not a square. */+\ti = 1;+\tdo+\t\t{+\t\t/* For efficiency, try small numbers first;+\t\t * if this fails, try random numbers.+\t\t */+\t\tif (i < 20)+\t\t\t{+\t\t\tif (!BN_set_word(y, i)) goto end;+\t\t\t}+\t\telse+\t\t\t{+\t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end;+\t\t\tif (BN_ucmp(y, p) >= 0)+\t\t\t\t{+\t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end;+\t\t\t\t}+\t\t\t/* now 0 <= y < |p| */+\t\t\tif (BN_is_zero(y))+\t\t\t\tif (!BN_set_word(y, i)) goto end;+\t\t\t}+\t\t+\t\tr = BN_kronecker(y, p, ctx);+\t\tif (r < -1) goto end;+\t\tif (r == 0)+\t\t\t{+\t\t\t/* m divides p */+\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\t\tgoto end;+\t\t\t}+\t\t}+\twhile (r == 1 && i++ < 80);+\t+\tif (r != -1)+\t\t{+\t\t/* Many rounds and still no non-square -- this is more likely+\t\t * a bug than just bad luck.+\t\t * Even if  p  is not prime, we should have found some  y+\t\t * such that r == -1.+\t\t */+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);+\t\tgoto end;+\t\t}+++\t/* Now that we have some non-square, we can find an element+\t * of order  2^e  by computing its q'th power. */+\tif (!BN_mod_exp(y, y, q, p, ctx)) goto end;+\tif (BN_is_one(y))+\t\t{+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\tgoto end;+\t\t}++\t/* Now we know that (if  p  is indeed prime) there is an integer+\t * k,  0 <= k < 2^e,  such that+\t *+\t *      a^q * y^k == 1   (mod p).+\t *+\t * As  a^q  is a square and  y  is not,  k  must be even.+\t * q+1  is even, too, so there is an element+\t *+\t *     X := a^((q+1)/2) * y^(k/2),+\t *+\t * and it satisfies+\t *+\t *     X^2 = a^q * a     * y^k+\t *         = a,+\t *+\t * so it is the square root that we are looking for.+\t */+\t+\t/* t := (q-1)/2  (note that  q  is odd) */+\tif (!BN_rshift1(t, q)) goto end;+\t+\t/* x := a^((q-1)/2) */+\tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */+\t\t{+\t\tif (!BN_nnmod(t, a, p, ctx)) goto end;+\t\tif (BN_is_zero(t))+\t\t\t{+\t\t\t/* special case: a == 0  (mod p) */+\t\t\tif (!BN_zero(ret)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+\t\telse+\t\t\tif (!BN_one(x)) goto end;+\t\t}+\telse+\t\t{+\t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end;+\t\tif (BN_is_zero(x))+\t\t\t{+\t\t\t/* special case: a == 0  (mod p) */+\t\t\tif (!BN_zero(ret)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+\t\t}++\t/* b := a*x^2  (= a^q) */+\tif (!BN_mod_sqr(b, x, p, ctx)) goto end;+\tif (!BN_mod_mul(b, b, a, p, ctx)) goto end;+\t+\t/* x := a*x    (= a^((q+1)/2)) */+\tif (!BN_mod_mul(x, x, a, p, ctx)) goto end;++\twhile (1)+\t\t{+\t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E+\t\t * where  E  refers to the original value of  e,  which we+\t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).+\t\t *+\t\t * We have  a*b = x^2,+\t\t *    y^2^(e-1) = -1,+\t\t *    b^2^(e-1) = 1.+\t\t */++\t\tif (BN_is_one(b))+\t\t\t{+\t\t\tif (!BN_copy(ret, x)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+++\t\t/* find smallest  i  such that  b^(2^i) = 1 */+\t\ti = 1;+\t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end;+\t\twhile (!BN_is_one(t))+\t\t\t{+\t\t\ti++;+\t\t\tif (i == e)+\t\t\t\t{+\t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);+\t\t\t\tgoto end;+\t\t\t\t}+\t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end;+\t\t\t}+\t\t++\t\t/* t := y^2^(e - i - 1) */+\t\tif (!BN_copy(t, y)) goto end;+\t\tfor (j = e - i - 1; j > 0; j--)+\t\t\t{+\t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end;+\t\t\t}+\t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;+\t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end;+\t\te = i;+\t\t}",
            "commit_date": "2000-11-30 00:18:19+00:00",
            "commit_hash": "cd2eebfd6497ac1ca4d450960ba843f14643a9b2",
            "message": "BN_sqrt"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- /dev/null+++ b/crypto/bn/bn_sqrt.c@@ -0,0 +1,1 @@+XXX",
            "commit_date": "2000-11-28 06:37:43+00:00",
            "commit_hash": "265592b99a3c2d5a8134d2c684620113153b4e1e",
            "message": "Add bn_kron.c (BN_kronecker), which I forgot in the previous commit.\nAlso add the next file in advance so that I can't forget this one :-)"
        }
    ],
    "git log -L12,96:crypto/bn/bn_sqrt.c": [
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,84 +12,85 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number- * Theory\", algorithm 1.5.1). 'p' must be prime!+ * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or+ * an incorrect \"result\" will be returned.  */ {",
            "commit_date": "2022-02-28 18:26:21+01:00",
            "commit_hash": "9eafb53614bf65797db25f467946e735e1b43dc9",
            "message": "Fix possible infinite loop in BN_mod_sqrt()\nThe calculation in some cases does not finish for non-prime p.\nThis fixes CVE-2022-0778.\nBased on patch by David Benjamin <davidben@google.com>.\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nint used_ctx = 0;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nused_ctx = 1;\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))"
        },
        {
            "author": {
                "email": "agustingianni@gmail.com",
                "name": "Agustin Gianni"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,82 +12,84 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {+    int used_ctx = 0;+    used_ctx = 1;",
            "commit_date": "2021-01-08 16:04:05+01:00",
            "commit_hash": "48116c2d0fbb1db875e2bc703c08089bf3c5c5c3",
            "message": "Fix incorrect use of BN_CTX API\nIn some edge cases BN_CTX_end was being called without first calling\nBN_CTX_start. This creates a situation where the state of the big\nnumber allocator is corrupted and may lead to crashes.\nFixes #13812\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/13813)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,82 +12,82 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);",
            "commit_date": "2020-11-04 12:23:19+01:00",
            "commit_hash": "9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2",
            "message": "Convert all {NAME}err() in crypto/ to their corresponding ERR_raise() call\nThis includes error reporting for libcrypto sub-libraries in surprising\nplaces.\nThis was done using util/err-to-raise\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13318)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))"
        },
        {
            "author": {
                "email": "kunnpuu@gmail.com",
                "name": "KaoruToda"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,82 +12,82 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-        return (NULL);+        return NULL;",
            "commit_date": "2017-10-17 23:04:09+09:00",
            "commit_hash": "26a7d938c9bf932a55cb5e4e02abb48fe395c5cd",
            "message": "Remove parentheses of return.\nSince return is inconsistent, I removed unnecessary parentheses and\nunified them.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4541)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -62,82 +62,82 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-                /*--                 * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse-                 * modulo  (|p|-1)/2,  and square roots can be computed-                 * directly by modular exponentiation.-                 * We have-                 *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),-                 * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.-                 */+        /*-+         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+         * modulo  (|p|-1)/2,  and square roots can be computed+         * directly by modular exponentiation.+         * We have+         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.+         */",
            "commit_date": "2015-01-05 11:30:03+00:00",
            "commit_hash": "50e735f9e5d220cdad7db690188b82a69ddcb39e",
            "message": "Re-align some comments after running the reformat script.\nThis should be a one off operation (subsequent invokation of the\nscript should not move them)\nReviewed-by: Tim Hudson <tjh@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn (NULL);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\nif (!BN_rshift(q, p, 2))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,308 +62,82 @@--BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) -/* Returns 'ret' such that- *      ret^2 == a (mod p),- * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course- * in Algebraic Computational Number Theory\", algorithm 1.5.1).- * 'p' must be prime!+BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)+/*+ * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks+ * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number+ * Theory\", algorithm 1.5.1). 'p' must be prime!  */-\t{-\tBIGNUM *ret = in;-\tint err = 1;-\tint r;-\tBIGNUM *A, *b, *q, *t, *x, *y;-\tint e, i, j;-\t-\tif (!BN_is_odd(p) || BN_abs_is_word(p, 1))-\t\t{-\t\tif (BN_abs_is_word(p, 2))-\t\t\t{-\t\t\tif (ret == NULL)-\t\t\t\tret = BN_new();-\t\t\tif (ret == NULL)-\t\t\t\tgoto end;-\t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0)))-\t\t\t\t{-\t\t\t\tif (ret != in)-\t\t\t\t\tBN_free(ret);-\t\t\t\treturn NULL;-\t\t\t\t}-\t\t\tbn_check_top(ret);-\t\t\treturn ret;-\t\t\t}--\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\treturn(NULL);-\t\t}--\tif (BN_is_zero(a) || BN_is_one(a))-\t\t{-\t\tif (ret == NULL)-\t\t\tret = BN_new();-\t\tif (ret == NULL)-\t\t\tgoto end;-\t\tif (!BN_set_word(ret, BN_is_one(a)))-\t\t\t{-\t\t\tif (ret != in)-\t\t\t\tBN_free(ret);-\t\t\treturn NULL;-\t\t\t}-\t\tbn_check_top(ret);-\t\treturn ret;-\t\t}--\tBN_CTX_start(ctx);-\tA = BN_CTX_get(ctx);-\tb = BN_CTX_get(ctx);-\tq = BN_CTX_get(ctx);-\tt = BN_CTX_get(ctx);-\tx = BN_CTX_get(ctx);-\ty = BN_CTX_get(ctx);-\tif (y == NULL) goto end;-\t-\tif (ret == NULL)-\t\tret = BN_new();-\tif (ret == NULL) goto end;--\t/* A = a mod p */-\tif (!BN_nnmod(A, a, p, ctx)) goto end;--\t/* now write  |p| - 1  as  2^e*q  where  q  is odd */-\te = 1;-\twhile (!BN_is_bit_set(p, e))-\t\te++;-\t/* we'll set  q  later (if needed) */--\tif (e == 1)-\t\t{-\t\t/*--\t\t * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse-\t\t * modulo  (|p|-1)/2,  and square roots can be computed-\t\t * directly by modular exponentiation.-\t\t * We have-\t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),-\t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.-\t\t */-\t\tif (!BN_rshift(q, p, 2)) goto end;-\t\tq->neg = 0;-\t\tif (!BN_add_word(q, 1)) goto end;-\t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end;-\t\terr = 0;-\t\tgoto vrfy;-\t\t}-\t-\tif (e == 2)-\t\t{-\t\t/*--\t\t * |p| == 5  (mod 8)-\t\t *-\t\t * In this case  2  is always a non-square since-\t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.-\t\t * So if  a  really is a square, then  2*a  is a non-square.-\t\t * Thus for-\t\t *      b := (2*a)^((|p|-5)/8),-\t\t *      i := (2*a)*b^2-\t\t * we have-\t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)-\t\t *         = (2*a)^((p-1)/2)-\t\t *         = -1;-\t\t * so if we set-\t\t *      x := a*b*(i-1),-\t\t * then-\t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)-\t\t *         = a^2 * b^2 * (-2*i)-\t\t *         = a*(-i)*(2*a*b^2)-\t\t *         = a*(-i)*i-\t\t *         = a.-\t\t *-\t\t * (This is due to A.O.L. Atkin, -\t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,-\t\t * November 1992.)-\t\t */--\t\t/* t := 2*a */-\t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end;--\t\t/* b := (2*a)^((|p|-5)/8) */-\t\tif (!BN_rshift(q, p, 3)) goto end;-\t\tq->neg = 0;-\t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end;--\t\t/* y := b^2 */-\t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end;--\t\t/* t := (2*a)*b^2 - 1*/-\t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;-\t\tif (!BN_sub_word(t, 1)) goto end;--\t\t/* x = a*b*t */-\t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end;-\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;--\t\tif (!BN_copy(ret, x)) goto end;-\t\terr = 0;-\t\tgoto vrfy;-\t\t}-\t-\t/* e > 2, so we really have to use the Tonelli/Shanks algorithm.-\t * First, find some  y  that is not a square. */-\tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */-\tq->neg = 0;-\ti = 2;-\tdo-\t\t{-\t\t/* For efficiency, try small numbers first;-\t\t * if this fails, try random numbers.-\t\t */-\t\tif (i < 22)-\t\t\t{-\t\t\tif (!BN_set_word(y, i)) goto end;-\t\t\t}-\t\telse-\t\t\t{-\t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end;-\t\t\tif (BN_ucmp(y, p) >= 0)-\t\t\t\t{-\t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end;-\t\t\t\t}-\t\t\t/* now 0 <= y < |p| */-\t\t\tif (BN_is_zero(y))-\t\t\t\tif (!BN_set_word(y, i)) goto end;-\t\t\t}-\t\t-\t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */-\t\tif (r < -1) goto end;-\t\tif (r == 0)-\t\t\t{-\t\t\t/* m divides p */-\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\t\tgoto end;-\t\t\t}-\t\t}-\twhile (r == 1 && ++i < 82);-\t-\tif (r != -1)-\t\t{-\t\t/* Many rounds and still no non-square -- this is more likely-\t\t * a bug than just bad luck.-\t\t * Even if  p  is not prime, we should have found some  y-\t\t * such that r == -1.-\t\t */-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);-\t\tgoto end;-\t\t}--\t/* Here's our actual 'q': */-\tif (!BN_rshift(q, q, e)) goto end;--\t/* Now that we have some non-square, we can find an element-\t * of order  2^e  by computing its q'th power. */-\tif (!BN_mod_exp(y, y, q, p, ctx)) goto end;-\tif (BN_is_one(y))-\t\t{-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\tgoto end;-\t\t}--\t/*--\t * Now we know that (if  p  is indeed prime) there is an integer-\t * k,  0 <= k < 2^e,  such that-\t *-\t *      a^q * y^k == 1   (mod p).-\t *-\t * As  a^q  is a square and  y  is not,  k  must be even.-\t * q+1  is even, too, so there is an element-\t *-\t *     X := a^((q+1)/2) * y^(k/2),-\t *-\t * and it satisfies-\t *-\t *     X^2 = a^q * a     * y^k-\t *         = a,-\t *-\t * so it is the square root that we are looking for.-\t */-\t-\t/* t := (q-1)/2  (note that  q  is odd) */-\tif (!BN_rshift1(t, q)) goto end;-\t-\t/* x := a^((q-1)/2) */-\tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */-\t\t{-\t\tif (!BN_nnmod(t, A, p, ctx)) goto end;-\t\tif (BN_is_zero(t))-\t\t\t{-\t\t\t/* special case: a == 0  (mod p) */-\t\t\tBN_zero(ret);-\t\t\terr = 0;-\t\t\tgoto end;-\t\t\t}-\t\telse-\t\t\tif (!BN_one(x)) goto end;-\t\t}-\telse-\t\t{-\t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end;-\t\tif (BN_is_zero(x))-\t\t\t{-\t\t\t/* special case: a == 0  (mod p) */-\t\t\tBN_zero(ret);-\t\t\terr = 0;-\t\t\tgoto end;-\t\t\t}-\t\t}--\t/* b := a*x^2  (= a^q) */-\tif (!BN_mod_sqr(b, x, p, ctx)) goto end;-\tif (!BN_mod_mul(b, b, A, p, ctx)) goto end;-\t-\t/* x := a*x    (= a^((q+1)/2)) */-\tif (!BN_mod_mul(x, x, A, p, ctx)) goto end;--\twhile (1)-\t\t{-\t\t/*- -\t\t * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E-\t\t * where  E  refers to the original value of  e,  which we-\t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).-\t\t *-\t\t * We have  a*b = x^2,-\t\t *    y^2^(e-1) = -1,-\t\t *    b^2^(e-1) = 1.-\t\t */--\t\tif (BN_is_one(b))-\t\t\t{-\t\t\tif (!BN_copy(ret, x)) goto end;-\t\t\terr = 0;-\t\t\tgoto vrfy;-\t\t\t}---\t\t/* find smallest  i  such that  b^(2^i) = 1 */-\t\ti = 1;-\t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end;-\t\twhile (!BN_is_one(t))-\t\t\t{-\t\t\ti++;-\t\t\tif (i == e)-\t\t\t\t{-\t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);-\t\t\t\tgoto end;-\t\t\t\t}-\t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end;-\t\t\t}-\t\t--\t\t/* t := y^2^(e - i - 1) */-\t\tif (!BN_copy(t, y)) goto end;-\t\tfor (j = e - i - 1; j > 0; j--)-\t\t\t{-\t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end;-\t\t\t}-\t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end;-\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;-\t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end;-\t\te = i;-\t\t}+{+    BIGNUM *ret = in;+    int err = 1;+    int r;+    BIGNUM *A, *b, *q, *t, *x, *y;+    int e, i, j;++    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {+        if (BN_abs_is_word(p, 2)) {+            if (ret == NULL)+                ret = BN_new();+            if (ret == NULL)+                goto end;+            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {+                if (ret != in)+                    BN_free(ret);+                return NULL;+            }+            bn_check_top(ret);+            return ret;+        }++        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+        return (NULL);+    }++    if (BN_is_zero(a) || BN_is_one(a)) {+        if (ret == NULL)+            ret = BN_new();+        if (ret == NULL)+            goto end;+        if (!BN_set_word(ret, BN_is_one(a))) {+            if (ret != in)+                BN_free(ret);+            return NULL;+        }+        bn_check_top(ret);+        return ret;+    }++    BN_CTX_start(ctx);+    A = BN_CTX_get(ctx);+    b = BN_CTX_get(ctx);+    q = BN_CTX_get(ctx);+    t = BN_CTX_get(ctx);+    x = BN_CTX_get(ctx);+    y = BN_CTX_get(ctx);+    if (y == NULL)+        goto end;++    if (ret == NULL)+        ret = BN_new();+    if (ret == NULL)+        goto end;++    /* A = a mod p */+    if (!BN_nnmod(A, a, p, ctx))+        goto end;++    /* now write  |p| - 1  as  2^e*q  where  q  is odd */+    e = 1;+    while (!BN_is_bit_set(p, e))+        e++;+    /* we'll set  q  later (if needed) */++    if (e == 1) {+                /*-+                 * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+                 * modulo  (|p|-1)/2,  and square roots can be computed+                 * directly by modular exponentiation.+                 * We have+                 *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+                 * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.+                 */+        if (!BN_rshift(q, p, 2))",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "tjh@openssl.org",
                "name": "Tim Hudson"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,304 +60,308 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tif (ret != in) \t\t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tif (ret != in) \t\t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{-\t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+\t\t/*-+\t\t * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{-\t\t/* |p| == 5  (mod 8)+\t\t/*-+\t\t * |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t}-\t/* Now we know that (if  p  is indeed prime) there is an integer+\t/*-+\t * Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{-\t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E+\t\t/*- +\t\t * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2014-12-28 12:48:40+10:00",
            "commit_hash": "1d97c8435171a7af575f73c526d79e1ef0ee5960",
            "message": "mark all block comments that need format preserving so that\nindent will not alter them when reformatting comments\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,304 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{-\t\t\t\tBN_free(ret);+\t\t\t\tif (ret != in)+\t\t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{-\t\t\tBN_free(ret);+\t\t\tif (ret != in)+\t\t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2005-08-23 04:14:40+00:00",
            "commit_hash": "7534d131d676431f1299618dfe0decd1a42680bb",
            "message": "avoid potential spurious BN_free()\nSubmitted by: David Heine <dlheine@suif.Stanford.EDU>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */-\t\t\tif (!BN_zero(ret)) goto end;+\t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */-\t\t\tif (!BN_zero(ret)) goto end;+\t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2004-03-13 23:57:20+00:00",
            "commit_hash": "b6358c89a10128692875fb92921b663c4d079a1e",
            "message": "Convert openssl code not to assume the deprecated form of BN_zero().\nRemove certain redundant BN_zero() initialisations, because BN_CTX_get(),\nBN_init(), [etc] already initialise to zero.\nCorrect error checking in bn_sqr.c, and be less wishy-wash about how/why\nthe result's 'top' value is set (note also, 'max' is always > 0 at this\npoint)."
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,300 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t}+\t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t}+\t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2003-11-04 22:54:49+00:00",
            "commit_hash": "d870740cd75dd4f0cb66fb8c32653a7d47369706",
            "message": "Put the first stage of my bignum debugging adventures into CVS. This code\nis itself experimental, and in addition may cause execution to break on\nexisting openssl \"bugs\" that previously were harmless or at least\ninvisible."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,300 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!- * If 'a' is not a square, this is not necessarily detected by- * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 15:13:10+00:00",
            "commit_hash": "d3bcbba45c4f161d88e30fd8b0434e8e24202681",
            "message": "remove obsolete part of comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,312 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  * If 'a' is not a square, this is not necessarily detected by  * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t}-#if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */-\tr = BN_kronecker(a, p, ctx);-\tif (r < -1) return NULL;-\tif (r == -1)-\t\t{-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);-\t\treturn(NULL);-\t\t}-#endif- \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 15:07:08+00:00",
            "commit_hash": "0903e56196a1a265dd9397e1e09a22aa4766914e",
            "message": "remove obsoleted disabled code"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,315 +60,312 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  * If 'a' is not a square, this is not necessarily detected by  * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r;-\tBIGNUM *b, *q, *t, *x, *y;+\tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx);+\tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end;+\t/* A = a mod p */+\tif (!BN_nnmod(A, a, p, ctx)) goto end;+ \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end;-\t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end;+\t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0;-\t\tgoto end;+\t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */-\t\t/* make sure that  a  is reduced modulo p */-\t\tif (a->neg || BN_ucmp(a, p) >= 0)-\t\t\t{-\t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end;-\t\t\ta = x; /* use x as temporary variable */-\t\t\t}- \t\t/* t := 2*a */-\t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;+\t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */-\t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0;-\t\tgoto end;+\t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{-\t\tif (!BN_nnmod(t, a, p, ctx)) goto end;+\t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{-\t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end;+\t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end;-\tif (!BN_mod_mul(b, b, a, p, ctx)) goto end;+\tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */-\tif (!BN_mod_mul(x, x, a, p, ctx)) goto end;+\tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0;-\t\t\tgoto end;+\t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 14:57:53+00:00",
            "commit_hash": "6fb60a84dd1ec81953917e0444dab50186617432",
            "message": "Change BN_mod_sqrt() so that it verifies that the input value is\nreally the square of the return value."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,313 +60,315 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!+ * If 'a' is not a square, this is not necessarily detected by+ * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2001-03-08 16:53:30+00:00",
            "commit_hash": "ff612904d277b6e4f8118913e1278a1afc75e073",
            "message": "Comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,314 +60,313 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++;-\tif (e > 2)-\t\t{-\t\t/* we don't need this  q  if  e = 1 or 2 */-\t\tif (!BN_rshift(q, p, e)) goto end;-\t\tq->neg = 0;-\t\t}+\t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{-\t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse-\t\t * modulo  (p-1)/2,  and square roots can be computed+\t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+\t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have-\t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),-\t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1.+\t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+\t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{-\t\t/* p == 5  (mod 8)+\t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for-\t\t *      b := (2*a)^((p-5)/8),+\t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have-\t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2)+\t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;-\t\t/* b := (2*a)^((p-5)/8) */+\t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */+\tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */+\tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t}-\t\tr = BN_kronecker(y, p, ctx);+\t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t}+\t/* Here's our actual 'q': */+\tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-07 08:48:58+00:00",
            "commit_hash": "80d89e6a6aa6d9520336c78877c3cccb54c881cd",
            "message": "Sign-related fixes (and tests).\nBN_mod_exp_mont does not work properly yet if modulus m\nis negative (we want computations to be carried out\nmodulo |m|)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,310 +60,314 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (e > 2)+\t\t{ \t\t/* we don't need this  q  if  e = 1 or 2 */ \t\tif (!BN_rshift(q, p, e)) goto end;-\tq->neg = 0;+\t\tq->neg = 0;+\t\t} \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end;+\t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* p == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((p-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((p-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end;+\t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-07 07:55:26+00:00",
            "commit_hash": "bc5f2740d2a427d5e16bfb12aa8b70d5a5adcfc8",
            "message": "Move 'q->neg = 0' to those places where it is needed\n(just in cases someone uses a negative modulus)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,310 +60,310 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (e > 2) \t\t/* we don't need this  q  if  e = 1 or 2 */ \t\tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* p == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((p-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((p-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;-\t\tif (!BN_sub_word(t, 1)) goto end; /* cannot become negative */+\t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-06 21:33:58+00:00",
            "commit_hash": "aa66eba7c8c7496db92b80da19688d6f96a40b96",
            "message": "BN_mod_sqrt documentation/comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,236 +60,310 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t}+\tif (BN_is_zero(a) || BN_is_one(a))+\t\t{+\t\tif (ret == NULL)+\t\t\tret = BN_new();+\t\tif (ret == NULL)+\t\t\tgoto end;+\t\tif (!BN_set_word(ret, BN_is_one(a)))+\t\t\t{+\t\t\tBN_free(ret);+\t\t\treturn NULL;+\t\t\t}+\t\treturn ret;+\t\t}+ #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++;-\tif (!BN_rshift(q, p, e)) goto end;+\tif (e > 2)+\t\t/* we don't need this  q  if  e = 1 or 2 */+\t\tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),-\t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2.+\t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */-\t\tif (!BN_add_word(q,1)) goto end;-\t\tif (!BN_rshift1(q,q)) goto end;+\t\tif (!BN_rshift(q, p, 2)) goto end;+\t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t}-\t/* e > 1, so we really have to use the Tonelli/Shanks algorithm.+\tif (e == 2)+\t\t{+\t\t/* p == 5  (mod 8)+\t\t *+\t\t * In this case  2  is always a non-square since+\t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+\t\t * So if  a  really is a square, then  2*a  is a non-square.+\t\t * Thus for+\t\t *      b := (2*a)^((p-5)/8),+\t\t *      i := (2*a)*b^2+\t\t * we have+\t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2)+\t\t *         = (2*a)^((p-1)/2)+\t\t *         = -1;+\t\t * so if we set+\t\t *      x := a*b*(i-1),+\t\t * then+\t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+\t\t *         = a^2 * b^2 * (-2*i)+\t\t *         = a*(-i)*(2*a*b^2)+\t\t *         = a*(-i)*i+\t\t *         = a.+\t\t *+\t\t * (This is due to A.O.L. Atkin, +\t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+\t\t * November 1992.)+\t\t */++\t\t/* make sure that  a  is reduced modulo p */+\t\tif (a->neg || BN_ucmp(a, p) >= 0)+\t\t\t{+\t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end;+\t\t\ta = x; /* use x as temporary variable */+\t\t\t}++\t\t/* t := 2*a */+\t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;++\t\t/* b := (2*a)^((p-5)/8) */+\t\tif (!BN_rshift(q, p, 3)) goto end;+\t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end;++\t\t/* y := b^2 */+\t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end;++\t\t/* t := (2*a)*b^2 - 1*/+\t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;+\t\tif (!BN_sub_word(t, 1)) goto end; /* cannot become negative */++\t\t/* x = a*b*t */+\t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;++\t\tif (!BN_copy(ret, x)) goto end;+\t\terr = 0;+\t\tgoto end;+\t\t}+\t+\t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-06 12:25:33+00:00",
            "commit_hash": "bac685417a0890642bada45bfaf1e44de9c92beb",
            "message": "Faster BN_mod_sqrt algorithm for p == 5 (8)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,236 +60,236 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2. \t\t */ \t\tif (!BN_add_word(q,1)) goto end; \t\tif (!BN_rshift1(q,q)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 1, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */-\ti = 1;+\ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */-\t\tif (i < 20)+\t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t}-\twhile (r == 1 && i++ < 80);+\twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-11-30 09:45:26+00:00",
            "commit_hash": "25439b76adb66fe0ce6e012a9af1e1ce969a1479",
            "message": "Move reduction step from BN_mod_exp to BN_mod_exp_mont_word.\nFix BN_mod_exp_simple for a==0 (mod m).\nSkip useless round in BN_mod_sqrt (1 is always a square, no need\nto test BN_kronecker for it)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -1,1 +60,236 @@-XXX+++BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) +/* Returns 'ret' such that+ *      ret^2 == a (mod p),+ * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course+ * in Algebraic Computational Number Theory\", algorithm 1.5.1).+ * 'p' must be prime!+ */+\t{+\tBIGNUM *ret = in;+\tint err = 1;+\tint r;+\tBIGNUM *b, *q, *t, *x, *y;+\tint e, i, j;+\t+\tif (!BN_is_odd(p) || BN_abs_is_word(p, 1))+\t\t{+\t\tif (BN_abs_is_word(p, 2))+\t\t\t{+\t\t\tif (ret == NULL)+\t\t\t\tret = BN_new();+\t\t\tif (ret == NULL)+\t\t\t\tgoto end;+\t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0)))+\t\t\t\t{+\t\t\t\tBN_free(ret);+\t\t\t\treturn NULL;+\t\t\t\t}+\t\t\treturn ret;+\t\t\t}++\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\treturn(NULL);+\t\t}++#if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */+\tr = BN_kronecker(a, p, ctx);+\tif (r < -1) return NULL;+\tif (r == -1)+\t\t{+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);+\t\treturn(NULL);+\t\t}+#endif++\tBN_CTX_start(ctx);+\tb = BN_CTX_get(ctx);+\tq = BN_CTX_get(ctx);+\tt = BN_CTX_get(ctx);+\tx = BN_CTX_get(ctx);+\ty = BN_CTX_get(ctx);+\tif (y == NULL) goto end;+\t+\tif (ret == NULL)+\t\tret = BN_new();+\tif (ret == NULL) goto end;++\t/* now write  |p| - 1  as  2^e*q  where  q  is odd */+\te = 1;+\twhile (!BN_is_bit_set(p, e))+\t\te++;+\tif (!BN_rshift(q, p, e)) goto end;+\tq->neg = 0;++\tif (e == 1)+\t\t{+\t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse+\t\t * modulo  (p-1)/2,  and square roots can be computed+\t\t * directly by modular exponentiation.+\t\t * We have+\t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),+\t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2.+\t\t */+\t\tif (!BN_add_word(q,1)) goto end;+\t\tif (!BN_rshift1(q,q)) goto end;+\t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end;+\t\terr = 0;+\t\tgoto end;+\t\t}+\t+\t/* e > 1, so we really have to use the Tonelli/Shanks algorithm.+\t * First, find some  y  that is not a square. */+\ti = 1;+\tdo+\t\t{+\t\t/* For efficiency, try small numbers first;+\t\t * if this fails, try random numbers.+\t\t */+\t\tif (i < 20)+\t\t\t{+\t\t\tif (!BN_set_word(y, i)) goto end;+\t\t\t}+\t\telse+\t\t\t{+\t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end;+\t\t\tif (BN_ucmp(y, p) >= 0)+\t\t\t\t{+\t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end;+\t\t\t\t}+\t\t\t/* now 0 <= y < |p| */+\t\t\tif (BN_is_zero(y))+\t\t\t\tif (!BN_set_word(y, i)) goto end;+\t\t\t}+\t\t+\t\tr = BN_kronecker(y, p, ctx);+\t\tif (r < -1) goto end;+\t\tif (r == 0)+\t\t\t{+\t\t\t/* m divides p */+\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\t\tgoto end;+\t\t\t}+\t\t}+\twhile (r == 1 && i++ < 80);+\t+\tif (r != -1)+\t\t{+\t\t/* Many rounds and still no non-square -- this is more likely+\t\t * a bug than just bad luck.+\t\t * Even if  p  is not prime, we should have found some  y+\t\t * such that r == -1.+\t\t */+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);+\t\tgoto end;+\t\t}+++\t/* Now that we have some non-square, we can find an element+\t * of order  2^e  by computing its q'th power. */+\tif (!BN_mod_exp(y, y, q, p, ctx)) goto end;+\tif (BN_is_one(y))+\t\t{+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\tgoto end;+\t\t}++\t/* Now we know that (if  p  is indeed prime) there is an integer+\t * k,  0 <= k < 2^e,  such that+\t *+\t *      a^q * y^k == 1   (mod p).+\t *+\t * As  a^q  is a square and  y  is not,  k  must be even.+\t * q+1  is even, too, so there is an element+\t *+\t *     X := a^((q+1)/2) * y^(k/2),+\t *+\t * and it satisfies+\t *+\t *     X^2 = a^q * a     * y^k+\t *         = a,+\t *+\t * so it is the square root that we are looking for.+\t */+\t+\t/* t := (q-1)/2  (note that  q  is odd) */+\tif (!BN_rshift1(t, q)) goto end;+\t+\t/* x := a^((q-1)/2) */+\tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */+\t\t{+\t\tif (!BN_nnmod(t, a, p, ctx)) goto end;+\t\tif (BN_is_zero(t))+\t\t\t{+\t\t\t/* special case: a == 0  (mod p) */+\t\t\tif (!BN_zero(ret)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+\t\telse+\t\t\tif (!BN_one(x)) goto end;+\t\t}+\telse+\t\t{+\t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end;+\t\tif (BN_is_zero(x))+\t\t\t{+\t\t\t/* special case: a == 0  (mod p) */+\t\t\tif (!BN_zero(ret)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+\t\t}++\t/* b := a*x^2  (= a^q) */+\tif (!BN_mod_sqr(b, x, p, ctx)) goto end;+\tif (!BN_mod_mul(b, b, a, p, ctx)) goto end;+\t+\t/* x := a*x    (= a^((q+1)/2)) */+\tif (!BN_mod_mul(x, x, a, p, ctx)) goto end;++\twhile (1)+\t\t{+\t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E+\t\t * where  E  refers to the original value of  e,  which we+\t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).+\t\t *+\t\t * We have  a*b = x^2,+\t\t *    y^2^(e-1) = -1,+\t\t *    b^2^(e-1) = 1.+\t\t */++\t\tif (BN_is_one(b))+\t\t\t{+\t\t\tif (!BN_copy(ret, x)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+++\t\t/* find smallest  i  such that  b^(2^i) = 1 */+\t\ti = 1;+\t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end;+\t\twhile (!BN_is_one(t))+\t\t\t{+\t\t\ti++;+\t\t\tif (i == e)+\t\t\t\t{+\t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);+\t\t\t\tgoto end;+\t\t\t\t}+\t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end;+\t\t\t}+\t\t++\t\t/* t := y^2^(e - i - 1) */+\t\tif (!BN_copy(t, y)) goto end;+\t\tfor (j = e - i - 1; j > 0; j--)+\t\t\t{+\t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end;+\t\t\t}+\t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;+\t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end;+\t\te = i;+\t\t}",
            "commit_date": "2000-11-30 00:18:19+00:00",
            "commit_hash": "cd2eebfd6497ac1ca4d450960ba843f14643a9b2",
            "message": "BN_sqrt"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- /dev/null+++ b/crypto/bn/bn_sqrt.c@@ -0,0 +1,1 @@+XXX",
            "commit_date": "2000-11-28 06:37:43+00:00",
            "commit_hash": "265592b99a3c2d5a8134d2c684620113153b4e1e",
            "message": "Add bn_kron.c (BN_kronecker), which I forgot in the previous commit.\nAlso add the next file in advance so that I can't forget this one :-)"
        }
    ],
    "git log -L12,35:crypto/bn/bn_word.c": [
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_word.c b/crypto/bn/bn_word.c--- a/crypto/bn/bn_word.c+++ b/crypto/bn/bn_word.c@@ -12,13 +12,24 @@ BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w) { #ifndef BN_LLONG #else #endif+#ifndef BN_LLONG+    /*+     * If |w| is too long and we don't have BN_ULLONG then we need to fall+     * back to using BN_div_word+     */+    if (w > ((BN_ULONG)1 << BN_BITS4)) {+        BIGNUM *tmp = BN_dup(a);+        if (tmp == NULL)+            return (BN_ULONG)-1;++        ret = BN_div_word(tmp, w);",
            "commit_date": "2016-05-31 11:28:14+01:00",
            "commit_hash": "37258dadaa9e36db4b96a3aa54aa6c67136160cc",
            "message": "Fix BN_mod_word bug\nOn systems where we do not have BN_ULLONG (e.g. typically 64 bit systems)\nthen BN_mod_word() can return incorrect results if the supplied modulus is\ntoo big.\nRT#4501\nReviewed-by: Andy Polyakov <appro@openssl.org>\nBN_ULONG ret = 0;\nBN_ULLONG ret = 0;\nint i;\nif (w == 0)\nreturn (BN_ULONG)-1;"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_word.c b/crypto/bn/bn_word.c--- a/crypto/bn/bn_word.c+++ b/crypto/bn/bn_word.c@@ -61,13 +61,13 @@ BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w)-\t{+{ #ifndef BN_LLONG-\tBN_ULONG ret=0;+    BN_ULONG ret = 0; #else-\tBN_ULLONG ret=0;+    BN_ULLONG ret = 0; #endif-\tint i;+    int i;-\tif (w == 0)-\t\treturn (BN_ULONG)-1;+    if (w == 0)+        return (BN_ULONG)-1;",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "nils@openssl.org",
                "name": "Nils Larsch"
            },
            "changes": "diff --git a/crypto/bn/bn_word.c b/crypto/bn/bn_word.c--- a/crypto/bn/bn_word.c+++ b/crypto/bn/bn_word.c@@ -62,10 +62,13 @@ BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w) \t{ #ifndef BN_LLONG \tBN_ULONG ret=0; #else \tBN_ULLONG ret=0; #endif \tint i;+\tif (w == 0)+\t\treturn (BN_ULONG)-1;+",
            "commit_date": "2005-07-25 22:57:54+00:00",
            "commit_hash": "0260405c6861ebe27a960b098d4a7da739e535ec",
            "message": "fix BN_mod_word and give a more reasonable return value if an error occurred"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_word.c b/crypto/bn/bn_word.c--- a/crypto/bn/bn_word.c+++ b/crypto/bn/bn_word.c@@ -62,10 +62,10 @@-BN_ULONG BN_mod_word(BIGNUM *a, BN_ULONG w)+BN_ULONG BN_mod_word(const BIGNUM *a, BN_ULONG w) \t{ #ifndef BN_LLONG \tBN_ULONG ret=0; #else \tBN_ULLONG ret=0; #endif \tint i;",
            "commit_date": "2000-02-03 01:26:07+00:00",
            "commit_hash": "7999c65c9bfd80ec0f07f6eb5be5ce2e36927298",
            "message": "Some 'const's for BNs."
        },
        {
            "author": {
                "email": "ulf@openssl.org",
                "name": "Ulf M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_word.c b/crypto/bn/bn_word.c--- a/crypto/bn/bn_word.c+++ b/crypto/bn/bn_word.c@@ -62,12 +62,10 @@-BN_ULONG BN_mod_word(a, w)-BIGNUM *a;-BN_ULONG w;+BN_ULONG BN_mod_word(BIGNUM *a, BN_ULONG w) \t{ #ifndef BN_LLONG \tBN_ULONG ret=0; #else \tBN_ULLONG ret=0; #endif \tint i;",
            "commit_date": "1999-04-19 21:31:43+00:00",
            "commit_hash": "6b691a5c85ddc4e407e32781841fee5c029506cd",
            "message": "Change functions to ANSI C."
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bn/bn_word.c b/crypto/bn/bn_word.c--- a/crypto/bn/bn_word.c+++ b/crypto/bn/bn_word.c@@ -62,12 +62,12 @@ BN_ULONG BN_mod_word(a, w) BIGNUM *a;-unsigned long w;+BN_ULONG w; \t{ #ifndef BN_LLONG \tBN_ULONG ret=0; #else \tBN_ULLONG ret=0; #endif \tint i;",
            "commit_date": "1998-12-21 11:00:56+00:00",
            "commit_hash": "dfeab0689f69c0b4bd3480ffd37a9cacc2f17d9c",
            "message": "Import of old SSLeay release: SSLeay 0.9.1b (unreleased)"
        },
        {
            "author": {
                "email": "rse@openssl.org",
                "name": "Ralf S. Engelschall"
            },
            "changes": "diff --git a/crypto/bn/bn_word.c b/crypto/bn/bn_word.c--- /dev/null+++ b/crypto/bn/bn_word.c@@ -0,0 +62,12 @@++BN_ULONG BN_mod_word(a, w)+BIGNUM *a;+unsigned long w;+\t{+#ifndef BN_LLONG+\tBN_ULONG ret=0;+#else+\tBN_ULLONG ret=0;+#endif+\tint i;+",
            "commit_date": "1998-12-21 10:52:47+00:00",
            "commit_hash": "d02b48c63a58ea4367a0e905979f140b7d090f86",
            "message": "Import of old SSLeay release: SSLeay 0.8.1b"
        }
    ],
    "git log -L18,45:test/param_build_test.c": [
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/param_build_test.c b/test/param_build_test.c--- a/test/param_build_test.c+++ b/test/param_build_test.c@@ -18,25 +18,28 @@ static int template_public_test(int tstid) {-    BIGNUM *bn = NULL, *bn_res = NULL;+    BIGNUM *pbn = NULL, *pbn_res = NULL;+    BIGNUM *nbn = NULL, *nbn_res = NULL;-        || !TEST_ptr(bn = BN_new())-        || !TEST_true(BN_set_word(bn, 1729))-        || !TEST_true(OSSL_PARAM_BLD_push_BN(bld, \"bignumber\", bn))+        || !TEST_ptr(pbn = BN_new())+        || !TEST_true(BN_set_word(pbn, 1729))+        || !TEST_true(OSSL_PARAM_BLD_push_BN(bld, \"bignumber\", pbn))+        || !TEST_ptr(nbn = BN_secure_new())+        || !TEST_true(BN_set_word(nbn, 1733))",
            "commit_date": "2021-11-28 18:03:40+01:00",
            "commit_hash": "748a2967ffd52cf86696582fb1074d513493f469",
            "message": "TEST: Add addition OSSL_PARAM tests for signed BIGNUMs\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/17162)\nOSSL_PARAM_BLD *bld = OSSL_PARAM_BLD_new();\nOSSL_PARAM *params = NULL, *params_blt = NULL, *p1 = NULL, *p;\nint i;\nlong int l;\nint32_t i32;\nint64_t i64;\ndouble d;\ntime_t t;\nchar *utf = NULL;\nconst char *cutf;\nint res = 0;\nif (!TEST_ptr(bld)\n|| !TEST_true(OSSL_PARAM_BLD_push_long(bld, \"l\", 42))\n|| !TEST_true(OSSL_PARAM_BLD_push_int32(bld, \"i32\", 1532))\n|| !TEST_true(OSSL_PARAM_BLD_push_int64(bld, \"i64\", -9999999))\n|| !TEST_true(OSSL_PARAM_BLD_push_time_t(bld, \"t\", 11224))\n|| !TEST_true(OSSL_PARAM_BLD_push_double(bld, \"d\", 1.61803398875))"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/test/param_build_test.c b/test/param_build_test.c--- a/test/param_build_test.c+++ b/test/param_build_test.c@@ -17,25 +18,25 @@-static int template_public_test(void)++static int template_public_test(int tstid) {-    OSSL_PARAM *params = NULL, *p;+    OSSL_PARAM *params = NULL, *params_blt = NULL, *p1 = NULL, *p;-        || !TEST_true(OSSL_PARAM_BLD_push_int(bld, \"i\", -6))",
            "commit_date": "2021-04-07 11:27:18+10:00",
            "commit_hash": "884314cab786a980189206b2cab5f62878a97669",
            "message": "Add OSSL_PARAM_dup() and OSSL_PARAM_merge().\nThese functions are prerequisites for implementing EVP_PKEY_todata().\nOSSL_PARAM_dup() is required to make a deep copy of the exported\nparams (since the provider export() uses a OSSL_PARAM_BLD which throws away the\ndata after the call), and then use OSSL_PARAM_merge() to add some additional params\nthat can be passed to the EVP_PKEY_todata().\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14785)\nOSSL_PARAM_BLD *bld = OSSL_PARAM_BLD_new();\nBIGNUM *bn = NULL, *bn_res = NULL;\nint i;\nlong int l;\nint32_t i32;\nint64_t i64;\ndouble d;\ntime_t t;\nchar *utf = NULL;\nconst char *cutf;\nint res = 0;\nif (!TEST_ptr(bld)\n|| !TEST_true(OSSL_PARAM_BLD_push_long(bld, \"l\", 42))\n|| !TEST_true(OSSL_PARAM_BLD_push_int32(bld, \"i32\", 1532))\n|| !TEST_true(OSSL_PARAM_BLD_push_int64(bld, \"i64\", -9999999))\n|| !TEST_true(OSSL_PARAM_BLD_push_time_t(bld, \"t\", 11224))\n|| !TEST_true(OSSL_PARAM_BLD_push_double(bld, \"d\", 1.61803398875))\n|| !TEST_ptr(bn = BN_new())\n|| !TEST_true(BN_set_word(bn, 1729))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, \"bignumber\", bn))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/param_build_test.c b/test/param_build_test.c--- a/test/param_build_test.c+++ b/test/param_build_test.c@@ -17,23 +17,25 @@ static int template_public_test(void) {+    time_t t;+        || !TEST_true(OSSL_PARAM_BLD_push_time_t(bld, \"t\", 11224))",
            "commit_date": "2020-05-11 09:37:45+10:00",
            "commit_hash": "5fdaa38febb7463dbd44f849b2930edcbd5f6bae",
            "message": "params: add OSSL_PARAM helpers for time_t.\nPOSIX mandates that time_t is a signed integer but it doesn't specify the\nlenght.  Having wrappers lets uses ignore this.\nReviewed-by: Matthias St. Pierre <Matthias.St.Pierre@ncp-e.com>\n(Merged from https://github.com/openssl/openssl/pull/11682)\nOSSL_PARAM_BLD *bld = OSSL_PARAM_BLD_new();\nOSSL_PARAM *params = NULL, *p;\nBIGNUM *bn = NULL, *bn_res = NULL;\nint i;\nlong int l;\nint32_t i32;\nint64_t i64;\ndouble d;\nchar *utf = NULL;\nconst char *cutf;\nint res = 0;\nif (!TEST_ptr(bld)\n|| !TEST_true(OSSL_PARAM_BLD_push_int(bld, \"i\", -6))\n|| !TEST_true(OSSL_PARAM_BLD_push_long(bld, \"l\", 42))\n|| !TEST_true(OSSL_PARAM_BLD_push_int32(bld, \"i32\", 1532))\n|| !TEST_true(OSSL_PARAM_BLD_push_int64(bld, \"i64\", -9999999))\n|| !TEST_true(OSSL_PARAM_BLD_push_double(bld, \"d\", 1.61803398875))\n|| !TEST_ptr(bn = BN_new())\n|| !TEST_true(BN_set_word(bn, 1729))\n|| !TEST_true(OSSL_PARAM_BLD_push_BN(bld, \"bignumber\", bn))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/param_build_test.c b/test/param_build_test.c--- a/test/param_build_test.c+++ b/test/param_build_test.c@@ -17,24 +17,23 @@ static int template_public_test(void) {-    OSSL_PARAM_BLD bld;+    OSSL_PARAM_BLD *bld = OSSL_PARAM_BLD_new();-    OSSL_PARAM_BLD_init(&bld);-    if (!TEST_true(OSSL_PARAM_BLD_push_int(&bld, \"i\", -6))-        || !TEST_true(OSSL_PARAM_BLD_push_long(&bld, \"l\", 42))-        || !TEST_true(OSSL_PARAM_BLD_push_int32(&bld, \"i32\", 1532))-        || !TEST_true(OSSL_PARAM_BLD_push_int64(&bld, \"i64\", -9999999))-        || !TEST_true(OSSL_PARAM_BLD_push_double(&bld, \"d\", 1.61803398875))+    if (!TEST_ptr(bld)+        || !TEST_true(OSSL_PARAM_BLD_push_int(bld, \"i\", -6))+        || !TEST_true(OSSL_PARAM_BLD_push_long(bld, \"l\", 42))+        || !TEST_true(OSSL_PARAM_BLD_push_int32(bld, \"i32\", 1532))+        || !TEST_true(OSSL_PARAM_BLD_push_int64(bld, \"i64\", -9999999))+        || !TEST_true(OSSL_PARAM_BLD_push_double(bld, \"d\", 1.61803398875))-        || !TEST_true(OSSL_PARAM_BLD_push_BN(&bld, \"bignumber\", bn))-        || !TEST_true(OSSL_PARAM_BLD_push_utf8_string(&bld, \"utf8_s\", \"foo\",+        || !TEST_true(OSSL_PARAM_BLD_push_BN(bld, \"bignumber\", bn))",
            "commit_date": "2020-03-26 09:28:01+10:00",
            "commit_hash": "6d4e6009d27712a405e1e3a4c33fb8a8566f134a",
            "message": "Param build: make structures opaque.\nSince this is public, it is best to make the underlying structure opaque.\nThis means converting from stack allocation to dynamic allocation for all\nusages.\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\n(Merged from https://github.com/openssl/openssl/pull/11390)\nOSSL_PARAM *params = NULL, *p;\nBIGNUM *bn = NULL, *bn_res = NULL;\nint i;\nlong int l;\nint32_t i32;\nint64_t i64;\ndouble d;\nchar *utf = NULL;\nconst char *cutf;\nint res = 0;\n|| !TEST_ptr(bn = BN_new())\n|| !TEST_true(BN_set_word(bn, 1729))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/param_build_test.c b/test/param_build_test.c--- a/test/param_build_test.c+++ b/test/param_build_test.c@@ -17,24 +17,24 @@ static int template_public_test(void) {-    ossl_param_bld_init(&bld);-    if (!TEST_true(ossl_param_bld_push_int(&bld, \"i\", -6))-        || !TEST_true(ossl_param_bld_push_long(&bld, \"l\", 42))-        || !TEST_true(ossl_param_bld_push_int32(&bld, \"i32\", 1532))-        || !TEST_true(ossl_param_bld_push_int64(&bld, \"i64\", -9999999))-        || !TEST_true(ossl_param_bld_push_double(&bld, \"d\", 1.61803398875))+    OSSL_PARAM_BLD_init(&bld);+    if (!TEST_true(OSSL_PARAM_BLD_push_int(&bld, \"i\", -6))+        || !TEST_true(OSSL_PARAM_BLD_push_long(&bld, \"l\", 42))+        || !TEST_true(OSSL_PARAM_BLD_push_int32(&bld, \"i32\", 1532))+        || !TEST_true(OSSL_PARAM_BLD_push_int64(&bld, \"i64\", -9999999))+        || !TEST_true(OSSL_PARAM_BLD_push_double(&bld, \"d\", 1.61803398875))-        || !TEST_true(ossl_param_bld_push_BN(&bld, \"bignumber\", bn))-        || !TEST_true(ossl_param_bld_push_utf8_string(&bld, \"utf8_s\", \"foo\",+        || !TEST_true(OSSL_PARAM_BLD_push_BN(&bld, \"bignumber\", bn))+        || !TEST_true(OSSL_PARAM_BLD_push_utf8_string(&bld, \"utf8_s\", \"foo\",",
            "commit_date": "2020-03-24 14:58:57+10:00",
            "commit_hash": "110bff618b5bd3c700f2f0a290612ca642672ce6",
            "message": "Param builder: make the OSSL_PARAM_BLD APIs public.\nThe catalyst for this is the difficult of passing BNs through the other\nOSSL_PARAM APIs.\nReviewed-by: Nicola Tuveri <nic.tuv@gmail.com>\n(Merged from https://github.com/openssl/openssl/pull/11390)\nOSSL_PARAM_BLD bld;\nOSSL_PARAM *params = NULL, *p;\nBIGNUM *bn = NULL, *bn_res = NULL;\nint i;\nlong int l;\nint32_t i32;\nint64_t i64;\ndouble d;\nchar *utf = NULL;\nconst char *cutf;\nint res = 0;\n|| !TEST_ptr(bn = BN_new())\n|| !TEST_true(BN_set_word(bn, 1729))"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/param_build_test.c b/test/param_build_test.c--- a/test/param_build_test.c+++ b/test/param_build_test.c@@ -17,21 +17,24 @@ static int template_public_test(void) {-    void *secure = (void *)\"abc\";+    BIGNUM *bn = NULL, *bn_res = NULL;+        || !TEST_ptr(bn = BN_new())+        || !TEST_true(BN_set_word(bn, 1729))+        || !TEST_true(ossl_param_bld_push_BN(&bld, \"bignumber\", bn))",
            "commit_date": "2019-07-19 01:14:07+10:00",
            "commit_hash": "7312ef3fc4a7d391272f3ba8075eabf81a229ad2",
            "message": "Add param builder free function.\nThis means include deallocation information in the return from\nthe ossl_param_bld_to_param function.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9404)\nOSSL_PARAM_BLD bld;\nOSSL_PARAM *params = NULL, *p;\nint i;\nlong int l;\nint32_t i32;\nint64_t i64;\ndouble d;\nchar *utf = NULL;\nconst char *cutf;\nint res = 0;\nossl_param_bld_init(&bld);\nif (!TEST_true(ossl_param_bld_push_int(&bld, \"i\", -6))\n|| !TEST_true(ossl_param_bld_push_long(&bld, \"l\", 42))\n|| !TEST_true(ossl_param_bld_push_int32(&bld, \"i32\", 1532))\n|| !TEST_true(ossl_param_bld_push_int64(&bld, \"i64\", -9999999))\n|| !TEST_true(ossl_param_bld_push_double(&bld, \"d\", 1.61803398875))\n|| !TEST_true(ossl_param_bld_push_utf8_string(&bld, \"utf8_s\", \"foo\","
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/param_build_test.c b/test/param_build_test.c--- /dev/null+++ b/test/param_build_test.c@@ -0,0 +17,21 @@+static int template_public_test(void)+{+    OSSL_PARAM_BLD bld;+    OSSL_PARAM *params = NULL, *p;+    void *secure = (void *)\"abc\";+    int i;+    long int l;+    int32_t i32;+    int64_t i64;+    double d;+    char *utf = NULL;+    const char *cutf;+    int res = 0;++    ossl_param_bld_init(&bld);+    if (!TEST_true(ossl_param_bld_push_int(&bld, \"i\", -6))+        || !TEST_true(ossl_param_bld_push_long(&bld, \"l\", 42))+        || !TEST_true(ossl_param_bld_push_int32(&bld, \"i32\", 1532))+        || !TEST_true(ossl_param_bld_push_int64(&bld, \"i64\", -9999999))+        || !TEST_true(ossl_param_bld_push_double(&bld, \"d\", 1.61803398875))+        || !TEST_true(ossl_param_bld_push_utf8_string(&bld, \"utf8_s\", \"foo\",",
            "commit_date": "2019-07-17 16:59:09+10:00",
            "commit_hash": "3c93fbacf6f5abd63e1d1763e7da537ed87f2a5d",
            "message": "Parameter building utilities.\nA fuller implementation of PARAMS_TEMPLATE as per #9266 but renamed.\nThis introduces a statis data type which can be used to constructor a\ndescription of a parameter array.  It can then be converted into a OSSL_PARAM\narray and the allocated storage freed by a single call to OPENSSL_free.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/9305)"
        }
    ],
    "git log -L18,52:crypto/ffc/ffc_key_validate.c": [
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/crypto/ffc/ffc_key_validate.c b/crypto/ffc/ffc_key_validate.c--- a/crypto/ffc/ffc_key_validate.c+++ b/crypto/ffc/ffc_key_validate.c@@ -18,35 +18,35 @@  */-int ffc_validate_public_key_partial(const FFC_PARAMS *params,-                                    const BIGNUM *pub_key, int *ret)+int ossl_ffc_validate_public_key_partial(const FFC_PARAMS *params,+                                         const BIGNUM *pub_key, int *ret) {  err:",
            "commit_date": "2020-09-30 15:07:24+10:00",
            "commit_hash": "5357c10624bedaeed984ef4ff370096911ee2ddf",
            "message": "ffc: add _ossl to exported but internal functions\nThe functions updated are:\nffc_generate_private_key, ffc_named_group_from_uid,\nffc_named_group_to_uid, ffc_params_FIPS186_2_gen_verify,\nffc_params_FIPS186_2_generate, ffc_params_FIPS186_2_validate,\nffc_params_FIPS186_4_gen_verify, ffc_params_FIPS186_4_generate,\nffc_params_FIPS186_4_validate, ffc_params_cleanup, ffc_params_cmp,\nffc_params_copy, ffc_params_enable_flags, ffc_params_flags_from_name,\nffc_params_flags_to_name, ffc_params_fromdata,\nffc_params_get0_pqg, ffc_params_get_validate_params,\nffc_params_init, ffc_params_print, ffc_params_set0_j,\nffc_params_set0_pqg, ffc_params_set_flags, ffc_params_set_gindex,\nffc_params_set_h, ffc_params_set_pcounter, ffc_params_set_seed,\nffc_params_set_validate_params, ffc_params_simple_validate,\nffc_params_todata, ffc_params_validate_unverifiable_g, ffc_set_digest,\nffc_set_group_pqg, ffc_validate_private_key, ffc_validate_public_key\nand ffc_validate_public_key_partial.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13041)\nint ok = 0;\nBIGNUM *tmp = NULL;\nBN_CTX *ctx = NULL;\n*ret = 0;\nctx = BN_CTX_new_ex(NULL);\nif (ctx == NULL)\ngoto err;\nBN_CTX_start(ctx);\ntmp = BN_CTX_get(ctx);\n/* Step(1): Verify pub_key >= 2 */\nif (tmp == NULL\n|| !BN_set_word(tmp, 1))\ngoto err;\nif (BN_cmp(pub_key, tmp) <= 0) {\n*ret |= FFC_ERROR_PUBKEY_TOO_SMALL;\ngoto err;\n}\n/* Step(1): Verify pub_key <=  p-2 */\nif (BN_copy(tmp, params->p) == NULL\n|| !BN_sub_word(tmp, 1))\ngoto err;\nif (BN_cmp(pub_key, tmp) >= 0) {\n*ret |= FFC_ERROR_PUBKEY_TOO_LARGE;\ngoto err;\n}\nok = 1;\nif (ctx != NULL) {\nBN_CTX_end(ctx);"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/crypto/ffc/ffc_key_validate.c b/crypto/ffc/ffc_key_validate.c--- /dev/null+++ b/crypto/ffc/ffc_key_validate.c@@ -0,0 +18,35 @@+ */+int ffc_validate_public_key_partial(const FFC_PARAMS *params,+                                    const BIGNUM *pub_key, int *ret)+{+    int ok = 0;+    BIGNUM *tmp = NULL;+    BN_CTX *ctx = NULL;++    *ret = 0;+    ctx = BN_CTX_new_ex(NULL);+    if (ctx == NULL)+        goto err;++    BN_CTX_start(ctx);+    tmp = BN_CTX_get(ctx);+    /* Step(1): Verify pub_key >= 2 */+    if (tmp == NULL+        || !BN_set_word(tmp, 1))+        goto err;+    if (BN_cmp(pub_key, tmp) <= 0) {+        *ret |= FFC_ERROR_PUBKEY_TOO_SMALL;+        goto err;+    }+    /* Step(1): Verify pub_key <=  p-2 */+    if (BN_copy(tmp, params->p) == NULL+        || !BN_sub_word(tmp, 1))+        goto err;+    if (BN_cmp(pub_key, tmp) >= 0) {+        *ret |= FFC_ERROR_PUBKEY_TOO_LARGE;+        goto err;+    }+    ok = 1;+ err:+    if (ctx != NULL) {+        BN_CTX_end(ctx);",
            "commit_date": "2020-02-16 13:03:46+10:00",
            "commit_hash": "8083fd3a183d4c881d6b15727cbc6cb7faeb3280",
            "message": "Add FFC param/key validation\nEmbed libctx in dsa and dh objects and cleanup internal methods to not pass libctx (This makes it consistent with the rsa changes)\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/10910)"
        }
    ],
    "git log -L18,42:crypto/ffc/ffc_key_validate.c": [
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/crypto/ffc/ffc_key_validate.c b/crypto/ffc/ffc_key_validate.c--- a/crypto/ffc/ffc_key_validate.c+++ b/crypto/ffc/ffc_key_validate.c@@ -18,25 +18,25 @@  */-int ffc_validate_public_key_partial(const FFC_PARAMS *params,-                                    const BIGNUM *pub_key, int *ret)+int ossl_ffc_validate_public_key_partial(const FFC_PARAMS *params,+                                         const BIGNUM *pub_key, int *ret) {",
            "commit_date": "2020-09-30 15:07:24+10:00",
            "commit_hash": "5357c10624bedaeed984ef4ff370096911ee2ddf",
            "message": "ffc: add _ossl to exported but internal functions\nThe functions updated are:\nffc_generate_private_key, ffc_named_group_from_uid,\nffc_named_group_to_uid, ffc_params_FIPS186_2_gen_verify,\nffc_params_FIPS186_2_generate, ffc_params_FIPS186_2_validate,\nffc_params_FIPS186_4_gen_verify, ffc_params_FIPS186_4_generate,\nffc_params_FIPS186_4_validate, ffc_params_cleanup, ffc_params_cmp,\nffc_params_copy, ffc_params_enable_flags, ffc_params_flags_from_name,\nffc_params_flags_to_name, ffc_params_fromdata,\nffc_params_get0_pqg, ffc_params_get_validate_params,\nffc_params_init, ffc_params_print, ffc_params_set0_j,\nffc_params_set0_pqg, ffc_params_set_flags, ffc_params_set_gindex,\nffc_params_set_h, ffc_params_set_pcounter, ffc_params_set_seed,\nffc_params_set_validate_params, ffc_params_simple_validate,\nffc_params_todata, ffc_params_validate_unverifiable_g, ffc_set_digest,\nffc_set_group_pqg, ffc_validate_private_key, ffc_validate_public_key\nand ffc_validate_public_key_partial.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13041)\nint ok = 0;\nBIGNUM *tmp = NULL;\nBN_CTX *ctx = NULL;\n*ret = 0;\nctx = BN_CTX_new_ex(NULL);\nif (ctx == NULL)\ngoto err;\nBN_CTX_start(ctx);\ntmp = BN_CTX_get(ctx);\n/* Step(1): Verify pub_key >= 2 */\nif (tmp == NULL\n|| !BN_set_word(tmp, 1))\ngoto err;\nif (BN_cmp(pub_key, tmp) <= 0) {\n*ret |= FFC_ERROR_PUBKEY_TOO_SMALL;\ngoto err;\n}\n/* Step(1): Verify pub_key <=  p-2 */\nif (BN_copy(tmp, params->p) == NULL"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/crypto/ffc/ffc_key_validate.c b/crypto/ffc/ffc_key_validate.c--- /dev/null+++ b/crypto/ffc/ffc_key_validate.c@@ -0,0 +18,25 @@+ */+int ffc_validate_public_key_partial(const FFC_PARAMS *params,+                                    const BIGNUM *pub_key, int *ret)+{+    int ok = 0;+    BIGNUM *tmp = NULL;+    BN_CTX *ctx = NULL;++    *ret = 0;+    ctx = BN_CTX_new_ex(NULL);+    if (ctx == NULL)+        goto err;++    BN_CTX_start(ctx);+    tmp = BN_CTX_get(ctx);+    /* Step(1): Verify pub_key >= 2 */+    if (tmp == NULL+        || !BN_set_word(tmp, 1))+        goto err;+    if (BN_cmp(pub_key, tmp) <= 0) {+        *ret |= FFC_ERROR_PUBKEY_TOO_SMALL;+        goto err;+    }+    /* Step(1): Verify pub_key <=  p-2 */+    if (BN_copy(tmp, params->p) == NULL",
            "commit_date": "2020-02-16 13:03:46+10:00",
            "commit_hash": "8083fd3a183d4c881d6b15727cbc6cb7faeb3280",
            "message": "Add FFC param/key validation\nEmbed libctx in dsa and dh objects and cleanup internal methods to not pass libctx (This makes it consistent with the rsa changes)\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/10910)"
        }
    ],
    "git log -L18,35:crypto/ffc/ffc_key_validate.c": [
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/crypto/ffc/ffc_key_validate.c b/crypto/ffc/ffc_key_validate.c--- a/crypto/ffc/ffc_key_validate.c+++ b/crypto/ffc/ffc_key_validate.c@@ -18,18 +18,18 @@  */-int ffc_validate_public_key_partial(const FFC_PARAMS *params,-                                    const BIGNUM *pub_key, int *ret)+int ossl_ffc_validate_public_key_partial(const FFC_PARAMS *params,+                                         const BIGNUM *pub_key, int *ret) {",
            "commit_date": "2020-09-30 15:07:24+10:00",
            "commit_hash": "5357c10624bedaeed984ef4ff370096911ee2ddf",
            "message": "ffc: add _ossl to exported but internal functions\nThe functions updated are:\nffc_generate_private_key, ffc_named_group_from_uid,\nffc_named_group_to_uid, ffc_params_FIPS186_2_gen_verify,\nffc_params_FIPS186_2_generate, ffc_params_FIPS186_2_validate,\nffc_params_FIPS186_4_gen_verify, ffc_params_FIPS186_4_generate,\nffc_params_FIPS186_4_validate, ffc_params_cleanup, ffc_params_cmp,\nffc_params_copy, ffc_params_enable_flags, ffc_params_flags_from_name,\nffc_params_flags_to_name, ffc_params_fromdata,\nffc_params_get0_pqg, ffc_params_get_validate_params,\nffc_params_init, ffc_params_print, ffc_params_set0_j,\nffc_params_set0_pqg, ffc_params_set_flags, ffc_params_set_gindex,\nffc_params_set_h, ffc_params_set_pcounter, ffc_params_set_seed,\nffc_params_set_validate_params, ffc_params_simple_validate,\nffc_params_todata, ffc_params_validate_unverifiable_g, ffc_set_digest,\nffc_set_group_pqg, ffc_validate_private_key, ffc_validate_public_key\nand ffc_validate_public_key_partial.\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/13041)\nint ok = 0;\nBIGNUM *tmp = NULL;\nBN_CTX *ctx = NULL;\n*ret = 0;\nctx = BN_CTX_new_ex(NULL);\nif (ctx == NULL)\ngoto err;\nBN_CTX_start(ctx);\ntmp = BN_CTX_get(ctx);\n/* Step(1): Verify pub_key >= 2 */\nif (tmp == NULL\n|| !BN_set_word(tmp, 1))"
        },
        {
            "author": {
                "email": "shane.lontis@oracle.com",
                "name": "Shane Lontis"
            },
            "changes": "diff --git a/crypto/ffc/ffc_key_validate.c b/crypto/ffc/ffc_key_validate.c--- /dev/null+++ b/crypto/ffc/ffc_key_validate.c@@ -0,0 +18,18 @@+ */+int ffc_validate_public_key_partial(const FFC_PARAMS *params,+                                    const BIGNUM *pub_key, int *ret)+{+    int ok = 0;+    BIGNUM *tmp = NULL;+    BN_CTX *ctx = NULL;++    *ret = 0;+    ctx = BN_CTX_new_ex(NULL);+    if (ctx == NULL)+        goto err;++    BN_CTX_start(ctx);+    tmp = BN_CTX_get(ctx);+    /* Step(1): Verify pub_key >= 2 */+    if (tmp == NULL+        || !BN_set_word(tmp, 1))",
            "commit_date": "2020-02-16 13:03:46+10:00",
            "commit_hash": "8083fd3a183d4c881d6b15727cbc6cb7faeb3280",
            "message": "Add FFC param/key validation\nEmbed libctx in dsa and dh objects and cleanup internal methods to not pass libctx (This makes it consistent with the rsa changes)\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/10910)"
        }
    ],
    "git log -L12,152:crypto/bn/bn_sqrt.c": [
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,140 +12,141 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number- * Theory\", algorithm 1.5.1). 'p' must be prime!+ * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or+ * an incorrect \"result\" will be returned.  */ {",
            "commit_date": "2022-02-28 18:26:21+01:00",
            "commit_hash": "9eafb53614bf65797db25f467946e735e1b43dc9",
            "message": "Fix possible infinite loop in BN_mod_sqrt()\nThe calculation in some cases does not finish for non-prime p.\nThis fixes CVE-2022-0778.\nBased on patch by David Benjamin <davidben@google.com>.\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nint used_ctx = 0;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nused_ctx = 1;\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* Subject: Square Roots and Cognate Matters modulo p=8n+5.\n* URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))\ngoto end;\n/* t := (2*a)*b^2 - 1 */\nif (!BN_mod_mul(t, t, y, p, ctx))"
        },
        {
            "author": {
                "email": "agustingianni@gmail.com",
                "name": "Agustin Gianni"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,138 +12,140 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {+    int used_ctx = 0;+    used_ctx = 1;",
            "commit_date": "2021-01-08 16:04:05+01:00",
            "commit_hash": "48116c2d0fbb1db875e2bc703c08089bf3c5c5c3",
            "message": "Fix incorrect use of BN_CTX API\nIn some edge cases BN_CTX_end was being called without first calling\nBN_CTX_start. This creates a situation where the state of the big\nnumber allocator is corrupted and may lead to crashes.\nFixes #13812\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/13813)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* Subject: Square Roots and Cognate Matters modulo p=8n+5.\n* URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))\ngoto end;\n/* t := (2*a)*b^2 - 1 */\nif (!BN_mod_mul(t, t, y, p, ctx))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,138 +12,138 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);",
            "commit_date": "2020-11-04 12:23:19+01:00",
            "commit_hash": "9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2",
            "message": "Convert all {NAME}err() in crypto/ to their corresponding ERR_raise() call\nThis includes error reporting for libcrypto sub-libraries in surprising\nplaces.\nThis was done using util/err-to-raise\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13318)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* Subject: Square Roots and Cognate Matters modulo p=8n+5.\n* URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))\ngoto end;\n/* t := (2*a)*b^2 - 1 */\nif (!BN_mod_mul(t, t, y, p, ctx))"
        },
        {
            "author": {
                "email": "bernd.edlinger@hotmail.de",
                "name": "Bernd Edlinger"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,137 +12,138 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-         * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+         * Subject: Square Roots and Cognate Matters modulo p=8n+5.+         * URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026",
            "commit_date": "2019-06-10 10:24:35+02:00",
            "commit_hash": "e98e586b31386af2b2212729da85561a207e7af3",
            "message": "Fix a URL to the NMBRTHRY list archive\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/9123)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))\ngoto end;\n/* t := (2*a)*b^2 - 1 */\nif (!BN_mod_mul(t, t, y, p, ctx))"
        },
        {
            "author": {
                "email": "kunnpuu@gmail.com",
                "name": "KaoruToda"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,137 +12,137 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-        return (NULL);+        return NULL;",
            "commit_date": "2017-10-17 23:04:09+09:00",
            "commit_hash": "26a7d938c9bf932a55cb5e4e02abb48fe395c5cd",
            "message": "Remove parentheses of return.\nSince return is inconsistent, I removed unnecessary parentheses and\nunified them.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4541)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))\ngoto end;\n/* t := (2*a)*b^2 - 1 */\nif (!BN_mod_mul(t, t, y, p, ctx))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -62,137 +62,137 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-                /*--                 * |p| == 5  (mod 8)-                 *-                 * In this case  2  is always a non-square since-                 * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.-                 * So if  a  really is a square, then  2*a  is a non-square.-                 * Thus for-                 *      b := (2*a)^((|p|-5)/8),-                 *      i := (2*a)*b^2-                 * we have-                 *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)-                 *         = (2*a)^((p-1)/2)-                 *         = -1;-                 * so if we set-                 *      x := a*b*(i-1),-                 * then-                 *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)-                 *         = a^2 * b^2 * (-2*i)-                 *         = a*(-i)*(2*a*b^2)-                 *         = a*(-i)*i-                 *         = a.-                 *-                 * (This is due to A.O.L. Atkin,-                 * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,-                 * November 1992.)-                 */+        /*-+         * |p| == 5  (mod 8)+         *+         * In this case  2  is always a non-square since+         * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+         * So if  a  really is a square, then  2*a  is a non-square.+         * Thus for+         *      b := (2*a)^((|p|-5)/8),+         *      i := (2*a)*b^2+         * we have+         *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)+         *         = (2*a)^((p-1)/2)+         *         = -1;+         * so if we set+         *      x := a*b*(i-1),+         * then+         *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+         *         = a^2 * b^2 * (-2*i)+         *         = a*(-i)*(2*a*b^2)+         *         = a*(-i)*i+         *         = a.+         *+         * (This is due to A.O.L. Atkin,+         * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+         * November 1992.)+         */",
            "commit_date": "2015-01-17 00:06:54+00:00",
            "commit_hash": "35a1cc90bc1795e8893c11e442790ee7f659fffb",
            "message": "More comment realignment\nReviewed-by: Tim Hudson <tjh@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn (NULL);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))\ngoto end;\n/* t := (2*a)*b^2 - 1 */\nif (!BN_mod_mul(t, t, y, p, ctx))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -62,137 +62,137 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-                /*--                 * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse-                 * modulo  (|p|-1)/2,  and square roots can be computed-                 * directly by modular exponentiation.-                 * We have-                 *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),-                 * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.-                 */+        /*-+         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+         * modulo  (|p|-1)/2,  and square roots can be computed+         * directly by modular exponentiation.+         * We have+         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.+         */",
            "commit_date": "2015-01-05 11:30:03+00:00",
            "commit_hash": "50e735f9e5d220cdad7db690188b82a69ddcb39e",
            "message": "Re-align some comments after running the reformat script.\nThis should be a one off operation (subsequent invokation of the\nscript should not move them)\nReviewed-by: Tim Hudson <tjh@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn (NULL);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))\ngoto end;\n/* t := (2*a)*b^2 - 1 */\nif (!BN_mod_mul(t, t, y, p, ctx))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,308 +62,137 @@--BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) -/* Returns 'ret' such that- *      ret^2 == a (mod p),- * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course- * in Algebraic Computational Number Theory\", algorithm 1.5.1).- * 'p' must be prime!+BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)+/*+ * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks+ * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number+ * Theory\", algorithm 1.5.1). 'p' must be prime!  */-\t{-\tBIGNUM *ret = in;-\tint err = 1;-\tint r;-\tBIGNUM *A, *b, *q, *t, *x, *y;-\tint e, i, j;-\t-\tif (!BN_is_odd(p) || BN_abs_is_word(p, 1))-\t\t{-\t\tif (BN_abs_is_word(p, 2))-\t\t\t{-\t\t\tif (ret == NULL)-\t\t\t\tret = BN_new();-\t\t\tif (ret == NULL)-\t\t\t\tgoto end;-\t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0)))-\t\t\t\t{-\t\t\t\tif (ret != in)-\t\t\t\t\tBN_free(ret);-\t\t\t\treturn NULL;-\t\t\t\t}-\t\t\tbn_check_top(ret);-\t\t\treturn ret;-\t\t\t}--\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\treturn(NULL);-\t\t}--\tif (BN_is_zero(a) || BN_is_one(a))-\t\t{-\t\tif (ret == NULL)-\t\t\tret = BN_new();-\t\tif (ret == NULL)-\t\t\tgoto end;-\t\tif (!BN_set_word(ret, BN_is_one(a)))-\t\t\t{-\t\t\tif (ret != in)-\t\t\t\tBN_free(ret);-\t\t\treturn NULL;-\t\t\t}-\t\tbn_check_top(ret);-\t\treturn ret;-\t\t}--\tBN_CTX_start(ctx);-\tA = BN_CTX_get(ctx);-\tb = BN_CTX_get(ctx);-\tq = BN_CTX_get(ctx);-\tt = BN_CTX_get(ctx);-\tx = BN_CTX_get(ctx);-\ty = BN_CTX_get(ctx);-\tif (y == NULL) goto end;-\t-\tif (ret == NULL)-\t\tret = BN_new();-\tif (ret == NULL) goto end;--\t/* A = a mod p */-\tif (!BN_nnmod(A, a, p, ctx)) goto end;--\t/* now write  |p| - 1  as  2^e*q  where  q  is odd */-\te = 1;-\twhile (!BN_is_bit_set(p, e))-\t\te++;-\t/* we'll set  q  later (if needed) */--\tif (e == 1)-\t\t{-\t\t/*--\t\t * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse-\t\t * modulo  (|p|-1)/2,  and square roots can be computed-\t\t * directly by modular exponentiation.-\t\t * We have-\t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),-\t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.-\t\t */-\t\tif (!BN_rshift(q, p, 2)) goto end;-\t\tq->neg = 0;-\t\tif (!BN_add_word(q, 1)) goto end;-\t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end;-\t\terr = 0;-\t\tgoto vrfy;-\t\t}-\t-\tif (e == 2)-\t\t{-\t\t/*--\t\t * |p| == 5  (mod 8)-\t\t *-\t\t * In this case  2  is always a non-square since-\t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.-\t\t * So if  a  really is a square, then  2*a  is a non-square.-\t\t * Thus for-\t\t *      b := (2*a)^((|p|-5)/8),-\t\t *      i := (2*a)*b^2-\t\t * we have-\t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)-\t\t *         = (2*a)^((p-1)/2)-\t\t *         = -1;-\t\t * so if we set-\t\t *      x := a*b*(i-1),-\t\t * then-\t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)-\t\t *         = a^2 * b^2 * (-2*i)-\t\t *         = a*(-i)*(2*a*b^2)-\t\t *         = a*(-i)*i-\t\t *         = a.-\t\t *-\t\t * (This is due to A.O.L. Atkin, -\t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,-\t\t * November 1992.)-\t\t */--\t\t/* t := 2*a */-\t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end;--\t\t/* b := (2*a)^((|p|-5)/8) */-\t\tif (!BN_rshift(q, p, 3)) goto end;-\t\tq->neg = 0;-\t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end;--\t\t/* y := b^2 */-\t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end;--\t\t/* t := (2*a)*b^2 - 1*/-\t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;-\t\tif (!BN_sub_word(t, 1)) goto end;--\t\t/* x = a*b*t */-\t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end;-\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;--\t\tif (!BN_copy(ret, x)) goto end;-\t\terr = 0;-\t\tgoto vrfy;-\t\t}-\t-\t/* e > 2, so we really have to use the Tonelli/Shanks algorithm.-\t * First, find some  y  that is not a square. */-\tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */-\tq->neg = 0;-\ti = 2;-\tdo-\t\t{-\t\t/* For efficiency, try small numbers first;-\t\t * if this fails, try random numbers.-\t\t */-\t\tif (i < 22)-\t\t\t{-\t\t\tif (!BN_set_word(y, i)) goto end;-\t\t\t}-\t\telse-\t\t\t{-\t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end;-\t\t\tif (BN_ucmp(y, p) >= 0)-\t\t\t\t{-\t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end;-\t\t\t\t}-\t\t\t/* now 0 <= y < |p| */-\t\t\tif (BN_is_zero(y))-\t\t\t\tif (!BN_set_word(y, i)) goto end;-\t\t\t}-\t\t-\t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */-\t\tif (r < -1) goto end;-\t\tif (r == 0)-\t\t\t{-\t\t\t/* m divides p */-\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\t\tgoto end;-\t\t\t}-\t\t}-\twhile (r == 1 && ++i < 82);-\t-\tif (r != -1)-\t\t{-\t\t/* Many rounds and still no non-square -- this is more likely-\t\t * a bug than just bad luck.-\t\t * Even if  p  is not prime, we should have found some  y-\t\t * such that r == -1.-\t\t */-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);-\t\tgoto end;-\t\t}--\t/* Here's our actual 'q': */-\tif (!BN_rshift(q, q, e)) goto end;--\t/* Now that we have some non-square, we can find an element-\t * of order  2^e  by computing its q'th power. */-\tif (!BN_mod_exp(y, y, q, p, ctx)) goto end;-\tif (BN_is_one(y))-\t\t{-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\tgoto end;-\t\t}--\t/*--\t * Now we know that (if  p  is indeed prime) there is an integer-\t * k,  0 <= k < 2^e,  such that-\t *-\t *      a^q * y^k == 1   (mod p).-\t *-\t * As  a^q  is a square and  y  is not,  k  must be even.-\t * q+1  is even, too, so there is an element-\t *-\t *     X := a^((q+1)/2) * y^(k/2),-\t *-\t * and it satisfies-\t *-\t *     X^2 = a^q * a     * y^k-\t *         = a,-\t *-\t * so it is the square root that we are looking for.-\t */-\t-\t/* t := (q-1)/2  (note that  q  is odd) */-\tif (!BN_rshift1(t, q)) goto end;-\t-\t/* x := a^((q-1)/2) */-\tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */-\t\t{-\t\tif (!BN_nnmod(t, A, p, ctx)) goto end;-\t\tif (BN_is_zero(t))-\t\t\t{-\t\t\t/* special case: a == 0  (mod p) */-\t\t\tBN_zero(ret);-\t\t\terr = 0;-\t\t\tgoto end;-\t\t\t}-\t\telse-\t\t\tif (!BN_one(x)) goto end;-\t\t}-\telse-\t\t{-\t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end;-\t\tif (BN_is_zero(x))-\t\t\t{-\t\t\t/* special case: a == 0  (mod p) */-\t\t\tBN_zero(ret);-\t\t\terr = 0;-\t\t\tgoto end;-\t\t\t}-\t\t}--\t/* b := a*x^2  (= a^q) */-\tif (!BN_mod_sqr(b, x, p, ctx)) goto end;-\tif (!BN_mod_mul(b, b, A, p, ctx)) goto end;-\t-\t/* x := a*x    (= a^((q+1)/2)) */-\tif (!BN_mod_mul(x, x, A, p, ctx)) goto end;--\twhile (1)-\t\t{-\t\t/*- -\t\t * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E-\t\t * where  E  refers to the original value of  e,  which we-\t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).-\t\t *-\t\t * We have  a*b = x^2,-\t\t *    y^2^(e-1) = -1,-\t\t *    b^2^(e-1) = 1.-\t\t */--\t\tif (BN_is_one(b))-\t\t\t{-\t\t\tif (!BN_copy(ret, x)) goto end;-\t\t\terr = 0;-\t\t\tgoto vrfy;-\t\t\t}---\t\t/* find smallest  i  such that  b^(2^i) = 1 */-\t\ti = 1;-\t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end;-\t\twhile (!BN_is_one(t))-\t\t\t{-\t\t\ti++;-\t\t\tif (i == e)-\t\t\t\t{-\t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);-\t\t\t\tgoto end;-\t\t\t\t}-\t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end;-\t\t\t}-\t\t--\t\t/* t := y^2^(e - i - 1) */-\t\tif (!BN_copy(t, y)) goto end;-\t\tfor (j = e - i - 1; j > 0; j--)-\t\t\t{-\t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end;-\t\t\t}-\t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end;-\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;-\t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end;-\t\te = i;-\t\t}+{+    BIGNUM *ret = in;+    int err = 1;+    int r;+    BIGNUM *A, *b, *q, *t, *x, *y;+    int e, i, j;++    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {+        if (BN_abs_is_word(p, 2)) {+            if (ret == NULL)+                ret = BN_new();+            if (ret == NULL)+                goto end;+            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {+                if (ret != in)+                    BN_free(ret);+                return NULL;+            }+            bn_check_top(ret);+            return ret;+        }++        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+        return (NULL);+    }++    if (BN_is_zero(a) || BN_is_one(a)) {+        if (ret == NULL)+            ret = BN_new();+        if (ret == NULL)+            goto end;+        if (!BN_set_word(ret, BN_is_one(a))) {+            if (ret != in)+                BN_free(ret);+            return NULL;+        }+        bn_check_top(ret);+        return ret;+    }++    BN_CTX_start(ctx);+    A = BN_CTX_get(ctx);+    b = BN_CTX_get(ctx);+    q = BN_CTX_get(ctx);+    t = BN_CTX_get(ctx);+    x = BN_CTX_get(ctx);+    y = BN_CTX_get(ctx);+    if (y == NULL)+        goto end;++    if (ret == NULL)+        ret = BN_new();+    if (ret == NULL)+        goto end;++    /* A = a mod p */+    if (!BN_nnmod(A, a, p, ctx))+        goto end;++    /* now write  |p| - 1  as  2^e*q  where  q  is odd */+    e = 1;+    while (!BN_is_bit_set(p, e))+        e++;+    /* we'll set  q  later (if needed) */++    if (e == 1) {+                /*-+                 * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+                 * modulo  (|p|-1)/2,  and square roots can be computed+                 * directly by modular exponentiation.+                 * We have+                 *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+                 * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.+                 */+        if (!BN_rshift(q, p, 2))+            goto end;+        q->neg = 0;+        if (!BN_add_word(q, 1))+            goto end;+        if (!BN_mod_exp(ret, A, q, p, ctx))+            goto end;+        err = 0;+        goto vrfy;+    }++    if (e == 2) {+                /*-+                 * |p| == 5  (mod 8)+                 *+                 * In this case  2  is always a non-square since+                 * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+                 * So if  a  really is a square, then  2*a  is a non-square.+                 * Thus for+                 *      b := (2*a)^((|p|-5)/8),+                 *      i := (2*a)*b^2+                 * we have+                 *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)+                 *         = (2*a)^((p-1)/2)+                 *         = -1;+                 * so if we set+                 *      x := a*b*(i-1),+                 * then+                 *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+                 *         = a^2 * b^2 * (-2*i)+                 *         = a*(-i)*(2*a*b^2)+                 *         = a*(-i)*i+                 *         = a.+                 *+                 * (This is due to A.O.L. Atkin,+                 * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+                 * November 1992.)+                 */++        /* t := 2*a */+        if (!BN_mod_lshift1_quick(t, A, p))+            goto end;++        /* b := (2*a)^((|p|-5)/8) */+        if (!BN_rshift(q, p, 3))+            goto end;+        q->neg = 0;+        if (!BN_mod_exp(b, t, q, p, ctx))+            goto end;++        /* y := b^2 */+        if (!BN_mod_sqr(y, b, p, ctx))+            goto end;++        /* t := (2*a)*b^2 - 1 */+        if (!BN_mod_mul(t, t, y, p, ctx))",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "tjh@openssl.org",
                "name": "Tim Hudson"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,304 +60,308 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tif (ret != in) \t\t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tif (ret != in) \t\t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{-\t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+\t\t/*-+\t\t * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{-\t\t/* |p| == 5  (mod 8)+\t\t/*-+\t\t * |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t}-\t/* Now we know that (if  p  is indeed prime) there is an integer+\t/*-+\t * Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{-\t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E+\t\t/*- +\t\t * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2014-12-28 12:48:40+10:00",
            "commit_hash": "1d97c8435171a7af575f73c526d79e1ef0ee5960",
            "message": "mark all block comments that need format preserving so that\nindent will not alter them when reformatting comments\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,304 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{-\t\t\t\tBN_free(ret);+\t\t\t\tif (ret != in)+\t\t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{-\t\t\tBN_free(ret);+\t\t\tif (ret != in)+\t\t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2005-08-23 04:14:40+00:00",
            "commit_hash": "7534d131d676431f1299618dfe0decd1a42680bb",
            "message": "avoid potential spurious BN_free()\nSubmitted by: David Heine <dlheine@suif.Stanford.EDU>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */-\t\t\tif (!BN_zero(ret)) goto end;+\t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */-\t\t\tif (!BN_zero(ret)) goto end;+\t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2004-03-13 23:57:20+00:00",
            "commit_hash": "b6358c89a10128692875fb92921b663c4d079a1e",
            "message": "Convert openssl code not to assume the deprecated form of BN_zero().\nRemove certain redundant BN_zero() initialisations, because BN_CTX_get(),\nBN_init(), [etc] already initialise to zero.\nCorrect error checking in bn_sqr.c, and be less wishy-wash about how/why\nthe result's 'top' value is set (note also, 'max' is always > 0 at this\npoint)."
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,300 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t}+\t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t}+\t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2003-11-04 22:54:49+00:00",
            "commit_hash": "d870740cd75dd4f0cb66fb8c32653a7d47369706",
            "message": "Put the first stage of my bignum debugging adventures into CVS. This code\nis itself experimental, and in addition may cause execution to break on\nexisting openssl \"bugs\" that previously were harmless or at least\ninvisible."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,300 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!- * If 'a' is not a square, this is not necessarily detected by- * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 15:13:10+00:00",
            "commit_hash": "d3bcbba45c4f161d88e30fd8b0434e8e24202681",
            "message": "remove obsolete part of comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,312 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  * If 'a' is not a square, this is not necessarily detected by  * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t}-#if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */-\tr = BN_kronecker(a, p, ctx);-\tif (r < -1) return NULL;-\tif (r == -1)-\t\t{-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);-\t\treturn(NULL);-\t\t}-#endif- \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 15:07:08+00:00",
            "commit_hash": "0903e56196a1a265dd9397e1e09a22aa4766914e",
            "message": "remove obsoleted disabled code"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,315 +60,312 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  * If 'a' is not a square, this is not necessarily detected by  * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r;-\tBIGNUM *b, *q, *t, *x, *y;+\tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx);+\tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end;+\t/* A = a mod p */+\tif (!BN_nnmod(A, a, p, ctx)) goto end;+ \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end;-\t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end;+\t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0;-\t\tgoto end;+\t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */-\t\t/* make sure that  a  is reduced modulo p */-\t\tif (a->neg || BN_ucmp(a, p) >= 0)-\t\t\t{-\t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end;-\t\t\ta = x; /* use x as temporary variable */-\t\t\t}- \t\t/* t := 2*a */-\t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;+\t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */-\t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0;-\t\tgoto end;+\t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{-\t\tif (!BN_nnmod(t, a, p, ctx)) goto end;+\t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{-\t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end;+\t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end;-\tif (!BN_mod_mul(b, b, a, p, ctx)) goto end;+\tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */-\tif (!BN_mod_mul(x, x, a, p, ctx)) goto end;+\tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0;-\t\t\tgoto end;+\t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 14:57:53+00:00",
            "commit_hash": "6fb60a84dd1ec81953917e0444dab50186617432",
            "message": "Change BN_mod_sqrt() so that it verifies that the input value is\nreally the square of the return value."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,313 +60,315 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!+ * If 'a' is not a square, this is not necessarily detected by+ * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2001-03-08 16:53:30+00:00",
            "commit_hash": "ff612904d277b6e4f8118913e1278a1afc75e073",
            "message": "Comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,314 +60,313 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++;-\tif (e > 2)-\t\t{-\t\t/* we don't need this  q  if  e = 1 or 2 */-\t\tif (!BN_rshift(q, p, e)) goto end;-\t\tq->neg = 0;-\t\t}+\t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{-\t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse-\t\t * modulo  (p-1)/2,  and square roots can be computed+\t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+\t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have-\t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),-\t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1.+\t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+\t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{-\t\t/* p == 5  (mod 8)+\t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for-\t\t *      b := (2*a)^((p-5)/8),+\t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have-\t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2)+\t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;-\t\t/* b := (2*a)^((p-5)/8) */+\t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */+\tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */+\tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t}-\t\tr = BN_kronecker(y, p, ctx);+\t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t}+\t/* Here's our actual 'q': */+\tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-07 08:48:58+00:00",
            "commit_hash": "80d89e6a6aa6d9520336c78877c3cccb54c881cd",
            "message": "Sign-related fixes (and tests).\nBN_mod_exp_mont does not work properly yet if modulus m\nis negative (we want computations to be carried out\nmodulo |m|)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,310 +60,314 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (e > 2)+\t\t{ \t\t/* we don't need this  q  if  e = 1 or 2 */ \t\tif (!BN_rshift(q, p, e)) goto end;-\tq->neg = 0;+\t\tq->neg = 0;+\t\t} \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end;+\t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* p == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((p-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((p-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end;+\t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-07 07:55:26+00:00",
            "commit_hash": "bc5f2740d2a427d5e16bfb12aa8b70d5a5adcfc8",
            "message": "Move 'q->neg = 0' to those places where it is needed\n(just in cases someone uses a negative modulus)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,310 +60,310 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (e > 2) \t\t/* we don't need this  q  if  e = 1 or 2 */ \t\tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* p == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((p-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((p-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;-\t\tif (!BN_sub_word(t, 1)) goto end; /* cannot become negative */+\t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-06 21:33:58+00:00",
            "commit_hash": "aa66eba7c8c7496db92b80da19688d6f96a40b96",
            "message": "BN_mod_sqrt documentation/comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,236 +60,310 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t}+\tif (BN_is_zero(a) || BN_is_one(a))+\t\t{+\t\tif (ret == NULL)+\t\t\tret = BN_new();+\t\tif (ret == NULL)+\t\t\tgoto end;+\t\tif (!BN_set_word(ret, BN_is_one(a)))+\t\t\t{+\t\t\tBN_free(ret);+\t\t\treturn NULL;+\t\t\t}+\t\treturn ret;+\t\t}+ #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++;-\tif (!BN_rshift(q, p, e)) goto end;+\tif (e > 2)+\t\t/* we don't need this  q  if  e = 1 or 2 */+\t\tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),-\t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2.+\t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */-\t\tif (!BN_add_word(q,1)) goto end;-\t\tif (!BN_rshift1(q,q)) goto end;+\t\tif (!BN_rshift(q, p, 2)) goto end;+\t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t}-\t/* e > 1, so we really have to use the Tonelli/Shanks algorithm.+\tif (e == 2)+\t\t{+\t\t/* p == 5  (mod 8)+\t\t *+\t\t * In this case  2  is always a non-square since+\t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+\t\t * So if  a  really is a square, then  2*a  is a non-square.+\t\t * Thus for+\t\t *      b := (2*a)^((p-5)/8),+\t\t *      i := (2*a)*b^2+\t\t * we have+\t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2)+\t\t *         = (2*a)^((p-1)/2)+\t\t *         = -1;+\t\t * so if we set+\t\t *      x := a*b*(i-1),+\t\t * then+\t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+\t\t *         = a^2 * b^2 * (-2*i)+\t\t *         = a*(-i)*(2*a*b^2)+\t\t *         = a*(-i)*i+\t\t *         = a.+\t\t *+\t\t * (This is due to A.O.L. Atkin, +\t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+\t\t * November 1992.)+\t\t */++\t\t/* make sure that  a  is reduced modulo p */+\t\tif (a->neg || BN_ucmp(a, p) >= 0)+\t\t\t{+\t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end;+\t\t\ta = x; /* use x as temporary variable */+\t\t\t}++\t\t/* t := 2*a */+\t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;++\t\t/* b := (2*a)^((p-5)/8) */+\t\tif (!BN_rshift(q, p, 3)) goto end;+\t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end;++\t\t/* y := b^2 */+\t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end;++\t\t/* t := (2*a)*b^2 - 1*/+\t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;+\t\tif (!BN_sub_word(t, 1)) goto end; /* cannot become negative */++\t\t/* x = a*b*t */+\t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;++\t\tif (!BN_copy(ret, x)) goto end;+\t\terr = 0;+\t\tgoto end;+\t\t}+\t+\t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-06 12:25:33+00:00",
            "commit_hash": "bac685417a0890642bada45bfaf1e44de9c92beb",
            "message": "Faster BN_mod_sqrt algorithm for p == 5 (8)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,236 +60,236 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2. \t\t */ \t\tif (!BN_add_word(q,1)) goto end; \t\tif (!BN_rshift1(q,q)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 1, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */-\ti = 1;+\ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */-\t\tif (i < 20)+\t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t}-\twhile (r == 1 && i++ < 80);+\twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-11-30 09:45:26+00:00",
            "commit_hash": "25439b76adb66fe0ce6e012a9af1e1ce969a1479",
            "message": "Move reduction step from BN_mod_exp to BN_mod_exp_mont_word.\nFix BN_mod_exp_simple for a==0 (mod m).\nSkip useless round in BN_mod_sqrt (1 is always a square, no need\nto test BN_kronecker for it)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -1,1 +60,236 @@-XXX+++BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) +/* Returns 'ret' such that+ *      ret^2 == a (mod p),+ * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course+ * in Algebraic Computational Number Theory\", algorithm 1.5.1).+ * 'p' must be prime!+ */+\t{+\tBIGNUM *ret = in;+\tint err = 1;+\tint r;+\tBIGNUM *b, *q, *t, *x, *y;+\tint e, i, j;+\t+\tif (!BN_is_odd(p) || BN_abs_is_word(p, 1))+\t\t{+\t\tif (BN_abs_is_word(p, 2))+\t\t\t{+\t\t\tif (ret == NULL)+\t\t\t\tret = BN_new();+\t\t\tif (ret == NULL)+\t\t\t\tgoto end;+\t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0)))+\t\t\t\t{+\t\t\t\tBN_free(ret);+\t\t\t\treturn NULL;+\t\t\t\t}+\t\t\treturn ret;+\t\t\t}++\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\treturn(NULL);+\t\t}++#if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */+\tr = BN_kronecker(a, p, ctx);+\tif (r < -1) return NULL;+\tif (r == -1)+\t\t{+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);+\t\treturn(NULL);+\t\t}+#endif++\tBN_CTX_start(ctx);+\tb = BN_CTX_get(ctx);+\tq = BN_CTX_get(ctx);+\tt = BN_CTX_get(ctx);+\tx = BN_CTX_get(ctx);+\ty = BN_CTX_get(ctx);+\tif (y == NULL) goto end;+\t+\tif (ret == NULL)+\t\tret = BN_new();+\tif (ret == NULL) goto end;++\t/* now write  |p| - 1  as  2^e*q  where  q  is odd */+\te = 1;+\twhile (!BN_is_bit_set(p, e))+\t\te++;+\tif (!BN_rshift(q, p, e)) goto end;+\tq->neg = 0;++\tif (e == 1)+\t\t{+\t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse+\t\t * modulo  (p-1)/2,  and square roots can be computed+\t\t * directly by modular exponentiation.+\t\t * We have+\t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),+\t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2.+\t\t */+\t\tif (!BN_add_word(q,1)) goto end;+\t\tif (!BN_rshift1(q,q)) goto end;+\t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end;+\t\terr = 0;+\t\tgoto end;+\t\t}+\t+\t/* e > 1, so we really have to use the Tonelli/Shanks algorithm.+\t * First, find some  y  that is not a square. */+\ti = 1;+\tdo+\t\t{+\t\t/* For efficiency, try small numbers first;+\t\t * if this fails, try random numbers.+\t\t */+\t\tif (i < 20)+\t\t\t{+\t\t\tif (!BN_set_word(y, i)) goto end;+\t\t\t}+\t\telse+\t\t\t{+\t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end;+\t\t\tif (BN_ucmp(y, p) >= 0)+\t\t\t\t{+\t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end;+\t\t\t\t}+\t\t\t/* now 0 <= y < |p| */+\t\t\tif (BN_is_zero(y))+\t\t\t\tif (!BN_set_word(y, i)) goto end;+\t\t\t}+\t\t+\t\tr = BN_kronecker(y, p, ctx);+\t\tif (r < -1) goto end;+\t\tif (r == 0)+\t\t\t{+\t\t\t/* m divides p */+\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\t\tgoto end;+\t\t\t}+\t\t}+\twhile (r == 1 && i++ < 80);+\t+\tif (r != -1)+\t\t{+\t\t/* Many rounds and still no non-square -- this is more likely+\t\t * a bug than just bad luck.+\t\t * Even if  p  is not prime, we should have found some  y+\t\t * such that r == -1.+\t\t */+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);+\t\tgoto end;+\t\t}+++\t/* Now that we have some non-square, we can find an element+\t * of order  2^e  by computing its q'th power. */+\tif (!BN_mod_exp(y, y, q, p, ctx)) goto end;+\tif (BN_is_one(y))+\t\t{+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\tgoto end;+\t\t}++\t/* Now we know that (if  p  is indeed prime) there is an integer+\t * k,  0 <= k < 2^e,  such that+\t *+\t *      a^q * y^k == 1   (mod p).+\t *+\t * As  a^q  is a square and  y  is not,  k  must be even.+\t * q+1  is even, too, so there is an element+\t *+\t *     X := a^((q+1)/2) * y^(k/2),+\t *+\t * and it satisfies+\t *+\t *     X^2 = a^q * a     * y^k+\t *         = a,+\t *+\t * so it is the square root that we are looking for.+\t */+\t+\t/* t := (q-1)/2  (note that  q  is odd) */+\tif (!BN_rshift1(t, q)) goto end;+\t+\t/* x := a^((q-1)/2) */+\tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */+\t\t{+\t\tif (!BN_nnmod(t, a, p, ctx)) goto end;+\t\tif (BN_is_zero(t))+\t\t\t{+\t\t\t/* special case: a == 0  (mod p) */+\t\t\tif (!BN_zero(ret)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+\t\telse+\t\t\tif (!BN_one(x)) goto end;+\t\t}+\telse+\t\t{+\t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end;+\t\tif (BN_is_zero(x))+\t\t\t{+\t\t\t/* special case: a == 0  (mod p) */+\t\t\tif (!BN_zero(ret)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+\t\t}++\t/* b := a*x^2  (= a^q) */+\tif (!BN_mod_sqr(b, x, p, ctx)) goto end;+\tif (!BN_mod_mul(b, b, a, p, ctx)) goto end;+\t+\t/* x := a*x    (= a^((q+1)/2)) */+\tif (!BN_mod_mul(x, x, a, p, ctx)) goto end;++\twhile (1)+\t\t{+\t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E+\t\t * where  E  refers to the original value of  e,  which we+\t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).+\t\t *+\t\t * We have  a*b = x^2,+\t\t *    y^2^(e-1) = -1,+\t\t *    b^2^(e-1) = 1.+\t\t */++\t\tif (BN_is_one(b))+\t\t\t{+\t\t\tif (!BN_copy(ret, x)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+++\t\t/* find smallest  i  such that  b^(2^i) = 1 */+\t\ti = 1;+\t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end;+\t\twhile (!BN_is_one(t))+\t\t\t{+\t\t\ti++;+\t\t\tif (i == e)+\t\t\t\t{+\t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);+\t\t\t\tgoto end;+\t\t\t\t}+\t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end;+\t\t\t}+\t\t++\t\t/* t := y^2^(e - i - 1) */+\t\tif (!BN_copy(t, y)) goto end;+\t\tfor (j = e - i - 1; j > 0; j--)+\t\t\t{+\t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end;+\t\t\t}+\t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;+\t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end;+\t\te = i;+\t\t}",
            "commit_date": "2000-11-30 00:18:19+00:00",
            "commit_hash": "cd2eebfd6497ac1ca4d450960ba843f14643a9b2",
            "message": "BN_sqrt"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- /dev/null+++ b/crypto/bn/bn_sqrt.c@@ -0,0 +1,1 @@+XXX",
            "commit_date": "2000-11-28 06:37:43+00:00",
            "commit_hash": "265592b99a3c2d5a8134d2c684620113153b4e1e",
            "message": "Add bn_kron.c (BN_kronecker), which I forgot in the previous commit.\nAlso add the next file in advance so that I can't forget this one :-)"
        }
    ],
    "git log -L12,148:crypto/bn/bn_sqrt.c": [
        {
            "author": {
                "email": "tomas@openssl.org",
                "name": "Tomas Mraz"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,136 +12,137 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number- * Theory\", algorithm 1.5.1). 'p' must be prime!+ * Theory\", algorithm 1.5.1). 'p' must be prime, otherwise an error or+ * an incorrect \"result\" will be returned.  */ {",
            "commit_date": "2022-02-28 18:26:21+01:00",
            "commit_hash": "9eafb53614bf65797db25f467946e735e1b43dc9",
            "message": "Fix possible infinite loop in BN_mod_sqrt()\nThe calculation in some cases does not finish for non-prime p.\nThis fixes CVE-2022-0778.\nBased on patch by David Benjamin <davidben@google.com>.\nReviewed-by: Paul Dale <pauli@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nint used_ctx = 0;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nused_ctx = 1;\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* Subject: Square Roots and Cognate Matters modulo p=8n+5.\n* URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))"
        },
        {
            "author": {
                "email": "agustingianni@gmail.com",
                "name": "Agustin Gianni"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,134 +12,136 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {+    int used_ctx = 0;+    used_ctx = 1;",
            "commit_date": "2021-01-08 16:04:05+01:00",
            "commit_hash": "48116c2d0fbb1db875e2bc703c08089bf3c5c5c3",
            "message": "Fix incorrect use of BN_CTX API\nIn some edge cases BN_CTX_end was being called without first calling\nBN_CTX_start. This creates a situation where the state of the big\nnumber allocator is corrupted and may lead to crashes.\nFixes #13812\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Tomas Mraz <tmraz@fedoraproject.org>\n(Merged from https://github.com/openssl/openssl/pull/13813)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* Subject: Square Roots and Cognate Matters modulo p=8n+5.\n* URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,134 +12,134 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+        ERR_raise(ERR_LIB_BN, BN_R_P_IS_NOT_PRIME);",
            "commit_date": "2020-11-04 12:23:19+01:00",
            "commit_hash": "9311d0c471ca2eaa259e8c1bbbeb7c46394c7ba2",
            "message": "Convert all {NAME}err() in crypto/ to their corresponding ERR_raise() call\nThis includes error reporting for libcrypto sub-libraries in surprising\nplaces.\nThis was done using util/err-to-raise\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/13318)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* Subject: Square Roots and Cognate Matters modulo p=8n+5.\n* URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))"
        },
        {
            "author": {
                "email": "bernd.edlinger@hotmail.de",
                "name": "Bernd Edlinger"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,133 +12,134 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-         * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+         * Subject: Square Roots and Cognate Matters modulo p=8n+5.+         * URL: https://listserv.nodak.edu/cgi-bin/wa.exe?A2=ind9211&L=NMBRTHRY&P=4026",
            "commit_date": "2019-06-10 10:24:35+02:00",
            "commit_hash": "e98e586b31386af2b2212729da85561a207e7af3",
            "message": "Fix a URL to the NMBRTHRY list archive\nReviewed-by: Matt Caswell <matt@openssl.org>\nReviewed-by: Richard Levitte <levitte@openssl.org>\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/9123)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn NULL;\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))"
        },
        {
            "author": {
                "email": "kunnpuu@gmail.com",
                "name": "KaoruToda"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -12,133 +12,133 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-        return (NULL);+        return NULL;",
            "commit_date": "2017-10-17 23:04:09+09:00",
            "commit_hash": "26a7d938c9bf932a55cb5e4e02abb48fe395c5cd",
            "message": "Remove parentheses of return.\nSince return is inconsistent, I removed unnecessary parentheses and\nunified them.\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/4541)\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -62,133 +62,133 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-                /*--                 * |p| == 5  (mod 8)-                 *-                 * In this case  2  is always a non-square since-                 * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.-                 * So if  a  really is a square, then  2*a  is a non-square.-                 * Thus for-                 *      b := (2*a)^((|p|-5)/8),-                 *      i := (2*a)*b^2-                 * we have-                 *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)-                 *         = (2*a)^((p-1)/2)-                 *         = -1;-                 * so if we set-                 *      x := a*b*(i-1),-                 * then-                 *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)-                 *         = a^2 * b^2 * (-2*i)-                 *         = a*(-i)*(2*a*b^2)-                 *         = a*(-i)*i-                 *         = a.-                 *-                 * (This is due to A.O.L. Atkin,-                 * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,-                 * November 1992.)-                 */+        /*-+         * |p| == 5  (mod 8)+         *+         * In this case  2  is always a non-square since+         * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+         * So if  a  really is a square, then  2*a  is a non-square.+         * Thus for+         *      b := (2*a)^((|p|-5)/8),+         *      i := (2*a)*b^2+         * we have+         *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)+         *         = (2*a)^((p-1)/2)+         *         = -1;+         * so if we set+         *      x := a*b*(i-1),+         * then+         *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+         *         = a^2 * b^2 * (-2*i)+         *         = a*(-i)*(2*a*b^2)+         *         = a*(-i)*i+         *         = a.+         *+         * (This is due to A.O.L. Atkin,+         * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+         * November 1992.)+         */",
            "commit_date": "2015-01-17 00:06:54+00:00",
            "commit_hash": "35a1cc90bc1795e8893c11e442790ee7f659fffb",
            "message": "More comment realignment\nReviewed-by: Tim Hudson <tjh@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn (NULL);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\n/*-\n* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse\n* modulo  (|p|-1)/2,  and square roots can be computed\n* directly by modular exponentiation.\n* We have\n*     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),\n* so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.\n*/\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -62,133 +62,133 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) /*  * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks  * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number  * Theory\", algorithm 1.5.1). 'p' must be prime!  */ {-                /*--                 * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse-                 * modulo  (|p|-1)/2,  and square roots can be computed-                 * directly by modular exponentiation.-                 * We have-                 *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),-                 * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.-                 */+        /*-+         * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+         * modulo  (|p|-1)/2,  and square roots can be computed+         * directly by modular exponentiation.+         * We have+         *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+         * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.+         */",
            "commit_date": "2015-01-05 11:30:03+00:00",
            "commit_hash": "50e735f9e5d220cdad7db690188b82a69ddcb39e",
            "message": "Re-align some comments after running the reformat script.\nThis should be a one off operation (subsequent invokation of the\nscript should not move them)\nReviewed-by: Tim Hudson <tjh@openssl.org>\nBIGNUM *ret = in;\nint err = 1;\nint r;\nBIGNUM *A, *b, *q, *t, *x, *y;\nint e, i, j;\nif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {\nif (BN_abs_is_word(p, 2)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_bit_set(a, 0))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);\nreturn (NULL);\n}\nif (BN_is_zero(a) || BN_is_one(a)) {\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\nif (!BN_set_word(ret, BN_is_one(a))) {\nif (ret != in)\nBN_free(ret);\nreturn NULL;\n}\nbn_check_top(ret);\nreturn ret;\n}\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nb = BN_CTX_get(ctx);\nq = BN_CTX_get(ctx);\nt = BN_CTX_get(ctx);\nx = BN_CTX_get(ctx);\ny = BN_CTX_get(ctx);\nif (y == NULL)\ngoto end;\nif (ret == NULL)\nret = BN_new();\nif (ret == NULL)\ngoto end;\n/* A = a mod p */\nif (!BN_nnmod(A, a, p, ctx))\ngoto end;\n/* now write  |p| - 1  as  2^e*q  where  q  is odd */\ne = 1;\nwhile (!BN_is_bit_set(p, e))\ne++;\n/* we'll set  q  later (if needed) */\nif (e == 1) {\nif (!BN_rshift(q, p, 2))\ngoto end;\nq->neg = 0;\nif (!BN_add_word(q, 1))\ngoto end;\nif (!BN_mod_exp(ret, A, q, p, ctx))\ngoto end;\nerr = 0;\ngoto vrfy;\n}\nif (e == 2) {\n/*-\n* |p| == 5  (mod 8)\n*\n* In this case  2  is always a non-square since\n* Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.\n* So if  a  really is a square, then  2*a  is a non-square.\n* Thus for\n*      b := (2*a)^((|p|-5)/8),\n*      i := (2*a)*b^2\n* we have\n*     i^2 = (2*a)^((1 + (|p|-5)/4)*2)\n*         = (2*a)^((p-1)/2)\n*         = -1;\n* so if we set\n*      x := a*b*(i-1),\n* then\n*     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)\n*         = a^2 * b^2 * (-2*i)\n*         = a*(-i)*(2*a*b^2)\n*         = a*(-i)*i\n*         = a.\n*\n* (This is due to A.O.L. Atkin,\n* <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,\n* November 1992.)\n*/\n/* t := 2*a */\nif (!BN_mod_lshift1_quick(t, A, p))\ngoto end;\n/* b := (2*a)^((|p|-5)/8) */\nif (!BN_rshift(q, p, 3))\ngoto end;\nq->neg = 0;\nif (!BN_mod_exp(b, t, q, p, ctx))\ngoto end;\n/* y := b^2 */\nif (!BN_mod_sqr(y, b, p, ctx))"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,308 +62,133 @@--BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) -/* Returns 'ret' such that- *      ret^2 == a (mod p),- * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course- * in Algebraic Computational Number Theory\", algorithm 1.5.1).- * 'p' must be prime!+BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)+/*+ * Returns 'ret' such that ret^2 == a (mod p), using the Tonelli/Shanks+ * algorithm (cf. Henri Cohen, \"A Course in Algebraic Computational Number+ * Theory\", algorithm 1.5.1). 'p' must be prime!  */-\t{-\tBIGNUM *ret = in;-\tint err = 1;-\tint r;-\tBIGNUM *A, *b, *q, *t, *x, *y;-\tint e, i, j;-\t-\tif (!BN_is_odd(p) || BN_abs_is_word(p, 1))-\t\t{-\t\tif (BN_abs_is_word(p, 2))-\t\t\t{-\t\t\tif (ret == NULL)-\t\t\t\tret = BN_new();-\t\t\tif (ret == NULL)-\t\t\t\tgoto end;-\t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0)))-\t\t\t\t{-\t\t\t\tif (ret != in)-\t\t\t\t\tBN_free(ret);-\t\t\t\treturn NULL;-\t\t\t\t}-\t\t\tbn_check_top(ret);-\t\t\treturn ret;-\t\t\t}--\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\treturn(NULL);-\t\t}--\tif (BN_is_zero(a) || BN_is_one(a))-\t\t{-\t\tif (ret == NULL)-\t\t\tret = BN_new();-\t\tif (ret == NULL)-\t\t\tgoto end;-\t\tif (!BN_set_word(ret, BN_is_one(a)))-\t\t\t{-\t\t\tif (ret != in)-\t\t\t\tBN_free(ret);-\t\t\treturn NULL;-\t\t\t}-\t\tbn_check_top(ret);-\t\treturn ret;-\t\t}--\tBN_CTX_start(ctx);-\tA = BN_CTX_get(ctx);-\tb = BN_CTX_get(ctx);-\tq = BN_CTX_get(ctx);-\tt = BN_CTX_get(ctx);-\tx = BN_CTX_get(ctx);-\ty = BN_CTX_get(ctx);-\tif (y == NULL) goto end;-\t-\tif (ret == NULL)-\t\tret = BN_new();-\tif (ret == NULL) goto end;--\t/* A = a mod p */-\tif (!BN_nnmod(A, a, p, ctx)) goto end;--\t/* now write  |p| - 1  as  2^e*q  where  q  is odd */-\te = 1;-\twhile (!BN_is_bit_set(p, e))-\t\te++;-\t/* we'll set  q  later (if needed) */--\tif (e == 1)-\t\t{-\t\t/*--\t\t * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse-\t\t * modulo  (|p|-1)/2,  and square roots can be computed-\t\t * directly by modular exponentiation.-\t\t * We have-\t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),-\t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.-\t\t */-\t\tif (!BN_rshift(q, p, 2)) goto end;-\t\tq->neg = 0;-\t\tif (!BN_add_word(q, 1)) goto end;-\t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end;-\t\terr = 0;-\t\tgoto vrfy;-\t\t}-\t-\tif (e == 2)-\t\t{-\t\t/*--\t\t * |p| == 5  (mod 8)-\t\t *-\t\t * In this case  2  is always a non-square since-\t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.-\t\t * So if  a  really is a square, then  2*a  is a non-square.-\t\t * Thus for-\t\t *      b := (2*a)^((|p|-5)/8),-\t\t *      i := (2*a)*b^2-\t\t * we have-\t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)-\t\t *         = (2*a)^((p-1)/2)-\t\t *         = -1;-\t\t * so if we set-\t\t *      x := a*b*(i-1),-\t\t * then-\t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)-\t\t *         = a^2 * b^2 * (-2*i)-\t\t *         = a*(-i)*(2*a*b^2)-\t\t *         = a*(-i)*i-\t\t *         = a.-\t\t *-\t\t * (This is due to A.O.L. Atkin, -\t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,-\t\t * November 1992.)-\t\t */--\t\t/* t := 2*a */-\t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end;--\t\t/* b := (2*a)^((|p|-5)/8) */-\t\tif (!BN_rshift(q, p, 3)) goto end;-\t\tq->neg = 0;-\t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end;--\t\t/* y := b^2 */-\t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end;--\t\t/* t := (2*a)*b^2 - 1*/-\t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;-\t\tif (!BN_sub_word(t, 1)) goto end;--\t\t/* x = a*b*t */-\t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end;-\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;--\t\tif (!BN_copy(ret, x)) goto end;-\t\terr = 0;-\t\tgoto vrfy;-\t\t}-\t-\t/* e > 2, so we really have to use the Tonelli/Shanks algorithm.-\t * First, find some  y  that is not a square. */-\tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */-\tq->neg = 0;-\ti = 2;-\tdo-\t\t{-\t\t/* For efficiency, try small numbers first;-\t\t * if this fails, try random numbers.-\t\t */-\t\tif (i < 22)-\t\t\t{-\t\t\tif (!BN_set_word(y, i)) goto end;-\t\t\t}-\t\telse-\t\t\t{-\t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end;-\t\t\tif (BN_ucmp(y, p) >= 0)-\t\t\t\t{-\t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end;-\t\t\t\t}-\t\t\t/* now 0 <= y < |p| */-\t\t\tif (BN_is_zero(y))-\t\t\t\tif (!BN_set_word(y, i)) goto end;-\t\t\t}-\t\t-\t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */-\t\tif (r < -1) goto end;-\t\tif (r == 0)-\t\t\t{-\t\t\t/* m divides p */-\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\t\tgoto end;-\t\t\t}-\t\t}-\twhile (r == 1 && ++i < 82);-\t-\tif (r != -1)-\t\t{-\t\t/* Many rounds and still no non-square -- this is more likely-\t\t * a bug than just bad luck.-\t\t * Even if  p  is not prime, we should have found some  y-\t\t * such that r == -1.-\t\t */-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);-\t\tgoto end;-\t\t}--\t/* Here's our actual 'q': */-\tif (!BN_rshift(q, q, e)) goto end;--\t/* Now that we have some non-square, we can find an element-\t * of order  2^e  by computing its q'th power. */-\tif (!BN_mod_exp(y, y, q, p, ctx)) goto end;-\tif (BN_is_one(y))-\t\t{-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);-\t\tgoto end;-\t\t}--\t/*--\t * Now we know that (if  p  is indeed prime) there is an integer-\t * k,  0 <= k < 2^e,  such that-\t *-\t *      a^q * y^k == 1   (mod p).-\t *-\t * As  a^q  is a square and  y  is not,  k  must be even.-\t * q+1  is even, too, so there is an element-\t *-\t *     X := a^((q+1)/2) * y^(k/2),-\t *-\t * and it satisfies-\t *-\t *     X^2 = a^q * a     * y^k-\t *         = a,-\t *-\t * so it is the square root that we are looking for.-\t */-\t-\t/* t := (q-1)/2  (note that  q  is odd) */-\tif (!BN_rshift1(t, q)) goto end;-\t-\t/* x := a^((q-1)/2) */-\tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */-\t\t{-\t\tif (!BN_nnmod(t, A, p, ctx)) goto end;-\t\tif (BN_is_zero(t))-\t\t\t{-\t\t\t/* special case: a == 0  (mod p) */-\t\t\tBN_zero(ret);-\t\t\terr = 0;-\t\t\tgoto end;-\t\t\t}-\t\telse-\t\t\tif (!BN_one(x)) goto end;-\t\t}-\telse-\t\t{-\t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end;-\t\tif (BN_is_zero(x))-\t\t\t{-\t\t\t/* special case: a == 0  (mod p) */-\t\t\tBN_zero(ret);-\t\t\terr = 0;-\t\t\tgoto end;-\t\t\t}-\t\t}--\t/* b := a*x^2  (= a^q) */-\tif (!BN_mod_sqr(b, x, p, ctx)) goto end;-\tif (!BN_mod_mul(b, b, A, p, ctx)) goto end;-\t-\t/* x := a*x    (= a^((q+1)/2)) */-\tif (!BN_mod_mul(x, x, A, p, ctx)) goto end;--\twhile (1)-\t\t{-\t\t/*- -\t\t * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E-\t\t * where  E  refers to the original value of  e,  which we-\t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).-\t\t *-\t\t * We have  a*b = x^2,-\t\t *    y^2^(e-1) = -1,-\t\t *    b^2^(e-1) = 1.-\t\t */--\t\tif (BN_is_one(b))-\t\t\t{-\t\t\tif (!BN_copy(ret, x)) goto end;-\t\t\terr = 0;-\t\t\tgoto vrfy;-\t\t\t}---\t\t/* find smallest  i  such that  b^(2^i) = 1 */-\t\ti = 1;-\t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end;-\t\twhile (!BN_is_one(t))-\t\t\t{-\t\t\ti++;-\t\t\tif (i == e)-\t\t\t\t{-\t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);-\t\t\t\tgoto end;-\t\t\t\t}-\t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end;-\t\t\t}-\t\t--\t\t/* t := y^2^(e - i - 1) */-\t\tif (!BN_copy(t, y)) goto end;-\t\tfor (j = e - i - 1; j > 0; j--)-\t\t\t{-\t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end;-\t\t\t}-\t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end;-\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;-\t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end;-\t\te = i;-\t\t}+{+    BIGNUM *ret = in;+    int err = 1;+    int r;+    BIGNUM *A, *b, *q, *t, *x, *y;+    int e, i, j;++    if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) {+        if (BN_abs_is_word(p, 2)) {+            if (ret == NULL)+                ret = BN_new();+            if (ret == NULL)+                goto end;+            if (!BN_set_word(ret, BN_is_bit_set(a, 0))) {+                if (ret != in)+                    BN_free(ret);+                return NULL;+            }+            bn_check_top(ret);+            return ret;+        }++        BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+        return (NULL);+    }++    if (BN_is_zero(a) || BN_is_one(a)) {+        if (ret == NULL)+            ret = BN_new();+        if (ret == NULL)+            goto end;+        if (!BN_set_word(ret, BN_is_one(a))) {+            if (ret != in)+                BN_free(ret);+            return NULL;+        }+        bn_check_top(ret);+        return ret;+    }++    BN_CTX_start(ctx);+    A = BN_CTX_get(ctx);+    b = BN_CTX_get(ctx);+    q = BN_CTX_get(ctx);+    t = BN_CTX_get(ctx);+    x = BN_CTX_get(ctx);+    y = BN_CTX_get(ctx);+    if (y == NULL)+        goto end;++    if (ret == NULL)+        ret = BN_new();+    if (ret == NULL)+        goto end;++    /* A = a mod p */+    if (!BN_nnmod(A, a, p, ctx))+        goto end;++    /* now write  |p| - 1  as  2^e*q  where  q  is odd */+    e = 1;+    while (!BN_is_bit_set(p, e))+        e++;+    /* we'll set  q  later (if needed) */++    if (e == 1) {+                /*-+                 * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+                 * modulo  (|p|-1)/2,  and square roots can be computed+                 * directly by modular exponentiation.+                 * We have+                 *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+                 * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1.+                 */+        if (!BN_rshift(q, p, 2))+            goto end;+        q->neg = 0;+        if (!BN_add_word(q, 1))+            goto end;+        if (!BN_mod_exp(ret, A, q, p, ctx))+            goto end;+        err = 0;+        goto vrfy;+    }++    if (e == 2) {+                /*-+                 * |p| == 5  (mod 8)+                 *+                 * In this case  2  is always a non-square since+                 * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+                 * So if  a  really is a square, then  2*a  is a non-square.+                 * Thus for+                 *      b := (2*a)^((|p|-5)/8),+                 *      i := (2*a)*b^2+                 * we have+                 *     i^2 = (2*a)^((1 + (|p|-5)/4)*2)+                 *         = (2*a)^((p-1)/2)+                 *         = -1;+                 * so if we set+                 *      x := a*b*(i-1),+                 * then+                 *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+                 *         = a^2 * b^2 * (-2*i)+                 *         = a*(-i)*(2*a*b^2)+                 *         = a*(-i)*i+                 *         = a.+                 *+                 * (This is due to A.O.L. Atkin,+                 * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+                 * November 1992.)+                 */++        /* t := 2*a */+        if (!BN_mod_lshift1_quick(t, A, p))+            goto end;++        /* b := (2*a)^((|p|-5)/8) */+        if (!BN_rshift(q, p, 3))+            goto end;+        q->neg = 0;+        if (!BN_mod_exp(b, t, q, p, ctx))+            goto end;++        /* y := b^2 */+        if (!BN_mod_sqr(y, b, p, ctx))",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "tjh@openssl.org",
                "name": "Tim Hudson"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,304 +60,308 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tif (ret != in) \t\t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tif (ret != in) \t\t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{-\t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+\t\t/*-+\t\t * The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{-\t\t/* |p| == 5  (mod 8)+\t\t/*-+\t\t * |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t}-\t/* Now we know that (if  p  is indeed prime) there is an integer+\t/*-+\t * Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{-\t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E+\t\t/*- +\t\t * Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2014-12-28 12:48:40+10:00",
            "commit_hash": "1d97c8435171a7af575f73c526d79e1ef0ee5960",
            "message": "mark all block comments that need format preserving so that\nindent will not alter them when reformatting comments\nReviewed-by: Rich Salz <rsalz@openssl.org>\nReviewed-by: Matt Caswell <matt@openssl.org>"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,304 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{-\t\t\t\tBN_free(ret);+\t\t\t\tif (ret != in)+\t\t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{-\t\t\tBN_free(ret);+\t\t\tif (ret != in)+\t\t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2005-08-23 04:14:40+00:00",
            "commit_hash": "7534d131d676431f1299618dfe0decd1a42680bb",
            "message": "avoid potential spurious BN_free()\nSubmitted by: David Heine <dlheine@suif.Stanford.EDU>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */-\t\t\tif (!BN_zero(ret)) goto end;+\t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */-\t\t\tif (!BN_zero(ret)) goto end;+\t\t\tBN_zero(ret); \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2004-03-13 23:57:20+00:00",
            "commit_hash": "b6358c89a10128692875fb92921b663c4d079a1e",
            "message": "Convert openssl code not to assume the deprecated form of BN_zero().\nRemove certain redundant BN_zero() initialisations, because BN_CTX_get(),\nBN_init(), [etc] already initialise to zero.\nCorrect error checking in bn_sqr.c, and be less wishy-wash about how/why\nthe result's 'top' value is set (note also, 'max' is always > 0 at this\npoint)."
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,300 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t}+\t\t\tbn_check_top(ret); \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t}+\t\tbn_check_top(ret); \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2003-11-04 22:54:49+00:00",
            "commit_hash": "d870740cd75dd4f0cb66fb8c32653a7d47369706",
            "message": "Put the first stage of my bignum debugging adventures into CVS. This code\nis itself experimental, and in addition may cause execution to break on\nexisting openssl \"bugs\" that previously were harmless or at least\ninvisible."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,302 +60,300 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!- * If 'a' is not a square, this is not necessarily detected by- * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 15:13:10+00:00",
            "commit_hash": "d3bcbba45c4f161d88e30fd8b0434e8e24202681",
            "message": "remove obsolete part of comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,312 +60,302 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  * If 'a' is not a square, this is not necessarily detected by  * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t}-#if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */-\tr = BN_kronecker(a, p, ctx);-\tif (r < -1) return NULL;-\tif (r == -1)-\t\t{-\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);-\t\treturn(NULL);-\t\t}-#endif- \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* A = a mod p */ \tif (!BN_nnmod(A, a, p, ctx)) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 15:07:08+00:00",
            "commit_hash": "0903e56196a1a265dd9397e1e09a22aa4766914e",
            "message": "remove obsoleted disabled code"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,315 +60,312 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  * If 'a' is not a square, this is not necessarily detected by  * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r;-\tBIGNUM *b, *q, *t, *x, *y;+\tBIGNUM *A, *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx);+\tA = BN_CTX_get(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end;+\t/* A = a mod p */+\tif (!BN_nnmod(A, a, p, ctx)) goto end;+ \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end;-\t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end;+\t\tif (!BN_mod_exp(ret, A, q, p, ctx)) goto end; \t\terr = 0;-\t\tgoto end;+\t\tgoto vrfy; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */-\t\t/* make sure that  a  is reduced modulo p */-\t\tif (a->neg || BN_ucmp(a, p) >= 0)-\t\t\t{-\t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end;-\t\t\ta = x; /* use x as temporary variable */-\t\t\t}- \t\t/* t := 2*a */-\t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;+\t\tif (!BN_mod_lshift1_quick(t, A, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */-\t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, A, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0;-\t\tgoto end;+\t\tgoto vrfy; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{-\t\tif (!BN_nnmod(t, a, p, ctx)) goto end;+\t\tif (!BN_nnmod(t, A, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{-\t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end;+\t\tif (!BN_mod_exp(x, A, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end;-\tif (!BN_mod_mul(b, b, a, p, ctx)) goto end;+\tif (!BN_mod_mul(b, b, A, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */-\tif (!BN_mod_mul(x, x, a, p, ctx)) goto end;+\tif (!BN_mod_mul(x, x, A, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0;-\t\t\tgoto end;+\t\t\tgoto vrfy; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2002-08-02 14:57:53+00:00",
            "commit_hash": "6fb60a84dd1ec81953917e0444dab50186617432",
            "message": "Change BN_mod_sqrt() so that it verifies that the input value is\nreally the square of the return value."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,313 +60,315 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!+ * If 'a' is not a square, this is not necessarily detected by+ * the algorithms; a bogus result must be expected in this case.  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{ \t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse \t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2), \t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */ \tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Here's our actual 'q': */ \tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2001-03-08 16:53:30+00:00",
            "commit_hash": "ff612904d277b6e4f8118913e1278a1afc75e073",
            "message": "Comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,314 +60,313 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++;-\tif (e > 2)-\t\t{-\t\t/* we don't need this  q  if  e = 1 or 2 */-\t\tif (!BN_rshift(q, p, e)) goto end;-\t\tq->neg = 0;-\t\t}+\t/* we'll set  q  later (if needed) */ \tif (e == 1) \t\t{-\t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse-\t\t * modulo  (p-1)/2,  and square roots can be computed+\t\t/* The easy case:  (|p|-1)/2  is odd, so 2 has an inverse+\t\t * modulo  (|p|-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have-\t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),-\t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1.+\t\t *     2 * (|p|+1)/4 == 1   (mod (|p|-1)/2),+\t\t * so we can use exponent  (|p|+1)/4,  i.e.  (|p|-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{-\t\t/* p == 5  (mod 8)+\t\t/* |p| == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for-\t\t *      b := (2*a)^((p-5)/8),+\t\t *      b := (2*a)^((|p|-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have-\t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2)+\t\t *     i^2 = (2*a)^((1 + (|p|-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;-\t\t/* b := (2*a)^((p-5)/8) */+\t\t/* b := (2*a)^((|p|-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */+\tif (!BN_copy(q, p)) goto end; /* use 'q' as temp */+\tq->neg = 0; \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t}-\t\tr = BN_kronecker(y, p, ctx);+\t\tr = BN_kronecker(y, q, ctx); /* here 'q' is |p| */ \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t}+\t/* Here's our actual 'q': */+\tif (!BN_rshift(q, q, e)) goto end; \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-07 08:48:58+00:00",
            "commit_hash": "80d89e6a6aa6d9520336c78877c3cccb54c881cd",
            "message": "Sign-related fixes (and tests).\nBN_mod_exp_mont does not work properly yet if modulus m\nis negative (we want computations to be carried out\nmodulo |m|)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,310 +60,314 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (e > 2)+\t\t{ \t\t/* we don't need this  q  if  e = 1 or 2 */ \t\tif (!BN_rshift(q, p, e)) goto end;-\tq->neg = 0;+\t\tq->neg = 0;+\t\t} \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end;+\t\tq->neg = 0; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* p == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((p-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((p-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end;+\t\tq->neg = 0; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end; \t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-07 07:55:26+00:00",
            "commit_hash": "bc5f2740d2a427d5e16bfb12aa8b70d5a5adcfc8",
            "message": "Move 'q->neg = 0' to those places where it is needed\n(just in cases someone uses a negative modulus)"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,310 +60,310 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} \tif (BN_is_zero(a) || BN_is_one(a)) \t\t{ \t\tif (ret == NULL) \t\t\tret = BN_new(); \t\tif (ret == NULL) \t\t\tgoto end; \t\tif (!BN_set_word(ret, BN_is_one(a))) \t\t\t{ \t\t\tBN_free(ret); \t\t\treturn NULL; \t\t\t} \t\treturn ret; \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (e > 2) \t\t/* we don't need this  q  if  e = 1 or 2 */ \t\tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */ \t\tif (!BN_rshift(q, p, 2)) goto end; \t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \tif (e == 2) \t\t{ \t\t/* p == 5  (mod 8) \t\t * \t\t * In this case  2  is always a non-square since \t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime. \t\t * So if  a  really is a square, then  2*a  is a non-square. \t\t * Thus for \t\t *      b := (2*a)^((p-5)/8), \t\t *      i := (2*a)*b^2 \t\t * we have \t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2) \t\t *         = (2*a)^((p-1)/2) \t\t *         = -1; \t\t * so if we set \t\t *      x := a*b*(i-1), \t\t * then \t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1) \t\t *         = a^2 * b^2 * (-2*i) \t\t *         = a*(-i)*(2*a*b^2) \t\t *         = a*(-i)*i \t\t *         = a. \t\t * \t\t * (This is due to A.O.L. Atkin,  \t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>, \t\t * November 1992.) \t\t */ \t\t/* make sure that  a  is reduced modulo p */ \t\tif (a->neg || BN_ucmp(a, p) >= 0) \t\t\t{ \t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end; \t\t\ta = x; /* use x as temporary variable */ \t\t\t} \t\t/* t := 2*a */ \t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end; \t\t/* b := (2*a)^((p-5)/8) */ \t\tif (!BN_rshift(q, p, 3)) goto end; \t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end; \t\t/* y := b^2 */ \t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end; \t\t/* t := (2*a)*b^2 - 1*/ \t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;-\t\tif (!BN_sub_word(t, 1)) goto end; /* cannot become negative */+\t\tif (!BN_sub_word(t, 1)) goto end; \t\t/* x = a*b*t */ \t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_copy(ret, x)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-06 21:33:58+00:00",
            "commit_hash": "aa66eba7c8c7496db92b80da19688d6f96a40b96",
            "message": "BN_mod_sqrt documentation/comment"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,236 +60,310 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t}+\tif (BN_is_zero(a) || BN_is_one(a))+\t\t{+\t\tif (ret == NULL)+\t\t\tret = BN_new();+\t\tif (ret == NULL)+\t\t\tgoto end;+\t\tif (!BN_set_word(ret, BN_is_one(a)))+\t\t\t{+\t\t\tBN_free(ret);+\t\t\treturn NULL;+\t\t\t}+\t\treturn ret;+\t\t}+ #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++;-\tif (!BN_rshift(q, p, e)) goto end;+\tif (e > 2)+\t\t/* we don't need this  q  if  e = 1 or 2 */+\t\tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),-\t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2.+\t\t * so we can use exponent  (p+1)/4,  i.e.  (p-3)/4 + 1. \t\t */-\t\tif (!BN_add_word(q,1)) goto end;-\t\tif (!BN_rshift1(q,q)) goto end;+\t\tif (!BN_rshift(q, p, 2)) goto end;+\t\tif (!BN_add_word(q, 1)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t}-\t/* e > 1, so we really have to use the Tonelli/Shanks algorithm.+\tif (e == 2)+\t\t{+\t\t/* p == 5  (mod 8)+\t\t *+\t\t * In this case  2  is always a non-square since+\t\t * Legendre(2,p) = (-1)^((p^2-1)/8)  for any odd prime.+\t\t * So if  a  really is a square, then  2*a  is a non-square.+\t\t * Thus for+\t\t *      b := (2*a)^((p-5)/8),+\t\t *      i := (2*a)*b^2+\t\t * we have+\t\t *     i^2 = (2*a)^((1 + (p-5)/4)*2)+\t\t *         = (2*a)^((p-1)/2)+\t\t *         = -1;+\t\t * so if we set+\t\t *      x := a*b*(i-1),+\t\t * then+\t\t *     x^2 = a^2 * b^2 * (i^2 - 2*i + 1)+\t\t *         = a^2 * b^2 * (-2*i)+\t\t *         = a*(-i)*(2*a*b^2)+\t\t *         = a*(-i)*i+\t\t *         = a.+\t\t *+\t\t * (This is due to A.O.L. Atkin, +\t\t * <URL: http://listserv.nodak.edu/scripts/wa.exe?A2=ind9211&L=nmbrthry&O=T&P=562>,+\t\t * November 1992.)+\t\t */++\t\t/* make sure that  a  is reduced modulo p */+\t\tif (a->neg || BN_ucmp(a, p) >= 0)+\t\t\t{+\t\t\tif (!BN_nnmod(x, a, p, ctx)) goto end;+\t\t\ta = x; /* use x as temporary variable */+\t\t\t}++\t\t/* t := 2*a */+\t\tif (!BN_mod_lshift1_quick(t, a, p)) goto end;++\t\t/* b := (2*a)^((p-5)/8) */+\t\tif (!BN_rshift(q, p, 3)) goto end;+\t\tif (!BN_mod_exp(b, t, q, p, ctx)) goto end;++\t\t/* y := b^2 */+\t\tif (!BN_mod_sqr(y, b, p, ctx)) goto end;++\t\t/* t := (2*a)*b^2 - 1*/+\t\tif (!BN_mod_mul(t, t, y, p, ctx)) goto end;+\t\tif (!BN_sub_word(t, 1)) goto end; /* cannot become negative */++\t\t/* x = a*b*t */+\t\tif (!BN_mod_mul(x, a, b, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;++\t\tif (!BN_copy(ret, x)) goto end;+\t\terr = 0;+\t\tgoto end;+\t\t}+\t+\t/* e > 2, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */ \ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */ \t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t} \twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-12-06 12:25:33+00:00",
            "commit_hash": "bac685417a0890642bada45bfaf1e44de9c92beb",
            "message": "Faster BN_mod_sqrt algorithm for p == 5 (8)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -60,236 +60,236 @@ BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx)  /* Returns 'ret' such that  *      ret^2 == a (mod p),  * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course  * in Algebraic Computational Number Theory\", algorithm 1.5.1).  * 'p' must be prime!  */ \t{ \tBIGNUM *ret = in; \tint err = 1; \tint r; \tBIGNUM *b, *q, *t, *x, *y; \tint e, i, j; \tif (!BN_is_odd(p) || BN_abs_is_word(p, 1)) \t\t{ \t\tif (BN_abs_is_word(p, 2)) \t\t\t{ \t\t\tif (ret == NULL) \t\t\t\tret = BN_new(); \t\t\tif (ret == NULL) \t\t\t\tgoto end; \t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0))) \t\t\t\t{ \t\t\t\tBN_free(ret); \t\t\t\treturn NULL; \t\t\t\t} \t\t\treturn ret; \t\t\t} \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\treturn(NULL); \t\t} #if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */ \tr = BN_kronecker(a, p, ctx); \tif (r < -1) return NULL; \tif (r == -1) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\treturn(NULL); \t\t} #endif \tBN_CTX_start(ctx); \tb = BN_CTX_get(ctx); \tq = BN_CTX_get(ctx); \tt = BN_CTX_get(ctx); \tx = BN_CTX_get(ctx); \ty = BN_CTX_get(ctx); \tif (y == NULL) goto end; \tif (ret == NULL) \t\tret = BN_new(); \tif (ret == NULL) goto end; \t/* now write  |p| - 1  as  2^e*q  where  q  is odd */ \te = 1; \twhile (!BN_is_bit_set(p, e)) \t\te++; \tif (!BN_rshift(q, p, e)) goto end; \tq->neg = 0; \tif (e == 1) \t\t{ \t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse \t\t * modulo  (p-1)/2,  and square roots can be computed \t\t * directly by modular exponentiation. \t\t * We have \t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2), \t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2. \t\t */ \t\tif (!BN_add_word(q,1)) goto end; \t\tif (!BN_rshift1(q,q)) goto end; \t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end; \t\terr = 0; \t\tgoto end; \t\t} \t/* e > 1, so we really have to use the Tonelli/Shanks algorithm. \t * First, find some  y  that is not a square. */-\ti = 1;+\ti = 2; \tdo \t\t{ \t\t/* For efficiency, try small numbers first; \t\t * if this fails, try random numbers. \t\t */-\t\tif (i < 20)+\t\tif (i < 22) \t\t\t{ \t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\telse \t\t\t{ \t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end; \t\t\tif (BN_ucmp(y, p) >= 0) \t\t\t\t{ \t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end; \t\t\t\t} \t\t\t/* now 0 <= y < |p| */ \t\t\tif (BN_is_zero(y)) \t\t\t\tif (!BN_set_word(y, i)) goto end; \t\t\t} \t\tr = BN_kronecker(y, p, ctx); \t\tif (r < -1) goto end; \t\tif (r == 0) \t\t\t{ \t\t\t/* m divides p */ \t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\t\tgoto end; \t\t\t} \t\t}-\twhile (r == 1 && i++ < 80);+\twhile (r == 1 && ++i < 82); \tif (r != -1) \t\t{ \t\t/* Many rounds and still no non-square -- this is more likely \t\t * a bug than just bad luck. \t\t * Even if  p  is not prime, we should have found some  y \t\t * such that r == -1. \t\t */ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); \t\tgoto end; \t\t} \t/* Now that we have some non-square, we can find an element \t * of order  2^e  by computing its q'th power. */ \tif (!BN_mod_exp(y, y, q, p, ctx)) goto end; \tif (BN_is_one(y)) \t\t{ \t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); \t\tgoto end; \t\t} \t/* Now we know that (if  p  is indeed prime) there is an integer \t * k,  0 <= k < 2^e,  such that \t * \t *      a^q * y^k == 1   (mod p). \t * \t * As  a^q  is a square and  y  is not,  k  must be even. \t * q+1  is even, too, so there is an element \t * \t *     X := a^((q+1)/2) * y^(k/2), \t * \t * and it satisfies \t * \t *     X^2 = a^q * a     * y^k \t *         = a, \t * \t * so it is the square root that we are looking for. \t */ \t/* t := (q-1)/2  (note that  q  is odd) */ \tif (!BN_rshift1(t, q)) goto end; \t/* x := a^((q-1)/2) */ \tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */ \t\t{ \t\tif (!BN_nnmod(t, a, p, ctx)) goto end; \t\tif (BN_is_zero(t)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\telse \t\t\tif (!BN_one(x)) goto end; \t\t} \telse \t\t{ \t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end; \t\tif (BN_is_zero(x)) \t\t\t{ \t\t\t/* special case: a == 0  (mod p) */ \t\t\tif (!BN_zero(ret)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t} \t/* b := a*x^2  (= a^q) */ \tif (!BN_mod_sqr(b, x, p, ctx)) goto end; \tif (!BN_mod_mul(b, b, a, p, ctx)) goto end; \t/* x := a*x    (= a^((q+1)/2)) */ \tif (!BN_mod_mul(x, x, a, p, ctx)) goto end; \twhile (1) \t\t{ \t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E \t\t * where  E  refers to the original value of  e,  which we \t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2). \t\t * \t\t * We have  a*b = x^2, \t\t *    y^2^(e-1) = -1, \t\t *    b^2^(e-1) = 1. \t\t */ \t\tif (BN_is_one(b)) \t\t\t{ \t\t\tif (!BN_copy(ret, x)) goto end; \t\t\terr = 0; \t\t\tgoto end; \t\t\t} \t\t/* find smallest  i  such that  b^(2^i) = 1 */ \t\ti = 1; \t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end; \t\twhile (!BN_is_one(t)) \t\t\t{ \t\t\ti++; \t\t\tif (i == e) \t\t\t\t{ \t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); \t\t\t\tgoto end; \t\t\t\t} \t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end; \t\t\t} \t\t/* t := y^2^(e - i - 1) */ \t\tif (!BN_copy(t, y)) goto end; \t\tfor (j = e - i - 1; j > 0; j--) \t\t\t{ \t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end; \t\t\t} \t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end; \t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end; \t\te = i; \t\t}",
            "commit_date": "2000-11-30 09:45:26+00:00",
            "commit_hash": "25439b76adb66fe0ce6e012a9af1e1ce969a1479",
            "message": "Move reduction step from BN_mod_exp to BN_mod_exp_mont_word.\nFix BN_mod_exp_simple for a==0 (mod m).\nSkip useless round in BN_mod_sqrt (1 is always a square, no need\nto test BN_kronecker for it)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- a/crypto/bn/bn_sqrt.c+++ b/crypto/bn/bn_sqrt.c@@ -1,1 +60,236 @@-XXX+++BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) +/* Returns 'ret' such that+ *      ret^2 == a (mod p),+ * using the Tonelli/Shanks algorithm (cf. Henri Cohen, \"A Course+ * in Algebraic Computational Number Theory\", algorithm 1.5.1).+ * 'p' must be prime!+ */+\t{+\tBIGNUM *ret = in;+\tint err = 1;+\tint r;+\tBIGNUM *b, *q, *t, *x, *y;+\tint e, i, j;+\t+\tif (!BN_is_odd(p) || BN_abs_is_word(p, 1))+\t\t{+\t\tif (BN_abs_is_word(p, 2))+\t\t\t{+\t\t\tif (ret == NULL)+\t\t\t\tret = BN_new();+\t\t\tif (ret == NULL)+\t\t\t\tgoto end;+\t\t\tif (!BN_set_word(ret, BN_is_bit_set(a, 0)))+\t\t\t\t{+\t\t\t\tBN_free(ret);+\t\t\t\treturn NULL;+\t\t\t\t}+\t\t\treturn ret;+\t\t\t}++\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\treturn(NULL);+\t\t}++#if 0 /* if BN_mod_sqrt is used with correct input, this just wastes time */+\tr = BN_kronecker(a, p, ctx);+\tif (r < -1) return NULL;+\tif (r == -1)+\t\t{+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);+\t\treturn(NULL);+\t\t}+#endif++\tBN_CTX_start(ctx);+\tb = BN_CTX_get(ctx);+\tq = BN_CTX_get(ctx);+\tt = BN_CTX_get(ctx);+\tx = BN_CTX_get(ctx);+\ty = BN_CTX_get(ctx);+\tif (y == NULL) goto end;+\t+\tif (ret == NULL)+\t\tret = BN_new();+\tif (ret == NULL) goto end;++\t/* now write  |p| - 1  as  2^e*q  where  q  is odd */+\te = 1;+\twhile (!BN_is_bit_set(p, e))+\t\te++;+\tif (!BN_rshift(q, p, e)) goto end;+\tq->neg = 0;++\tif (e == 1)+\t\t{+\t\t/* The easy case:  (p-1)/2  is odd, so 2 has an inverse+\t\t * modulo  (p-1)/2,  and square roots can be computed+\t\t * directly by modular exponentiation.+\t\t * We have+\t\t *     2 * (p+1)/4 == 1   (mod (p-1)/2),+\t\t * so we can use exponent  (p+1)/4,  i.e.  (q+1)/2.+\t\t */+\t\tif (!BN_add_word(q,1)) goto end;+\t\tif (!BN_rshift1(q,q)) goto end;+\t\tif (!BN_mod_exp(ret, a, q, p, ctx)) goto end;+\t\terr = 0;+\t\tgoto end;+\t\t}+\t+\t/* e > 1, so we really have to use the Tonelli/Shanks algorithm.+\t * First, find some  y  that is not a square. */+\ti = 1;+\tdo+\t\t{+\t\t/* For efficiency, try small numbers first;+\t\t * if this fails, try random numbers.+\t\t */+\t\tif (i < 20)+\t\t\t{+\t\t\tif (!BN_set_word(y, i)) goto end;+\t\t\t}+\t\telse+\t\t\t{+\t\t\tif (!BN_pseudo_rand(y, BN_num_bits(p), 0, 0)) goto end;+\t\t\tif (BN_ucmp(y, p) >= 0)+\t\t\t\t{+\t\t\t\tif (!(p->neg ? BN_add : BN_sub)(y, y, p)) goto end;+\t\t\t\t}+\t\t\t/* now 0 <= y < |p| */+\t\t\tif (BN_is_zero(y))+\t\t\t\tif (!BN_set_word(y, i)) goto end;+\t\t\t}+\t\t+\t\tr = BN_kronecker(y, p, ctx);+\t\tif (r < -1) goto end;+\t\tif (r == 0)+\t\t\t{+\t\t\t/* m divides p */+\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\t\tgoto end;+\t\t\t}+\t\t}+\twhile (r == 1 && i++ < 80);+\t+\tif (r != -1)+\t\t{+\t\t/* Many rounds and still no non-square -- this is more likely+\t\t * a bug than just bad luck.+\t\t * Even if  p  is not prime, we should have found some  y+\t\t * such that r == -1.+\t\t */+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS);+\t\tgoto end;+\t\t}+++\t/* Now that we have some non-square, we can find an element+\t * of order  2^e  by computing its q'th power. */+\tif (!BN_mod_exp(y, y, q, p, ctx)) goto end;+\tif (BN_is_one(y))+\t\t{+\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME);+\t\tgoto end;+\t\t}++\t/* Now we know that (if  p  is indeed prime) there is an integer+\t * k,  0 <= k < 2^e,  such that+\t *+\t *      a^q * y^k == 1   (mod p).+\t *+\t * As  a^q  is a square and  y  is not,  k  must be even.+\t * q+1  is even, too, so there is an element+\t *+\t *     X := a^((q+1)/2) * y^(k/2),+\t *+\t * and it satisfies+\t *+\t *     X^2 = a^q * a     * y^k+\t *         = a,+\t *+\t * so it is the square root that we are looking for.+\t */+\t+\t/* t := (q-1)/2  (note that  q  is odd) */+\tif (!BN_rshift1(t, q)) goto end;+\t+\t/* x := a^((q-1)/2) */+\tif (BN_is_zero(t)) /* special case: p = 2^e + 1 */+\t\t{+\t\tif (!BN_nnmod(t, a, p, ctx)) goto end;+\t\tif (BN_is_zero(t))+\t\t\t{+\t\t\t/* special case: a == 0  (mod p) */+\t\t\tif (!BN_zero(ret)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+\t\telse+\t\t\tif (!BN_one(x)) goto end;+\t\t}+\telse+\t\t{+\t\tif (!BN_mod_exp(x, a, t, p, ctx)) goto end;+\t\tif (BN_is_zero(x))+\t\t\t{+\t\t\t/* special case: a == 0  (mod p) */+\t\t\tif (!BN_zero(ret)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+\t\t}++\t/* b := a*x^2  (= a^q) */+\tif (!BN_mod_sqr(b, x, p, ctx)) goto end;+\tif (!BN_mod_mul(b, b, a, p, ctx)) goto end;+\t+\t/* x := a*x    (= a^((q+1)/2)) */+\tif (!BN_mod_mul(x, x, a, p, ctx)) goto end;++\twhile (1)+\t\t{+\t\t/* Now  b  is  a^q * y^k  for some even  k  (0 <= k < 2^E+\t\t * where  E  refers to the original value of  e,  which we+\t\t * don't keep in a variable),  and  x  is  a^((q+1)/2) * y^(k/2).+\t\t *+\t\t * We have  a*b = x^2,+\t\t *    y^2^(e-1) = -1,+\t\t *    b^2^(e-1) = 1.+\t\t */++\t\tif (BN_is_one(b))+\t\t\t{+\t\t\tif (!BN_copy(ret, x)) goto end;+\t\t\terr = 0;+\t\t\tgoto end;+\t\t\t}+++\t\t/* find smallest  i  such that  b^(2^i) = 1 */+\t\ti = 1;+\t\tif (!BN_mod_sqr(t, b, p, ctx)) goto end;+\t\twhile (!BN_is_one(t))+\t\t\t{+\t\t\ti++;+\t\t\tif (i == e)+\t\t\t\t{+\t\t\t\tBNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE);+\t\t\t\tgoto end;+\t\t\t\t}+\t\t\tif (!BN_mod_mul(t, t, t, p, ctx)) goto end;+\t\t\t}+\t\t++\t\t/* t := y^2^(e - i - 1) */+\t\tif (!BN_copy(t, y)) goto end;+\t\tfor (j = e - i - 1; j > 0; j--)+\t\t\t{+\t\t\tif (!BN_mod_sqr(t, t, p, ctx)) goto end;+\t\t\t}+\t\tif (!BN_mod_mul(y, t, t, p, ctx)) goto end;+\t\tif (!BN_mod_mul(x, x, t, p, ctx)) goto end;+\t\tif (!BN_mod_mul(b, b, y, p, ctx)) goto end;+\t\te = i;+\t\t}",
            "commit_date": "2000-11-30 00:18:19+00:00",
            "commit_hash": "cd2eebfd6497ac1ca4d450960ba843f14643a9b2",
            "message": "BN_sqrt"
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_sqrt.c b/crypto/bn/bn_sqrt.c--- /dev/null+++ b/crypto/bn/bn_sqrt.c@@ -0,0 +1,1 @@+XXX",
            "commit_date": "2000-11-28 06:37:43+00:00",
            "commit_hash": "265592b99a3c2d5a8134d2c684620113153b4e1e",
            "message": "Add bn_kron.c (BN_kronecker), which I forgot in the previous commit.\nAlso add the next file in advance so that I can't forget this one :-)"
        }
    ],
    "git log -L16,44:crypto/bn/bn_kron.c": [
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_kron.c b/crypto/bn/bn_kron.c--- a/crypto/bn/bn_kron.c+++ b/crypto/bn/bn_kron.c@@ -62,29 +62,29 @@ /* Returns -2 for errors because both -1 and 0 are valid results. */ int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx) {-        /*--         * In 'tab', only odd-indexed entries are relevant:-         * For any odd BIGNUM n,-         *     tab[BN_lsw(n) & 7]-         * is $(-1)^{(n^2-1)/8}$ (using TeX notation).-         * Note that the sign of n does not matter.-         */+    /*-+     * In 'tab', only odd-indexed entries are relevant:+     * For any odd BIGNUM n,+     *     tab[BN_lsw(n) & 7]+     * is $(-1)^{(n^2-1)/8}$ (using TeX notation).+     * Note that the sign of n does not matter.+     */",
            "commit_date": "2015-01-17 00:06:54+00:00",
            "commit_hash": "35a1cc90bc1795e8893c11e442790ee7f659fffb",
            "message": "More comment realignment\nReviewed-by: Tim Hudson <tjh@openssl.org>\nint i;\nint ret = -2;               /* avoid 'uninitialized' warning */\nint err = 0;\nBIGNUM *A, *B, *tmp;\nstatic const int tab[8] = { 0, 1, 0, -1, 0, -1, 0, 1 };\nbn_check_top(a);\nbn_check_top(b);\nBN_CTX_start(ctx);\nA = BN_CTX_get(ctx);\nB = BN_CTX_get(ctx);\nif (B == NULL)\ngoto end;\nerr = !BN_copy(A, a);\nif (err)\ngoto end;\nerr = !BN_copy(B, b);"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_kron.c b/crypto/bn/bn_kron.c--- a/crypto/bn/bn_kron.c+++ b/crypto/bn/bn_kron.c@@ -62,124 +62,29 @@ /* Returns -2 for errors because both -1 and 0 are valid results. */ int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)-\t{-\tint i;-\tint ret = -2; /* avoid 'uninitialized' warning */-\tint err = 0;-\tBIGNUM *A, *B, *tmp;-\t/*--\t * In 'tab', only odd-indexed entries are relevant:-\t * For any odd BIGNUM n,-\t *     tab[BN_lsw(n) & 7]-\t * is $(-1)^{(n^2-1)/8}$ (using TeX notation).-\t * Note that the sign of n does not matter.-\t */-\tstatic const int tab[8] = {0, 1, 0, -1, 0, -1, 0, 1};--\tbn_check_top(a);-\tbn_check_top(b);--\tBN_CTX_start(ctx);-\tA = BN_CTX_get(ctx);-\tB = BN_CTX_get(ctx);-\tif (B == NULL) goto end;-\t-\terr = !BN_copy(A, a);-\tif (err) goto end;-\terr = !BN_copy(B, b);-\tif (err) goto end;--\t/*-\t * Kronecker symbol, imlemented according to Henri Cohen,-\t * \"A Course in Computational Algebraic Number Theory\"-\t * (algorithm 1.4.10).-\t */--\t/* Cohen's step 1: */--\tif (BN_is_zero(B))-\t\t{-\t\tret = BN_abs_is_word(A, 1);-\t\tgoto end;- \t\t}-\t-\t/* Cohen's step 2: */--\tif (!BN_is_odd(A) && !BN_is_odd(B))-\t\t{-\t\tret = 0;-\t\tgoto end;-\t\t}--\t/* now  B  is non-zero */-\ti = 0;-\twhile (!BN_is_bit_set(B, i))-\t\ti++;-\terr = !BN_rshift(B, B, i);-\tif (err) goto end;-\tif (i & 1)-\t\t{-\t\t/* i is odd */-\t\t/* (thus  B  was even, thus  A  must be odd!)  */--\t\t/* set 'ret' to $(-1)^{(A^2-1)/8}$ */-\t\tret = tab[BN_lsw(A) & 7];-\t\t}-\telse-\t\t{-\t\t/* i is even */-\t\tret = 1;-\t\t}-\t-\tif (B->neg)-\t\t{-\t\tB->neg = 0;-\t\tif (A->neg)-\t\t\tret = -ret;-\t\t}--\t/* now  B  is positive and odd, so what remains to be done is-\t * to compute the Jacobi symbol  (A/B)  and multiply it by 'ret' */--\twhile (1)-\t\t{-\t\t/* Cohen's step 3: */--\t\t/*  B  is positive and odd */--\t\tif (BN_is_zero(A))-\t\t\t{-\t\t\tret = BN_is_one(B) ? ret : 0;-\t\t\tgoto end;-\t\t\t}--\t\t/* now  A  is non-zero */-\t\ti = 0;-\t\twhile (!BN_is_bit_set(A, i))-\t\t\ti++;-\t\terr = !BN_rshift(A, A, i);-\t\tif (err) goto end;-\t\tif (i & 1)-\t\t\t{-\t\t\t/* i is odd */-\t\t\t/* multiply 'ret' by  $(-1)^{(B^2-1)/8}$ */-\t\t\tret = ret * tab[BN_lsw(B) & 7];-\t\t\t}-\t-\t\t/* Cohen's step 4: */-\t\t/* multiply 'ret' by  $(-1)^{(A-1)(B-1)/4}$ */-\t\tif ((A->neg ? ~BN_lsw(A) : BN_lsw(A)) & BN_lsw(B) & 2)-\t\t\tret = -ret;-\t\t-\t\t/* (A, B) := (B mod |A|, |A|) */-\t\terr = !BN_nnmod(B, B, A, ctx);-\t\tif (err) goto end;-\t\ttmp = A; A = B; B = tmp;-\t\ttmp->neg = 0;-\t\t}-end:-\tBN_CTX_end(ctx);-\tif (err)-\t\treturn -2;-\telse-\t\treturn ret;-\t}+{+    int i;+    int ret = -2;               /* avoid 'uninitialized' warning */+    int err = 0;+    BIGNUM *A, *B, *tmp;+        /*-+         * In 'tab', only odd-indexed entries are relevant:+         * For any odd BIGNUM n,+         *     tab[BN_lsw(n) & 7]+         * is $(-1)^{(n^2-1)/8}$ (using TeX notation).+         * Note that the sign of n does not matter.+         */+    static const int tab[8] = { 0, 1, 0, -1, 0, -1, 0, 1 };++    bn_check_top(a);+    bn_check_top(b);++    BN_CTX_start(ctx);+    A = BN_CTX_get(ctx);+    B = BN_CTX_get(ctx);+    if (B == NULL)+        goto end;++    err = !BN_copy(A, a);+    if (err)+        goto end;+    err = !BN_copy(B, b);",
            "commit_date": "2015-01-22 03:40:55+00:00",
            "commit_hash": "0f113f3ee4d629ef9a4a30911b22b224772085e5",
            "message": "Run util/openssl-format-source -v -c .\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "matt@openssl.org",
                "name": "Matt Caswell"
            },
            "changes": "diff --git a/crypto/bn/bn_kron.c b/crypto/bn/bn_kron.c--- a/crypto/bn/bn_kron.c+++ b/crypto/bn/bn_kron.c@@ -62,123 +62,124 @@ /* Returns -2 for errors because both -1 and 0 are valid results. */ int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx) \t{ \tint i; \tint ret = -2; /* avoid 'uninitialized' warning */ \tint err = 0; \tBIGNUM *A, *B, *tmp;-\t/* In 'tab', only odd-indexed entries are relevant:+\t/*-+\t * In 'tab', only odd-indexed entries are relevant: \t * For any odd BIGNUM n, \t *     tab[BN_lsw(n) & 7] \t * is $(-1)^{(n^2-1)/8}$ (using TeX notation). \t * Note that the sign of n does not matter. \t */ \tstatic const int tab[8] = {0, 1, 0, -1, 0, -1, 0, 1}; \tbn_check_top(a); \tbn_check_top(b); \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tB = BN_CTX_get(ctx); \tif (B == NULL) goto end; \terr = !BN_copy(A, a); \tif (err) goto end; \terr = !BN_copy(B, b); \tif (err) goto end; \t/* \t * Kronecker symbol, imlemented according to Henri Cohen, \t * \"A Course in Computational Algebraic Number Theory\" \t * (algorithm 1.4.10). \t */ \t/* Cohen's step 1: */ \tif (BN_is_zero(B)) \t\t{ \t\tret = BN_abs_is_word(A, 1); \t\tgoto end;  \t\t} \t/* Cohen's step 2: */ \tif (!BN_is_odd(A) && !BN_is_odd(B)) \t\t{ \t\tret = 0; \t\tgoto end; \t\t} \t/* now  B  is non-zero */ \ti = 0; \twhile (!BN_is_bit_set(B, i)) \t\ti++; \terr = !BN_rshift(B, B, i); \tif (err) goto end; \tif (i & 1) \t\t{ \t\t/* i is odd */ \t\t/* (thus  B  was even, thus  A  must be odd!)  */ \t\t/* set 'ret' to $(-1)^{(A^2-1)/8}$ */ \t\tret = tab[BN_lsw(A) & 7]; \t\t} \telse \t\t{ \t\t/* i is even */ \t\tret = 1; \t\t} \tif (B->neg) \t\t{ \t\tB->neg = 0; \t\tif (A->neg) \t\t\tret = -ret; \t\t} \t/* now  B  is positive and odd, so what remains to be done is \t * to compute the Jacobi symbol  (A/B)  and multiply it by 'ret' */ \twhile (1) \t\t{ \t\t/* Cohen's step 3: */ \t\t/*  B  is positive and odd */ \t\tif (BN_is_zero(A)) \t\t\t{ \t\t\tret = BN_is_one(B) ? ret : 0; \t\t\tgoto end; \t\t\t} \t\t/* now  A  is non-zero */ \t\ti = 0; \t\twhile (!BN_is_bit_set(A, i)) \t\t\ti++; \t\terr = !BN_rshift(A, A, i); \t\tif (err) goto end; \t\tif (i & 1) \t\t\t{ \t\t\t/* i is odd */ \t\t\t/* multiply 'ret' by  $(-1)^{(B^2-1)/8}$ */ \t\t\tret = ret * tab[BN_lsw(B) & 7]; \t\t\t} \t\t/* Cohen's step 4: */ \t\t/* multiply 'ret' by  $(-1)^{(A-1)(B-1)/4}$ */ \t\tif ((A->neg ? ~BN_lsw(A) : BN_lsw(A)) & BN_lsw(B) & 2) \t\t\tret = -ret; \t\t/* (A, B) := (B mod |A|, |A|) */ \t\terr = !BN_nnmod(B, B, A, ctx); \t\tif (err) goto end; \t\ttmp = A; A = B; B = tmp; \t\ttmp->neg = 0; \t\t} end: \tBN_CTX_end(ctx); \tif (err) \t\treturn -2; \telse \t\treturn ret; \t}",
            "commit_date": "2015-01-16 09:21:50+00:00",
            "commit_hash": "c80fd6b215449f2ba7228af58979ac8709f74b82",
            "message": "Further comment changes for reformat (master)\nReviewed-by: Tim Hudson <tjh@openssl.org>"
        },
        {
            "author": {
                "email": "geoff@openssl.org",
                "name": "Geoff Thorpe"
            },
            "changes": "diff --git a/crypto/bn/bn_kron.c b/crypto/bn/bn_kron.c--- a/crypto/bn/bn_kron.c+++ b/crypto/bn/bn_kron.c@@ -62,121 +62,123 @@ /* Returns -2 for errors because both -1 and 0 are valid results. */ int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx) \t{ \tint i; \tint ret = -2; /* avoid 'uninitialized' warning */ \tint err = 0; \tBIGNUM *A, *B, *tmp; \t/* In 'tab', only odd-indexed entries are relevant: \t * For any odd BIGNUM n, \t *     tab[BN_lsw(n) & 7] \t * is $(-1)^{(n^2-1)/8}$ (using TeX notation). \t * Note that the sign of n does not matter. \t */ \tstatic const int tab[8] = {0, 1, 0, -1, 0, -1, 0, 1};+\tbn_check_top(a);+\tbn_check_top(b);+ \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tB = BN_CTX_get(ctx); \tif (B == NULL) goto end; \terr = !BN_copy(A, a); \tif (err) goto end; \terr = !BN_copy(B, b); \tif (err) goto end; \t/* \t * Kronecker symbol, imlemented according to Henri Cohen, \t * \"A Course in Computational Algebraic Number Theory\" \t * (algorithm 1.4.10). \t */ \t/* Cohen's step 1: */ \tif (BN_is_zero(B)) \t\t{ \t\tret = BN_abs_is_word(A, 1); \t\tgoto end;  \t\t} \t/* Cohen's step 2: */ \tif (!BN_is_odd(A) && !BN_is_odd(B)) \t\t{ \t\tret = 0; \t\tgoto end; \t\t} \t/* now  B  is non-zero */ \ti = 0; \twhile (!BN_is_bit_set(B, i)) \t\ti++; \terr = !BN_rshift(B, B, i); \tif (err) goto end; \tif (i & 1) \t\t{ \t\t/* i is odd */ \t\t/* (thus  B  was even, thus  A  must be odd!)  */ \t\t/* set 'ret' to $(-1)^{(A^2-1)/8}$ */ \t\tret = tab[BN_lsw(A) & 7]; \t\t} \telse \t\t{ \t\t/* i is even */ \t\tret = 1; \t\t} \tif (B->neg) \t\t{ \t\tB->neg = 0; \t\tif (A->neg) \t\t\tret = -ret; \t\t} \t/* now  B  is positive and odd, so what remains to be done is \t * to compute the Jacobi symbol  (A/B)  and multiply it by 'ret' */ \twhile (1) \t\t{ \t\t/* Cohen's step 3: */ \t\t/*  B  is positive and odd */ \t\tif (BN_is_zero(A)) \t\t\t{ \t\t\tret = BN_is_one(B) ? ret : 0; \t\t\tgoto end; \t\t\t} \t\t/* now  A  is non-zero */ \t\ti = 0; \t\twhile (!BN_is_bit_set(A, i)) \t\t\ti++; \t\terr = !BN_rshift(A, A, i); \t\tif (err) goto end; \t\tif (i & 1) \t\t\t{ \t\t\t/* i is odd */ \t\t\t/* multiply 'ret' by  $(-1)^{(B^2-1)/8}$ */ \t\t\tret = ret * tab[BN_lsw(B) & 7]; \t\t\t} \t\t/* Cohen's step 4: */ \t\t/* multiply 'ret' by  $(-1)^{(A-1)(B-1)/4}$ */ \t\tif ((A->neg ? ~BN_lsw(A) : BN_lsw(A)) & BN_lsw(B) & 2) \t\t\tret = -ret; \t\t/* (A, B) := (B mod |A|, |A|) */ \t\terr = !BN_nnmod(B, B, A, ctx); \t\tif (err) goto end; \t\ttmp = A; A = B; B = tmp; \t\ttmp->neg = 0; \t\t}-\t- end:+end: \tBN_CTX_end(ctx); \tif (err) \t\treturn -2; \telse \t\treturn ret; \t}",
            "commit_date": "2003-12-01 23:11:45+00:00",
            "commit_hash": "b74cc0776b97a55f9a17c67d43d694211f734c75",
            "message": "Add missing bn_check_top()s to bn_kron.c, remove some miscellaneous\nwhite-space, and include extra headers to satisfy debugging builds."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_kron.c b/crypto/bn/bn_kron.c--- a/crypto/bn/bn_kron.c+++ b/crypto/bn/bn_kron.c@@ -64,121 +64,121 @@ /* Returns -2 for errors because both -1 and 0 are valid results. */ int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx) \t{ \tint i;-\tint ret;+\tint ret = -2; /* avoid 'uninitialized' warning */ \tint err = 0; \tBIGNUM *A, *B, *tmp; \t/* In 'tab', only odd-indexed entries are relevant: \t * For any odd BIGNUM n, \t *     tab[BN_lsw(n) & 7] \t * is $(-1)^{(n^2-1)/8}$ (using TeX notation). \t * Note that the sign of n does not matter. \t */ \tstatic const int tab[8] = {0, 1, 0, -1, 0, -1, 0, 1}; \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tB = BN_CTX_get(ctx); \tif (B == NULL) goto end; \terr = !BN_copy(A, a); \tif (err) goto end; \terr = !BN_copy(B, b); \tif (err) goto end; \t/* \t * Kronecker symbol, imlemented according to Henri Cohen, \t * \"A Course in Computational Algebraic Number Theory\" \t * (algorithm 1.4.10). \t */ \t/* Cohen's step 1: */ \tif (BN_is_zero(B)) \t\t{ \t\tret = BN_abs_is_word(A, 1); \t\tgoto end;  \t\t} \t/* Cohen's step 2: */ \tif (!BN_is_odd(A) && !BN_is_odd(B)) \t\t{ \t\tret = 0; \t\tgoto end; \t\t} \t/* now  B  is non-zero */ \ti = 0; \twhile (!BN_is_bit_set(B, i)) \t\ti++; \terr = !BN_rshift(B, B, i); \tif (err) goto end; \tif (i & 1) \t\t{ \t\t/* i is odd */ \t\t/* (thus  B  was even, thus  A  must be odd!)  */ \t\t/* set 'ret' to $(-1)^{(A^2-1)/8}$ */ \t\tret = tab[BN_lsw(A) & 7]; \t\t} \telse \t\t{ \t\t/* i is even */ \t\tret = 1; \t\t} \tif (B->neg) \t\t{ \t\tB->neg = 0; \t\tif (A->neg) \t\t\tret = -ret; \t\t} \t/* now  B  is positive and odd, so what remains to be done is \t * to compute the Jacobi symbol  (A/B)  and multiply it by 'ret' */ \twhile (1) \t\t{ \t\t/* Cohen's step 3: */ \t\t/*  B  is positive and odd */ \t\tif (BN_is_zero(A)) \t\t\t{ \t\t\tret = BN_is_one(B) ? ret : 0; \t\t\tgoto end; \t\t\t} \t\t/* now  A  is non-zero */ \t\ti = 0; \t\twhile (!BN_is_bit_set(A, i)) \t\t\ti++; \t\terr = !BN_rshift(A, A, i); \t\tif (err) goto end; \t\tif (i & 1) \t\t\t{ \t\t\t/* i is odd */ \t\t\t/* multiply 'ret' by  $(-1)^{(B^2-1)/8}$ */ \t\t\tret = ret * tab[BN_lsw(B) & 7]; \t\t\t} \t\t/* Cohen's step 4: */ \t\t/* multiply 'ret' by  $(-1)^{(A-1)(B-1)/4}$ */-\t\tif (BN_lsw(A) & BN_lsw(B) & 2)+\t\tif ((A->neg ? ~BN_lsw(A) : BN_lsw(A)) & BN_lsw(B) & 2) \t\t\tret = -ret; \t\t/* (A, B) := (B mod |A|, |A|) */ \t\terr = !BN_nnmod(B, B, A, ctx); \t\tif (err) goto end; \t\ttmp = A; A = B; B = tmp; \t\ttmp->neg = 0; \t\t}  end: \tBN_CTX_end(ctx); \tif (err) \t\treturn -2; \telse \t\treturn ret; \t}",
            "commit_date": "2000-11-29 19:26:33+00:00",
            "commit_hash": "eb1f1b0a341cbe2c75d8f24b2dc62f4cad05dcec",
            "message": "Fix BN_kronecker so that it works correctly if 'a' is negative\n(we need the two's complement of BN_lsw then)."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_kron.c b/crypto/bn/bn_kron.c--- a/crypto/bn/bn_kron.c+++ b/crypto/bn/bn_kron.c@@ -64,121 +64,121 @@ /* Returns -2 for errors because both -1 and 0 are valid results. */ int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx) \t{ \tint i; \tint ret; \tint err = 0; \tBIGNUM *A, *B, *tmp; \t/* In 'tab', only odd-indexed entries are relevant: \t * For any odd BIGNUM n, \t *     tab[BN_lsw(n) & 7] \t * is $(-1)^{(n^2-1)/8}$ (using TeX notation). \t * Note that the sign of n does not matter. \t */ \tstatic const int tab[8] = {0, 1, 0, -1, 0, -1, 0, 1}; \tBN_CTX_start(ctx); \tA = BN_CTX_get(ctx); \tB = BN_CTX_get(ctx); \tif (B == NULL) goto end; \terr = !BN_copy(A, a); \tif (err) goto end; \terr = !BN_copy(B, b); \tif (err) goto end; \t/* \t * Kronecker symbol, imlemented according to Henri Cohen, \t * \"A Course in Computational Algebraic Number Theory\" \t * (algorithm 1.4.10). \t */ \t/* Cohen's step 1: */ \tif (BN_is_zero(B)) \t\t{ \t\tret = BN_abs_is_word(A, 1); \t\tgoto end;  \t\t} \t/* Cohen's step 2: */ \tif (!BN_is_odd(A) && !BN_is_odd(B)) \t\t{ \t\tret = 0; \t\tgoto end; \t\t} \t/* now  B  is non-zero */ \ti = 0; \twhile (!BN_is_bit_set(B, i)) \t\ti++; \terr = !BN_rshift(B, B, i); \tif (err) goto end; \tif (i & 1) \t\t{ \t\t/* i is odd */ \t\t/* (thus  B  was even, thus  A  must be odd!)  */ \t\t/* set 'ret' to $(-1)^{(A^2-1)/8}$ */ \t\tret = tab[BN_lsw(A) & 7]; \t\t} \telse \t\t{ \t\t/* i is even */ \t\tret = 1; \t\t} \tif (B->neg) \t\t{ \t\tB->neg = 0; \t\tif (A->neg) \t\t\tret = -ret; \t\t} \t/* now  B  is positive and odd, so what remains to be done is \t * to compute the Jacobi symbol  (A/B)  and multiply it by 'ret' */ \twhile (1) \t\t{ \t\t/* Cohen's step 3: */ \t\t/*  B  is positive and odd */ \t\tif (BN_is_zero(A)) \t\t\t{-\t\t\tret = BN_is_one(B);+\t\t\tret = BN_is_one(B) ? ret : 0; \t\t\tgoto end; \t\t\t} \t\t/* now  A  is non-zero */ \t\ti = 0; \t\twhile (!BN_is_bit_set(A, i)) \t\t\ti++; \t\terr = !BN_rshift(A, A, i); \t\tif (err) goto end; \t\tif (i & 1) \t\t\t{ \t\t\t/* i is odd */ \t\t\t/* multiply 'ret' by  $(-1)^{(B^2-1)/8}$ */ \t\t\tret = ret * tab[BN_lsw(B) & 7]; \t\t\t} \t\t/* Cohen's step 4: */ \t\t/* multiply 'ret' by  $(-1)^{(A-1)(B-1)/4}$ */ \t\tif (BN_lsw(A) & BN_lsw(B) & 2) \t\t\tret = -ret; \t\t/* (A, B) := (B mod |A|, |A|) */ \t\terr = !BN_nnmod(B, B, A, ctx); \t\tif (err) goto end; \t\ttmp = A; A = B; B = tmp; \t\ttmp->neg = 0; \t\t}  end: \tBN_CTX_end(ctx); \tif (err) \t\treturn -2; \telse \t\treturn ret; \t}",
            "commit_date": "2000-11-28 07:53:35+00:00",
            "commit_hash": "d79cab27a583a3557a8f45a41326ad2953fde538",
            "message": "Correct a bug in BN_kronecker.\nSketch the test for BN_kronecker."
        },
        {
            "author": {
                "email": "bodo@openssl.org",
                "name": "Bodo M\u00f6ller"
            },
            "changes": "diff --git a/crypto/bn/bn_kron.c b/crypto/bn/bn_kron.c--- /dev/null+++ b/crypto/bn/bn_kron.c@@ -0,0 +64,121 @@+/* Returns -2 for errors because both -1 and 0 are valid results. */+int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx)+\t{+\tint i;+\tint ret;+\tint err = 0;+\tBIGNUM *A, *B, *tmp;+\t/* In 'tab', only odd-indexed entries are relevant:+\t * For any odd BIGNUM n,+\t *     tab[BN_lsw(n) & 7]+\t * is $(-1)^{(n^2-1)/8}$ (using TeX notation).+\t * Note that the sign of n does not matter.+\t */+\tstatic const int tab[8] = {0, 1, 0, -1, 0, -1, 0, 1};++\tBN_CTX_start(ctx);+\tA = BN_CTX_get(ctx);+\tB = BN_CTX_get(ctx);+\tif (B == NULL) goto end;+\t+\terr = !BN_copy(A, a);+\tif (err) goto end;+\terr = !BN_copy(B, b);+\tif (err) goto end;++\t/*+\t * Kronecker symbol, imlemented according to Henri Cohen,+\t * \"A Course in Computational Algebraic Number Theory\"+\t * (algorithm 1.4.10).+\t */++\t/* Cohen's step 1: */++\tif (BN_is_zero(B))+\t\t{+\t\tret = BN_abs_is_word(A, 1);+\t\tgoto end;+ \t\t}+\t+\t/* Cohen's step 2: */++\tif (!BN_is_odd(A) && !BN_is_odd(B))+\t\t{+\t\tret = 0;+\t\tgoto end;+\t\t}++\t/* now  B  is non-zero */+\ti = 0;+\twhile (!BN_is_bit_set(B, i))+\t\ti++;+\terr = !BN_rshift(B, B, i);+\tif (err) goto end;+\tif (i & 1)+\t\t{+\t\t/* i is odd */+\t\t/* (thus  B  was even, thus  A  must be odd!)  */++\t\t/* set 'ret' to $(-1)^{(A^2-1)/8}$ */+\t\tret = tab[BN_lsw(A) & 7];+\t\t}+\telse+\t\t{+\t\t/* i is even */+\t\tret = 1;+\t\t}+\t+\tif (B->neg)+\t\t{+\t\tB->neg = 0;+\t\tif (A->neg)+\t\t\tret = -ret;+\t\t}++\t/* now  B  is positive and odd, so what remains to be done is+\t * to compute the Jacobi symbol  (A/B)  and multiply it by 'ret' */++\twhile (1)+\t\t{+\t\t/* Cohen's step 3: */++\t\t/*  B  is positive and odd */++\t\tif (BN_is_zero(A))+\t\t\t{+\t\t\tret = BN_is_one(B);+\t\t\tgoto end;+\t\t\t}++\t\t/* now  A  is non-zero */+\t\ti = 0;+\t\twhile (!BN_is_bit_set(A, i))+\t\t\ti++;+\t\terr = !BN_rshift(A, A, i);+\t\tif (err) goto end;+\t\tif (i & 1)+\t\t\t{+\t\t\t/* i is odd */+\t\t\t/* multiply 'ret' by  $(-1)^{(B^2-1)/8}$ */+\t\t\tret = ret * tab[BN_lsw(B) & 7];+\t\t\t}+\t+\t\t/* Cohen's step 4: */+\t\t/* multiply 'ret' by  $(-1)^{(A-1)(B-1)/4}$ */+\t\tif (BN_lsw(A) & BN_lsw(B) & 2)+\t\t\tret = -ret;+\t\t+\t\t/* (A, B) := (B mod |A|, |A|) */+\t\terr = !BN_nnmod(B, B, A, ctx);+\t\tif (err) goto end;+\t\ttmp = A; A = B; B = tmp;+\t\ttmp->neg = 0;+\t\t}+\t+ end:+\tBN_CTX_end(ctx);+\tif (err)+\t\treturn -2;+\telse+\t\treturn ret;+\t}",
            "commit_date": "2000-11-28 06:37:43+00:00",
            "commit_hash": "265592b99a3c2d5a8134d2c684620113153b4e1e",
            "message": "Add bn_kron.c (BN_kronecker), which I forgot in the previous commit.\nAlso add the next file in advance so that I can't forget this one :-)"
        }
    ],
    "git log -L18,27:test/namemap_internal_test.c": [
        {
            "author": {
                "email": "rsalz@akamai.com",
                "name": "Rich Salz"
            },
            "changes": "diff --git a/test/namemap_internal_test.c b/test/namemap_internal_test.c--- a/test/namemap_internal_test.c+++ b/test/namemap_internal_test.c@@ -18,10 +18,10 @@ static int test_namemap_empty(void) {-    ok = TEST_true(ossl_namemap_empty(NULL))+    ok = TEST_int_eq(ossl_namemap_empty(NULL), 1)-         && TEST_true(ossl_namemap_empty(nm))+         && TEST_int_eq(ossl_namemap_empty(nm), 1)",
            "commit_date": "2021-02-18 15:31:56-05:00",
            "commit_hash": "cd3f8c1b11b0b9f4163bc8c62cbae38aec1b4030",
            "message": "Always check CRYPTO_LOCK_{read,write}_lock\nSome functions that lock things are void, so we just return early.\nAlso make ossl_namemap_empty return 0 on error.  Updated the docs, and added\nsome code to ossl_namemap_stored() to handle the failure, and updated the\ntests to allow for failure.\nFixes: #14230\nReviewed-by: Shane Lontis <shane.lontis@oracle.com>\nReviewed-by: Paul Dale <pauli@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/14238)\nOSSL_NAMEMAP *nm = NULL;\nint ok;\n&& TEST_ptr(nm = ossl_namemap_new())\n&& TEST_int_ne(ossl_namemap_add_name(nm, 0, NAME1), 0)"
        },
        {
            "author": {
                "email": "paul.dale@oracle.com",
                "name": "Pauli"
            },
            "changes": "diff --git a/test/namemap_internal_test.c b/test/namemap_internal_test.c--- a/test/namemap_internal_test.c+++ b/test/namemap_internal_test.c@@ -18,1 +18,10 @@+static int test_namemap_empty(void)+{+    OSSL_NAMEMAP *nm = NULL;+    int ok;++    ok = TEST_true(ossl_namemap_empty(NULL))+         && TEST_ptr(nm = ossl_namemap_new())+         && TEST_true(ossl_namemap_empty(nm))+         && TEST_int_ne(ossl_namemap_add_name(nm, 0, NAME1), 0)",
            "commit_date": "2020-06-18 11:01:08+10:00",
            "commit_hash": "c720fc35f4aa90cdc7cdc424b976c5322fb0098e",
            "message": "namemap: change ossl_namemap_empty() to do what the documentation says.\nThe function is documented as returning 1 when passed a NULL argument.\nInstead it core dumps.  Added a unit test for this.\nAdditionally, a performance improvement is incorporated.  The namemap\nmax_number field is only ever compared against zero and incremented.\nThe zero comparison grabs a lock specifically for this check.  This change\nuses TSAN operations instead if they are available.\nReviewed-by: Richard Levitte <levitte@openssl.org>\n(Merged from https://github.com/openssl/openssl/pull/12181)"
        },
        {
            "author": {
                "email": "levitte@openssl.org",
                "name": "Richard Levitte"
            },
            "changes": "diff --git a/test/namemap_internal_test.c b/test/namemap_internal_test.c--- /dev/null+++ b/test/namemap_internal_test.c@@ -0,0 +16,1 @@+",
            "commit_date": "2019-05-23 16:00:05+02:00",
            "commit_hash": "734a462e4028e2f0136d3af0b37611138e781246",
            "message": "Add a namemap test\nReviewed-by: Paul Dale <paul.dale@oracle.com>\n(Merged from https://github.com/openssl/openssl/pull/8967)"
        }
    ]
}